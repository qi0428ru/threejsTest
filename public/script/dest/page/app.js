/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(15);


/***/ }),

/***/ 2:
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v1.9.0
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2013-1-14
	 */
	(function( window, undefined ) {
	"use strict";
	var
		// A central reference to the root jQuery(document)
		rootjQuery,

		// The deferred used on DOM ready
		readyList,

		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,
		location = window.location,

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$,

		// [[Class]] -> type pairs
		class2type = {},

		// List of deleted data cache ids, so we can reuse them
		core_deletedIds = [],

		core_version = "1.9.0",

		// Save a reference to some core methods
		core_concat = core_deletedIds.concat,
		core_push = core_deletedIds.push,
		core_slice = core_deletedIds.slice,
		core_indexOf = core_deletedIds.indexOf,
		core_toString = class2type.toString,
		core_hasOwn = class2type.hasOwnProperty,
		core_trim = core_version.trim,

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			return new jQuery.fn.init( selector, context, rootjQuery );
		},

		// Used for matching numbers
		core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

		// Used for splitting on whitespace
		core_rnotwhite = /\S+/g,

		// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		// Match a standalone tag
		rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

		// JSON RegExp
		rvalidchars = /^[\],:{}\s]*$/,
		rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
		rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
		rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		},

		// The ready event handler and self cleanup method
		DOMContentLoaded = function() {
			if ( document.addEventListener ) {
				document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
				jQuery.ready();
			} else if ( document.readyState === "complete" ) {
				// we're here because readyState === "complete" in oldIE
				// which is good enough for us to call the dom ready!
				document.detachEvent( "onreadystatechange", DOMContentLoaded );
				jQuery.ready();
			}
		};

	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: core_version,

		constructor: jQuery,
		init: function( selector, context, rootjQuery ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;

						// scripts is true for back-compat
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id !== match[2] ) {
								return rootjQuery.find( selector );
							}

							// Otherwise, we inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return rootjQuery.ready( selector );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		},

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		// The number of elements contained in the matched element set
		size: function() {
			return this.length;
		},

		toArray: function() {
			return core_slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num == null ?

				// Return a 'clean' array
				this.toArray() :

				// Return just the object
				( num < 0 ? this[ this.length + num ] : this[ num ] );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},

		ready: function( fn ) {
			// Add the callback
			jQuery.ready.promise().done( fn );

			return this;
		},

		slice: function() {
			return this.pushStack( core_slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},

		end: function() {
			return this.prevObject || this.constructor(null);
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: core_push,
		sort: [].sort,
		splice: [].splice
	};

	// Give the init function the jQuery prototype for later instantiation
	jQuery.fn.init.prototype = jQuery.fn;

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if ( length === i ) {
			target = this;
			--i;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({
		noConflict: function( deep ) {
			if ( window.$ === jQuery ) {
				window.$ = _$;
			}

			if ( deep && window.jQuery === jQuery ) {
				window.jQuery = _jQuery;
			}

			return jQuery;
		},

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger("ready").off("ready");
			}
		},

		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray || function( obj ) {
			return jQuery.type(obj) === "array";
		},

		isWindow: function( obj ) {
			return obj != null && obj == obj.window;
		},

		isNumeric: function( obj ) {
			return !isNaN( parseFloat(obj) ) && isFinite( obj );
		},

		type: function( obj ) {
			if ( obj == null ) {
				return String( obj );
			}
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ core_toString.call(obj) ] || "object" :
				typeof obj;
		},

		isPlainObject: function( obj ) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the constructor property.
			// Make sure that DOM nodes and window objects don't pass through, as well
			if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			try {
				// Not own constructor property must be Object
				if ( obj.constructor &&
					!core_hasOwn.call(obj, "constructor") &&
					!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
					return false;
				}
			} catch ( e ) {
				// IE8,9 Will throw exceptions on certain host objects #9897
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for ( key in obj ) {}

			return key === undefined || core_hasOwn.call( obj, key );
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		error: function( msg ) {
			throw new Error( msg );
		},

		// data: string of html
		// context (optional): If specified, the fragment will be created in this context, defaults to document
		// keepScripts (optional): If true, will include scripts passed in the html string
		parseHTML: function( data, context, keepScripts ) {
			if ( !data || typeof data !== "string" ) {
				return null;
			}
			if ( typeof context === "boolean" ) {
				keepScripts = context;
				context = false;
			}
			context = context || document;

			var parsed = rsingleTag.exec( data ),
				scripts = !keepScripts && [];

			// Single tag
			if ( parsed ) {
				return [ context.createElement( parsed[1] ) ];
			}

			parsed = jQuery.buildFragment( [ data ], context, scripts );
			if ( scripts ) {
				jQuery( scripts ).remove();
			}
			return jQuery.merge( [], parsed.childNodes );
		},

		parseJSON: function( data ) {
			// Attempt to parse using the native JSON parser first
			if ( window.JSON && window.JSON.parse ) {
				return window.JSON.parse( data );
			}

			if ( data === null ) {
				return data;
			}

			if ( typeof data === "string" ) {

				// Make sure leading/trailing whitespace is removed (IE can't handle it)
				data = jQuery.trim( data );

				if ( data ) {
					// Make sure the incoming data is actual JSON
					// Logic borrowed from http://json.org/json2.js
					if ( rvalidchars.test( data.replace( rvalidescape, "@" )
						.replace( rvalidtokens, "]" )
						.replace( rvalidbraces, "")) ) {

						return ( new Function( "return " + data ) )();
					}
				}
			}

			jQuery.error( "Invalid JSON: " + data );
		},

		// Cross-browser xml parsing
		parseXML: function( data ) {
			var xml, tmp;
			if ( !data || typeof data !== "string" ) {
				return null;
			}
			try {
				if ( window.DOMParser ) { // Standard
					tmp = new DOMParser();
					xml = tmp.parseFromString( data , "text/xml" );
				} else { // IE
					xml = new ActiveXObject( "Microsoft.XMLDOM" );
					xml.async = "false";
					xml.loadXML( data );
				}
			} catch( e ) {
				xml = undefined;
			}
			if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
				jQuery.error( "Invalid XML: " + data );
			}
			return xml;
		},

		noop: function() {},

		// Evaluates a script in a global context
		// Workarounds based on findings by Jim Driscoll
		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
		globalEval: function( data ) {
			if ( data && jQuery.trim( data ) ) {
				// We use execScript on Internet Explorer
				// We use an anonymous function so that context is window
				// rather than jQuery in Firefox
				( window.execScript || function( data ) {
					window[ "eval" ].call( window, data );
				} )( data );
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );

			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				}

			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				}
			}

			return obj;
		},

		// Use native String.trim function wherever possible
		trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
			function( text ) {
				return text == null ?
					"" :
					core_trim.call( text );
			} :

			// Otherwise use our own trimming functionality
			function( text ) {
				return text == null ?
					"" :
					( text + "" ).replace( rtrim, "" );
			},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					core_push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			var len;

			if ( arr ) {
				if ( core_indexOf ) {
					return core_indexOf.call( arr, elem, i );
				}

				len = arr.length;
				i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

				for ( ; i < len; i++ ) {
					// Skip accessing in sparse arrays
					if ( i in arr && arr[ i ] === elem ) {
						return i;
					}
				}
			}

			return -1;
		},

		merge: function( first, second ) {
			var l = second.length,
				i = first.length,
				j = 0;

			if ( typeof l === "number" ) {
				for ( ; j < l; j++ ) {
					first[ i++ ] = second[ j ];
				}
			} else {
				while ( second[j] !== undefined ) {
					first[ i++ ] = second[ j++ ];
				}
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, inv ) {
			var retVal,
				ret = [],
				i = 0,
				length = elems.length;
			inv = !!inv;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				retVal = !!callback( elems[ i ], i );
				if ( inv !== retVal ) {
					ret.push( elems[ i ] );
				}
			}

			return ret;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];

			// Go through the array, translating each of the items to their
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret[ ret.length ] = value;
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret[ ret.length ] = value;
					}
				}
			}

			// Flatten any nested arrays
			return core_concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = core_slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		// Multifunctional method to get and set values of a collection
		// The value/s can optionally be executed if it's a function
		access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
			var i = 0,
				length = elems.length,
				bulk = key == null;

			// Sets many values
			if ( jQuery.type( key ) === "object" ) {
				chainable = true;
				for ( i in key ) {
					jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
				}

			// Sets one value
			} else if ( value !== undefined ) {
				chainable = true;

				if ( !jQuery.isFunction( value ) ) {
					raw = true;
				}

				if ( bulk ) {
					// Bulk operations run against the entire set
					if ( raw ) {
						fn.call( elems, value );
						fn = null;

					// ...except when executing function values
					} else {
						bulk = fn;
						fn = function( elem, key, value ) {
							return bulk.call( jQuery( elem ), value );
						};
					}
				}

				if ( fn ) {
					for ( ; i < length; i++ ) {
						fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
					}
				}
			}

			return chainable ?
				elems :

				// Gets
				bulk ?
					fn.call( elems ) :
					length ? fn( elems[0], key ) : emptyGet;
		},

		now: function() {
			return ( new Date() ).getTime();
		}
	});

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// we once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );

			// Standards-based browsers support DOMContentLoaded
			} else if ( document.addEventListener ) {
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", jQuery.ready, false );

			// If IE event model is used
			} else {
				// Ensure firing before onload, maybe late but safe also for iframes
				document.attachEvent( "onreadystatechange", DOMContentLoaded );

				// A fallback to window.onload, that will always work
				window.attachEvent( "onload", jQuery.ready );

				// If IE and not a frame
				// continually check to see if the document is ready
				var top = false;

				try {
					top = window.frameElement == null && document.documentElement;
				} catch(e) {}

				if ( top && top.doScroll ) {
					(function doScrollCheck() {
						if ( !jQuery.isReady ) {

							try {
								// Use the trick by Diego Perini
								// http://javascript.nwbox.com/IEContentLoaded/
								top.doScroll("left");
							} catch(e) {
								return setTimeout( doScrollCheck, 50 );
							}

							// and execute any waiting functions
							jQuery.ready();
						}
					})();
				}
			}
		}
		return readyList.promise( obj );
	};

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});

	function isArraylike( obj ) {
		var length = obj.length,
			type = jQuery.type( obj );

		if ( jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.nodeType === 1 && length ) {
			return true;
		}

		return type === "array" || type !== "function" &&
			( length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj );
	}

	// All jQuery objects should point back to these
	rootjQuery = jQuery(document);
	// String to Object options format cache
	var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );

		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Control if a given callback is in the list
				has: function( fn ) {
					return jQuery.inArray( fn, list ) > -1;
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( list && ( !fired || stack ) ) {
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};
	jQuery.extend({

		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var action = tuple[ 0 ],
									fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = core_slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
						if( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}

			// if we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	});
	jQuery.support = (function() {

		var support, all, a, select, opt, input, fragment, eventName, isSupported, i,
			div = document.createElement("div");

		// Setup
		div.setAttribute( "className", "t" );
		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

		// Support tests won't run in some limited or non-browser environments
		all = div.getElementsByTagName("*");
		a = div.getElementsByTagName("a")[ 0 ];
		if ( !all || !a || !all.length ) {
			return {};
		}

		// First batch of tests
		select = document.createElement("select");
		opt = select.appendChild( document.createElement("option") );
		input = div.getElementsByTagName("input")[ 0 ];

		a.style.cssText = "top:1px;float:left;opacity:.5";
		support = {
			// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
			getSetAttribute: div.className !== "t",

			// IE strips leading whitespace when .innerHTML is used
			leadingWhitespace: div.firstChild.nodeType === 3,

			// Make sure that tbody elements aren't automatically inserted
			// IE will insert them into empty tables
			tbody: !div.getElementsByTagName("tbody").length,

			// Make sure that link elements get serialized correctly by innerHTML
			// This requires a wrapper element in IE
			htmlSerialize: !!div.getElementsByTagName("link").length,

			// Get the style information from getAttribute
			// (IE uses .cssText instead)
			style: /top/.test( a.getAttribute("style") ),

			// Make sure that URLs aren't manipulated
			// (IE normalizes it by default)
			hrefNormalized: a.getAttribute("href") === "/a",

			// Make sure that element opacity exists
			// (IE uses filter instead)
			// Use a regex to work around a WebKit issue. See #5145
			opacity: /^0.5/.test( a.style.opacity ),

			// Verify style float existence
			// (IE uses styleFloat instead of cssFloat)
			cssFloat: !!a.style.cssFloat,

			// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
			checkOn: !!input.value,

			// Make sure that a selected-by-default option has a working selected property.
			// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
			optSelected: opt.selected,

			// Tests for enctype support on a form (#6743)
			enctype: !!document.createElement("form").enctype,

			// Makes sure cloning an html5 element does not cause problems
			// Where outerHTML is undefined, this still works
			html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

			// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
			boxModel: document.compatMode === "CSS1Compat",

			// Will be defined later
			deleteExpando: true,
			noCloneEvent: true,
			inlineBlockNeedsLayout: false,
			shrinkWrapBlocks: false,
			reliableMarginRight: true,
			boxSizingReliable: true,
			pixelPosition: false
		};

		// Make sure checked status is properly cloned
		input.checked = true;
		support.noCloneChecked = input.cloneNode( true ).checked;

		// Make sure that the options inside disabled selects aren't marked as disabled
		// (WebKit marks them as disabled)
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<9
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}

		// Check if we can trust getAttribute("value")
		input = document.createElement("input");
		input.setAttribute( "value", "" );
		support.input = input.getAttribute( "value" ) === "";

		// Check if an input maintains its value after becoming a radio
		input.value = "t";
		input.setAttribute( "type", "radio" );
		support.radioValue = input.value === "t";

		// #11217 - WebKit loses check when the name is after the checked attribute
		input.setAttribute( "checked", "t" );
		input.setAttribute( "name", "t" );

		fragment = document.createDocumentFragment();
		fragment.appendChild( input );

		// Check if a disconnected checkbox will retain its checked
		// value of true after appended to the DOM (IE6/7)
		support.appendChecked = input.checked;

		// WebKit doesn't clone checked state correctly in fragments
		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<9
		// Opera does not clone events (and typeof div.attachEvent === undefined).
		// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
		if ( div.attachEvent ) {
			div.attachEvent( "onclick", function() {
				support.noCloneEvent = false;
			});

			div.cloneNode( true ).click();
		}

		// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
		// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php
		for ( i in { submit: true, change: true, focusin: true }) {
			div.setAttribute( eventName = "on" + i, "t" );

			support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
		}

		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		// Run tests that need a body at doc ready
		jQuery(function() {
			var container, marginDiv, tds,
				divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
				body = document.getElementsByTagName("body")[0];

			if ( !body ) {
				// Return for frameset docs that don't have a body
				return;
			}

			container = document.createElement("div");
			container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

			body.appendChild( container ).appendChild( div );

			// Support: IE8
			// Check if table cells still have offsetWidth/Height when they are set
			// to display:none and there are still other visible table cells in a
			// table row; if so, offsetWidth/Height are not reliable for use when
			// determining if an element has been hidden directly using
			// display:none (it is still safe to use offsets if a parent element is
			// hidden; don safety goggles and see bug #4512 for more information).
			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
			tds = div.getElementsByTagName("td");
			tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
			isSupported = ( tds[ 0 ].offsetHeight === 0 );

			tds[ 0 ].style.display = "";
			tds[ 1 ].style.display = "none";

			// Support: IE8
			// Check if empty table cells still have offsetWidth/Height
			support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

			// Check box-sizing and margin behavior
			div.innerHTML = "";
			div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
			support.boxSizing = ( div.offsetWidth === 4 );
			support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

			// Use window.getComputedStyle because jsdom on node.js will break without it.
			if ( window.getComputedStyle ) {
				support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
				support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// Fails in WebKit before Feb 2011 nightlies
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				marginDiv = div.appendChild( document.createElement("div") );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";

				support.reliableMarginRight =
					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
			}

			if ( typeof div.style.zoom !== "undefined" ) {
				// Support: IE<8
				// Check if natively block-level elements act like inline-block
				// elements when setting their display to 'inline' and giving
				// them layout
				div.innerHTML = "";
				div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
				support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

				// Support: IE6
				// Check if elements with layout shrink-wrap their children
				div.style.display = "block";
				div.innerHTML = "<div></div>";
				div.firstChild.style.width = "5px";
				support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				body.style.zoom = 1;
			}

			body.removeChild( container );

			// Null elements to avoid leaks in IE
			container = div = tds = marginDiv = null;
		});

		// Null elements to avoid leaks in IE
		all = select = fragment = opt = a = input = null;

		return support;
	})();

	var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
		rmultiDash = /([A-Z])/g;
		
	function internalData( elem, name, data, pvt /* Internal Use Only */ ){
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	}

	function internalRemoveData( elem, name, pvt /* For internal use only */ ){
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				} else {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = name.concat( jQuery.map( name, jQuery.camelCase ) );
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	}

	jQuery.extend({
		cache: {},

		// Unique for each copy of jQuery on the page
		// Non-digits removed to match rinlinejQuery
		expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

		// The following elements throw uncatchable exceptions if you
		// attempt to add expando properties to them.
		noData: {
			"embed": true,
			// Ban all objects except for Flash (which handle expandos)
			"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
			"applet": true
		},

		hasData: function( elem ) {
			elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
			return !!elem && !isEmptyDataObject( elem );
		},

		data: function( elem, name, data ) {
			return internalData( elem, name, data, false );
		},

		removeData: function( elem, name ) {
			return internalRemoveData( elem, name, false );
		},

		// For internal use only.
		_data: function( elem, name, data ) {
			return internalData( elem, name, data, true );
		},
		
		_removeData: function( elem, name ) {
			return internalRemoveData( elem, name, true );
		},

		// A method for determining if a DOM node can handle the data expando
		acceptData: function( elem ) {
			var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

			// nodes accept data unless otherwise specified; rejection can be conditional
			return !noData || noData !== true && elem.getAttribute("classid") === noData;
		}
	});

	jQuery.fn.extend({
		data: function( key, value ) {
			var attrs, name,
				elem = this[0],
				i = 0,
				data = null;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = jQuery.data( elem );

					if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
						attrs = elem.attributes;
						for ( ; i < attrs.length; i++ ) {
							name = attrs[i].name;

							if ( !name.indexOf( "data-" ) ) {
								name = jQuery.camelCase( name.substring(5) );

								dataAttr( elem, name, data[ name ] );
							}
						}
						jQuery._data( elem, "parsedAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					jQuery.data( this, key );
				});
			}

			return jQuery.access( this, function( value ) {

				if ( value === undefined ) {
					// Try to fetch any internally stored data first
					return elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
				}

				this.each(function() {
					jQuery.data( this, key, value );
				});
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each(function() {
				jQuery.removeData( this, key );
			});
		}
	});

	function dataAttr( elem, key, data ) {
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {

			var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}

				// Make sure we set the data so it isn't changed later
				jQuery.data( elem, key, data );

			} else {
				data = undefined;
			}
		}

		return data;
	}

	// checks a cache object for emptiness
	function isEmptyDataObject( obj ) {
		var name;
		for ( name in obj ) {

			// if the public data object is empty, the private is still empty
			if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
				continue;
			}
			if ( name !== "toJSON" ) {
				return false;
			}
		}

		return true;
	}
	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = jQuery._data( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray(data) ) {
						queue = jQuery._data( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			hooks.cur = fn;
			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// not intended for public consumption - generates a queueHooks object, or returns the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return jQuery._data( elem, key ) || jQuery._data( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					jQuery._removeData( elem, type + "queue" );
					jQuery._removeData( elem, key );
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}

			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );

					// ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		// Based off of the plugin by Clint Helfers, with permission.
		// http://blindsignals.com/index.php/2009/07/jquery-delay/
		delay: function( time, type ) {
			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
			type = type || "fx";

			return this.queue( type, function( next, hooks ) {
				var timeout = setTimeout( next, time );
				hooks.stop = function() {
					clearTimeout( timeout );
				};
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while( i-- ) {
				tmp = jQuery._data( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var nodeHook, boolHook,
		rclass = /[\t\r\n]/g,
		rreturn = /\r/g,
		rfocusable = /^(?:input|select|textarea|button|object)$/i,
		rclickable = /^(?:a|area)$/i,
		rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,
		ruseDefault = /^(?:checked|selected)$/i,
		getSetAttribute = jQuery.support.getSetAttribute,
		getSetInput = jQuery.support.input;

	jQuery.fn.extend({
		attr: function( name, value ) {
			return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		},

		prop: function( name, value ) {
			return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			name = jQuery.propFix[ name ] || name;
			return this.each(function() {
				// try/catch handles cases where IE balks (such as removing a property on window)
				try {
					this[ name ] = undefined;
					delete this[ name ];
				} catch( e ) {}
			});
		},

		addClass: function( value ) {
			var classes, elem, cur, clazz, j,
				i = 0,
				len = this.length,
				proceed = typeof value === "string" && value;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}

			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( core_rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
						elem.className = jQuery.trim( cur );

					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, clazz, j,
				i = 0,
				len = this.length,
				proceed = arguments.length === 0 || typeof value === "string" && value;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( core_rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
						elem.className = value ? jQuery.trim( cur ) : "";
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isBool = typeof stateVal === "boolean";

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}

			return this.each(function() {
				if ( type === "string" ) {
					// toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						state = stateVal,
						classNames = value.match( core_rnotwhite ) || [];

					while ( (className = classNames[ i++ ]) ) {
						// check each className given, space separated list
						state = isBool ? state : !self.hasClass( className );
						self[ state ? "addClass" : "removeClass" ]( className );
					}

				// Toggle whole class name
				} else if ( type === "undefined" || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						jQuery._data( this, "__className__", this.className );
					}

					// If the element has a class name or if we're passed "false",
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
				}
			});
		},

		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}

			return false;
		},

		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?
						// handle most common string cases
						ret.replace(rreturn, "") :
						// handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each(function( i ) {
				var val,
					self = jQuery(this);

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, self.val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
				} else if ( typeof val === "number" ) {
					val += "";
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map(val, function ( value ) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					// attributes.value is undefined in Blackberry 4.7 but
					// uses .value. See #6932
					var val = elem.attributes.value;
					return !val || val.specified ? elem.value : elem.text;
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// oldIE doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var values = jQuery.makeArray( value );

					jQuery(elem).find("option").each(function() {
						this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
					});

					if ( !values.length ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		},

		attr: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;

			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( notxml ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
			}

			if ( value !== undefined ) {

				if ( value === null ) {
					jQuery.removeAttr( elem, name );

				} else if ( hooks && notxml && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;

				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}

			} else if ( hooks && notxml && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {

				// In IE9+, Flash objects don't have .getAttribute (#12945)
				// Support: IE9+
				if ( typeof elem.getAttribute !== "undefined" ) {
					ret =  elem.getAttribute( name );
				}

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( core_rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( rboolean.test( name ) ) {
						// Set corresponding property to false for boolean attributes
						// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8
						if ( !getSetAttribute && ruseDefault.test( name ) ) {
							elem[ jQuery.camelCase( "default-" + name ) ] =
								elem[ propName ] = false;
						} else {
							elem[ propName ] = false;
						}

					// See #9699 for explanation of this approach (setting first, then removal)
					} else {
						jQuery.attr( elem, name, "" );
					}

					elem.removeAttribute( getSetAttribute ? name : propName );
				}
			}
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
						// Setting the type on a radio button after the value resets the value in IE6-9
						// Reset value to default in case type is set after value during creation
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		propFix: {
			tabindex: "tabIndex",
			readonly: "readOnly",
			"for": "htmlFor",
			"class": "className",
			maxlength: "maxLength",
			cellspacing: "cellSpacing",
			cellpadding: "cellPadding",
			rowspan: "rowSpan",
			colspan: "colSpan",
			usemap: "useMap",
			frameborder: "frameBorder",
			contenteditable: "contentEditable"
		},

		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;

			// don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;

				} else {
					return ( elem[ name ] = value );
				}

			} else {
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
					return ret;

				} else {
					return elem[ name ];
				}
			}
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {
					// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					var attributeNode = elem.getAttributeNode("tabindex");

					return attributeNode && attributeNode.specified ?
						parseInt( attributeNode.value, 10 ) :
						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							undefined;
				}
			}
		}
	});

	// Hook for boolean attributes
	boolHook = {
		get: function( elem, name ) {
			var
				// Use .prop to determine if this attribute is understood as boolean
				prop = jQuery.prop( elem, name ),

				// Fetch it accordingly
				attr = typeof prop === "boolean" && elem.getAttribute( name ),
				detail = typeof prop === "boolean" ?

					getSetInput && getSetAttribute ?
						attr != null :
						// oldIE fabricates an empty string for missing boolean attributes
						// and conflates checked/selected into attroperties
						ruseDefault.test( name ) ?
							elem[ jQuery.camelCase( "default-" + name ) ] :
							!!attr :

					// fetch an attribute node for properties not recognized as boolean
					elem.getAttributeNode( name );

			return detail && detail.value !== false ?
				name.toLowerCase() :
				undefined;
		},
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
				// IE<8 needs the *property* name
				elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

			// Use defaultChecked and defaultSelected for oldIE
			} else {
				elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
			}

			return name;
		}
	};

	// fix oldIE value attroperty
	if ( !getSetInput || !getSetAttribute ) {
		jQuery.attrHooks.value = {
			get: function( elem, name ) {
				var ret = elem.getAttributeNode( name );
				return jQuery.nodeName( elem, "input" ) ?

					// Ignore the value *property* by using defaultValue
					elem.defaultValue :

					ret && ret.specified ? ret.value : undefined;
			},
			set: function( elem, value, name ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					// Does not return so that setAttribute is also used
					elem.defaultValue = value;
				} else {
					// Use nodeHook if defined (#1954); otherwise setAttribute is fine
					return nodeHook && nodeHook.set( elem, value, name );
				}
			}
		};
	}

	// IE6/7 do not support getting/setting some attributes with get/setAttribute
	if ( !getSetAttribute ) {

		// Use this for any attribute in IE6/7
		// This fixes almost every IE6/7 issue
		nodeHook = jQuery.valHooks.button = {
			get: function( elem, name ) {
				var ret = elem.getAttributeNode( name );
				return ret && ( name === "id" || name === "name" || name === "coords" ? ret.value !== "" : ret.specified ) ?
					ret.value :
					undefined;
			},
			set: function( elem, value, name ) {
				// Set the existing or create a new attribute node
				var ret = elem.getAttributeNode( name );
				if ( !ret ) {
					elem.setAttributeNode(
						(ret = elem.ownerDocument.createAttribute( name ))
					);
				}

				ret.value = value += "";

				// Break association with cloned elements by also using setAttribute (#9646)
				return name === "value" || value === elem.getAttribute( name ) ?
					value :
					undefined;
			}
		};

		// Set contenteditable to false on removals(#10429)
		// Setting to empty string throws an error as an invalid value
		jQuery.attrHooks.contenteditable = {
			get: nodeHook.get,
			set: function( elem, value, name ) {
				nodeHook.set( elem, value === "" ? false : value, name );
			}
		};

		// Set width and height to auto instead of 0 on empty string( Bug #8150 )
		// This is for removals
		jQuery.each([ "width", "height" ], function( i, name ) {
			jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
				set: function( elem, value ) {
					if ( value === "" ) {
						elem.setAttribute( name, "auto" );
						return value;
					}
				}
			});
		});
	}


	// Some attributes require a special call on IE
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !jQuery.support.hrefNormalized ) {
		jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
			jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
				get: function( elem ) {
					var ret = elem.getAttribute( name, 2 );
					return ret == null ? undefined : ret;
				}
			});
		});

		// href/src property should get the full normalized URL (#10299/#12915)
		jQuery.each([ "href", "src" ], function( i, name ) {
			jQuery.propHooks[ name ] = {
				get: function( elem ) {
					return elem.getAttribute( name, 4 );
				}
			};
		});
	}

	if ( !jQuery.support.style ) {
		jQuery.attrHooks.style = {
			get: function( elem ) {
				// Return undefined in the case of empty string
				// Note: IE uppercases css property names, but if we were to .toLowerCase()
				// .cssText, that would destroy case senstitivity in URL's, like in "background"
				return elem.style.cssText || undefined;
			},
			set: function( elem, value ) {
				return ( elem.style.cssText = value + "" );
			}
		};
	}

	// Safari mis-reports the default selected property of an option
	// Accessing the parent's selectedIndex property fixes it
	if ( !jQuery.support.optSelected ) {
		jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
			get: function( elem ) {
				var parent = elem.parentNode;

				if ( parent ) {
					parent.selectedIndex;

					// Make sure that it also works with optgroups, see #5701
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
				return null;
			}
		});
	}

	// IE6/7 call enctype encoding
	if ( !jQuery.support.enctype ) {
		jQuery.propFix.enctype = "encoding";
	}

	// Radios and checkboxes getter/setter
	if ( !jQuery.support.checkOn ) {
		jQuery.each([ "radio", "checkbox" ], function() {
			jQuery.valHooks[ this ] = {
				get: function( elem ) {
					// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
					return elem.getAttribute("value") === null ? "on" : elem.value;
				}
			};
		});
	}
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		});
	});
	var rformElems = /^(?:input|select|textarea)$/i,
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				// Don't attach events to noData or text/comment nodes (but allow plain objects)
				elemData = elem.nodeType !== 3 && elem.nodeType !== 8 && jQuery._data( elem );

			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
						jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
						undefined;
				};
				// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
				eventHandle.elem = elem;
			}

			// Handle multiple events separated by a space
			// jQuery(...).bind("mouseover mouseout", fn);
			types = ( types || "" ).match( core_rnotwhite ) || [""];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener/attachEvent if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						// Bind the global event handler to the element
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );

						} else if ( elem.attachEvent ) {
							elem.attachEvent( "on" + type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

			// Nullify elem to prevent memory leaks in IE
			elem = null;
		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = jQuery.hasData( elem ) && jQuery._data( elem );

			if ( !elemData || !(events = elemData.events) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( core_rnotwhite ) || [""];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;

				// removeData also checks for emptiness and clears the expando if empty
				// so use it instead of delete
				jQuery._removeData( elem, "events" );
			}
		},

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = event.type || event,
				namespaces = event.namespace ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			event.isTrigger = true;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
					event.preventDefault();
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
					!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Can't use an .isFunction() check here because IE6/7 fails that test.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						try {
							elem[ type ]();
						} catch ( e ) {
							// IE<9 dies on focus/blur to hidden element (#1486,#12518)
							// only reproducible on winXP IE8 native, not IE9 in IE8 mode
						}
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = core_slice.call( arguments ),
				handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or
					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

				for ( ; cur != this; cur = cur.parentNode || this ) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}

			return handlerQueue;
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop,
				originalEvent = event,
				fixHook = jQuery.event.fixHooks[ event.type ] || {},
				copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: IE<9
			// Fix target property (#1925)
			if ( !event.target ) {
				event.target = originalEvent.srcElement || document;
			}

			// Support: Chrome 23+, Safari?
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			// Support: IE<9
			// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
			event.metaKey = !!event.metaKey;

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button,
					fromElement = original.fromElement;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add relatedTarget, if necessary
				if ( !event.relatedTarget && fromElement ) {
					event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
						this.click();
						return false;
					}
				}
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== document.activeElement && this.focus ) {
						try {
							this.focus();
							return false;
						} catch ( e ) {
							// Support: IE<9
							// If we error on focus to hidden element (#1486, #12518),
							// let .trigger() run the handlers
						}
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === document.activeElement && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Even when returnValue equals to undefined Firefox will still show alert
					if ( event.result !== undefined ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},

		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{ type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};

	jQuery.removeEvent = document.removeEventListener ?
		function( elem, type, handle ) {
			if ( elem.removeEventListener ) {
				elem.removeEventListener( type, handle, false );
			}
		} :
		function( elem, type, handle ) {
			var name = "on" + type;

			if ( elem.detachEvent ) {

				// #8545, #7054, preventing memory leaks for custom events in IE6-8
				// detachEvent needed property on element, by name of that event, to properly expose it to GC
				if ( typeof elem[ name ] === "undefined" ) {
					elem[ name ] = null;
				}

				elem.detachEvent( name, handle );
			}
		};

	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
				src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;
			if ( !e ) {
				return;
			}

			// If preventDefault exists, run it on the original event
			if ( e.preventDefault ) {
				e.preventDefault();

			// Support: IE
			// Otherwise set the returnValue property of the original event to false
			} else {
				e.returnValue = false;
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;
			if ( !e ) {
				return;
			}
			// If stopPropagation exists, run it on the original event
			if ( e.stopPropagation ) {
				e.stopPropagation();
			}

			// Support: IE
			// Set the cancelBubble property of the original event to true
			e.cancelBubble = true;
		},
		stopImmediatePropagation: function() {
			this.isImmediatePropagationStopped = returnTrue;
			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});

	// IE submit delegation
	if ( !jQuery.support.submitBubbles ) {

		jQuery.event.special.submit = {
			setup: function() {
				// Only need this for delegated form submit events
				if ( jQuery.nodeName( this, "form" ) ) {
					return false;
				}

				// Lazy-add a submit handler when a descendant form may potentially be submitted
				jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
					// Node name check avoids a VML-related crash in IE (#9807)
					var elem = e.target,
						form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
					if ( form && !jQuery._data( form, "submitBubbles" ) ) {
						jQuery.event.add( form, "submit._submit", function( event ) {
							event._submit_bubble = true;
						});
						jQuery._data( form, "submitBubbles", true );
					}
				});
				// return undefined since we don't need an event listener
			},

			postDispatch: function( event ) {
				// If form was submitted by the user, bubble the event up the tree
				if ( event._submit_bubble ) {
					delete event._submit_bubble;
					if ( this.parentNode && !event.isTrigger ) {
						jQuery.event.simulate( "submit", this.parentNode, event, true );
					}
				}
			},

			teardown: function() {
				// Only need this for delegated form submit events
				if ( jQuery.nodeName( this, "form" ) ) {
					return false;
				}

				// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
				jQuery.event.remove( this, "._submit" );
			}
		};
	}

	// IE change delegation and checkbox/radio fix
	if ( !jQuery.support.changeBubbles ) {

		jQuery.event.special.change = {

			setup: function() {

				if ( rformElems.test( this.nodeName ) ) {
					// IE doesn't fire change on a check/radio until blur; trigger it on click
					// after a propertychange. Eat the blur-change in special.change.handle.
					// This still fires onchange a second time for check/radio after blur.
					if ( this.type === "checkbox" || this.type === "radio" ) {
						jQuery.event.add( this, "propertychange._change", function( event ) {
							if ( event.originalEvent.propertyName === "checked" ) {
								this._just_changed = true;
							}
						});
						jQuery.event.add( this, "click._change", function( event ) {
							if ( this._just_changed && !event.isTrigger ) {
								this._just_changed = false;
							}
							// Allow triggered, simulated change events (#11500)
							jQuery.event.simulate( "change", this, event, true );
						});
					}
					return false;
				}
				// Delegated event; lazy-add a change handler on descendant inputs
				jQuery.event.add( this, "beforeactivate._change", function( e ) {
					var elem = e.target;

					if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
						jQuery.event.add( elem, "change._change", function( event ) {
							if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
								jQuery.event.simulate( "change", this.parentNode, event, true );
							}
						});
						jQuery._data( elem, "changeBubbles", true );
					}
				});
			},

			handle: function( event ) {
				var elem = event.target;

				// Swallow native change events from checkbox/radio, we already triggered them above
				if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
					return event.handleObj.handler.apply( this, arguments );
				}
			},

			teardown: function() {
				jQuery.event.remove( this, "._change" );

				return !rformElems.test( this.nodeName );
			}
		};
	}

	// Create "bubbling" focus and blur events
	if ( !jQuery.support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler while someone wants focusin/focusout
			var attaches = 0,
				handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};

			jQuery.event.special[ fix ] = {
				setup: function() {
					if ( attaches++ === 0 ) {
						document.addEventListener( orig, handler, true );
					}
				},
				teardown: function() {
					if ( --attaches === 0 ) {
						document.removeEventListener( orig, handler, true );
					}
				}
			};
		});
	}

	jQuery.fn.extend({

		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}

			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		},

		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		},

		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	});

	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};

		if ( rkeyEvent.test( name ) ) {
			jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
		}

		if ( rmouseEvent.test( name ) ) {
			jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
		}
	});
	/*!
	 * Sizzle CSS Selector Engine
	 * Copyright 2012 jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://sizzlejs.com/
	 */
	(function( window, undefined ) {

	var i,
		cachedruns,
		Expr,
		getText,
		isXML,
		compile,
		hasDuplicate,
		outermostContext,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsXML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
		sortOrder,

		// Instance-specific data
		expando = "sizzle" + -(new Date()),
		preferredDoc = window.document,
		support = {},
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),

		// General-purpose constants
		strundefined = typeof undefined,
		MAX_NEGATIVE = 1 << 31,

		// Array methods
		arr = [],
		pop = arr.pop,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf if we can't use a native one
		indexOf = arr.indexOf || function( elem ) {
			var i = 0,
				len = this.length;
			for ( ; i < len; i++ ) {
				if ( this[i] === elem ) {
					return i;
				}
			}
			return -1;
		},


		// Regular expressions

		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),

		// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
		operators = "([*^$|!~]?=)",
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
			"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

		// Prefer arguments quoted,
		//   then not containing pseudos/brackets,
		//   then attribute selectors/non-parenthetical expressions,
		//   then anything else
		// These preferences are here to reduce the number of selectors
		//   needing tokenize in the PSEUDO preFilter
		pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rsibling = /[\x20\t\r\n\f]*[+~]/,

		rnative = /\{\s*\[native code\]\s*\}/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rescape = /'|\\/g,
		rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
		funescape = function( _, escaped ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			return high !== high ?
				escaped :
				// BMP codepoint
				high < 0 ?
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		};

	// Use a stripped-down slice if we can't use a native one
	try {
		slice.call( docElem.childNodes, 0 )[0].nodeType;
	} catch ( e ) {
		slice = function( i ) {
			var elem,
				results = [];
			for ( ; (elem = this[i]); i++ ) {
				results.push( elem );
			}
			return results;
		};
	}

	/**
	 * For feature detection
	 * @param {Function} fn The function to test for native support
	 */
	function isNative( fn ) {
		return rnative.test( fn + "" );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var cache,
			keys = [];

		return (cache = function( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key += " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key ] = value);
		});
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	}

	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}

		context = context || document;
		results = results || [];

		if ( !selector || typeof selector !== "string" ) {
			return results;
		}

		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
			return [];
		}

		if ( !documentIsXML && !seed ) {

			// Shortcuts
			if ( (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}

				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
					return results;

				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {
					push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
					return results;
				}
			}

			// QSA path
			if ( support.qsa && !rbuggyQSA.test(selector) ) {
				old = true;
				nid = expando;
				newContext = context;
				newSelector = nodeType === 9 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && context.parentNode || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Detect xml
	 * @param {Element|Object} elem An element or a document
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var doc = node ? node.ownerDocument || node : preferredDoc;

		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Set our document
		document = doc;
		docElem = doc.documentElement;

		// Support tests
		documentIsXML = isXML( doc );

		// Check if getElementsByTagName("*") returns only elements
		support.tagNameNoComments = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Check if attributes should be retrieved by attribute nodes
		support.attributes = assert(function( div ) {
			div.innerHTML = "<select></select>";
			var type = typeof div.lastChild.getAttribute("multiple");
			// IE8 returns a string for some attributes even when not present
			return type !== "boolean" && type !== "string";
		});

		// Check if getElementsByClassName can be trusted
		support.getByClassName = assert(function( div ) {
			// Opera can't find a second classname (in 9.6)
			div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
			if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
				return false;
			}

			// Safari 3.2 caches class attributes and doesn't catch changes
			div.lastChild.className = "e";
			return div.getElementsByClassName("e").length === 2;
		});

		// Check if getElementById returns elements by name
		// Check if getElementsByName privileges form controls or returns elements by ID
		support.getByName = assert(function( div ) {
			// Inject content
			div.id = expando + 0;
			div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
			docElem.insertBefore( div, docElem.firstChild );

			// Test
			var pass = doc.getElementsByName &&
				// buggy browsers will return fewer than the correct 2
				doc.getElementsByName( expando ).length === 2 +
				// buggy browsers will return more than the correct 0
				doc.getElementsByName( expando + 0 ).length;
			support.getIdNotName = !doc.getElementById( expando );

			// Cleanup
			docElem.removeChild( div );

			return pass;
		});

		// IE6/7 return modified attributes
		Expr.attrHandle = assert(function( div ) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
				div.firstChild.getAttribute("href") === "#";
		}) ?
			{} :
			{
				"href": function( elem ) {
					return elem.getAttribute( "href", 2 );
				},
				"type": function( elem ) {
					return elem.getAttribute("type");
				}
			};

		// ID find and filter
		if ( support.getIdNotName ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			};
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.tagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Name
		Expr.find["NAME"] = support.getByName && function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		};

		// Class
		Expr.find["CLASS"] = support.getByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {
				return context.getElementsByClassName( className );
			}
		};

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21),
		// no need to also add to buggyMatches since matches checks buggyQSA
		// A support test would require too much code (would include document ready)
		rbuggyQSA = [ ":focus" ];

		if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explictly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				div.innerHTML = "<select><option selected=''></option></select>";

				// IE8 - Some boolean attributes are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
			});

			assert(function( div ) {

				// Opera 10-12/IE8 - ^= $= *= and empty values
				// Should not select anything
				div.innerHTML = "<input type='hidden' i=''/>";
				if ( div.querySelectorAll("[i^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.webkitMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = new RegExp( rbuggyMatches.join("|") );

		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		// Document order sorting
		sortOrder = docElem.compareDocumentPosition ?
		function( a, b ) {
			var compare;

			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			if ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {
				if ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {
					if ( a === doc || contains( preferredDoc, a ) ) {
						return -1;
					}
					if ( b === doc || contains( preferredDoc, b ) ) {
						return 1;
					}
					return 0;
				}
				return compare & 4 ? -1 : 1;
			}

			return a.compareDocumentPosition ? -1 : 1;
		} :
		function( a, b ) {
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// The nodes are identical, we can exit early
			if ( a === b ) {
				hasDuplicate = true;
				return 0;

			// Fallback to using sourceIndex (in IE) if it's available on both nodes
			} else if ( a.sourceIndex && b.sourceIndex ) {
				return ( ~b.sourceIndex || MAX_NEGATIVE ) - ( contains( preferredDoc, a ) && ~a.sourceIndex || MAX_NEGATIVE );

			// Parentless nodes are either documents or disconnected
			} else if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		// Always assume the presence of duplicates if sort doesn't
		// pass them to our comparison function (as in Google Chrome).
		hasDuplicate = false;
		[0, 0].sort( sortOrder );
		support.detectDuplicates = hasDuplicate;

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		// rbuggyQSA always contains :focus, so no need for an existence check
		if ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {
			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch(e) {}
		}

		return Sizzle( expr, document, null, [elem] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		var val;

		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		if ( !documentIsXML ) {
			name = name.toLowerCase();
		}
		if ( (val = Expr.attrHandle[ name ]) ) {
			return val( elem );
		}
		if ( documentIsXML || support.attributes ) {
			return elem.getAttribute( name );
		}
		return ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?
			name :
			val && val.specified ? val.value : null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	// Document sorting and removing duplicates
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			i = 1,
			j = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( ; (elem = results[i]); i++ ) {
				if ( elem === results[ i - 1 ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		return results;
	};

	function siblingCheck( a, b ) {
		var cur = a && b && a.nextSibling;

		for ( ; cur; cur = cur.nextSibling ) {
			if ( cur === b ) {
				return -1;
			}
		}

		return a ? 1 : -1;
	}

	// Returns a function to use in pseudos for input types
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	// Returns a function to use in pseudos for buttons
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	// Returns a function to use in pseudos for positionals
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			for ( ; (node = elem[i]); i++ ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[5] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[4] ) {
					match[2] = match[4];

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeName ) {
				if ( nodeName === "*" ) {
					return function() { return true; };
				}

				nodeName = nodeName.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.substr( result.length - check.length ) === check :
						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];

							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf.call( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifider
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsXML ?
							elem.getAttribute("xml:lang") || elem.getAttribute("lang") :
							elem.lang) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
				//   not comment, processing instructions, or others
				// Thanks to Diego Perini for the nodeName shortcut
				//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
				// use getAttribute instead to test this case
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	function tokenize( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( tokens = [] );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				} );
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push( {
						value: matched,
						type: type,
						matches: match
					} );
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	}

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && combinator.dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var data, cache, outerCache,
					dirkey = dirruns + " " + doneName;

				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
								if ( (data = cache[1]) === true || data === cachedruns ) {
									return data === true;
								}
							} else {
								cache = outerCache[ dir ] = [ dirkey ];
								cache[1] = matcher( elem, context, xml ) || cachedruns;
								if ( cache[1] === true ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf.call( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		// A counter to specify which element is currently being matched
		var matcherCachedRuns = 0,
			bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, expandContext ) {
				var elem, j, matcher,
					setMatched = [],
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					outermost = expandContext != null,
					contextBackup = outermostContext,
					// We must always have either seed elements or context
					elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
					// Nested matchers should use non-integer dirruns
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

				if ( outermost ) {
					outermostContext = context !== document && context;
					cachedruns = matcherCachedRuns;
				}

				// Add elements passing elementMatchers directly to results
				for ( ; (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
							cachedruns = ++matcherCachedRuns;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// Apply set filters to unmatched elements
				// `i` starts as a string, so matchedCount would equal "00" if there are no elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					for ( j = 0; (matcher = setMatchers[j]); j++ ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !group ) {
				group = tokenize( selector );
			}
			i = group.length;
			while ( i-- ) {
				cached = matcherFromTokens( group[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
		}
		return cached;
	};

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function select( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			match = tokenize( selector );

		if ( !seed ) {
			// Try to minimize operations if there is only one group
			if ( match.length === 1 ) {

				// Take a shortcut and set the context if the root selector is an ID
				tokens = match[0] = match[0].slice( 0 );
				if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
						context.nodeType === 9 && !documentIsXML &&
						Expr.relative[ tokens[1].type ] ) {

					context = Expr.find["ID"]( token.matches[0].replace( runescape, funescape ), context )[0];
					if ( !context ) {
						return results;
					}

					selector = selector.slice( tokens.shift().value.length );
				}

				// Fetch a seed set for right-to-left matching
				for ( i = matchExpr["needsContext"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
					token = tokens[i];

					// Abort if we hit a combinator
					if ( Expr.relative[ (type = token.type) ] ) {
						break;
					}
					if ( (find = Expr.find[ type ]) ) {
						// Search, expanding context for leading sibling combinators
						if ( (seed = find(
							token.matches[0].replace( runescape, funescape ),
							rsibling.test( tokens[0].type ) && context.parentNode || context
						)) ) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice( i, 1 );
							selector = seed.length && toSelector( tokens );
							if ( !selector ) {
								push.apply( results, slice.call( seed, 0 ) );
								return results;
							}

							break;
						}
					}
				}
			}
		}

		// Compile and execute a filtering function
		// Provide `match` to avoid retokenization if we modified the selector above
		compile( selector, match )(
			seed,
			context,
			documentIsXML,
			results,
			rsibling.test( selector )
		);
		return results;
	}

	// Deprecated
	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Easy API for creating new setFilters
	function setFilters() {}
	Expr.filters = setFilters.prototype = Expr.pseudos;
	Expr.setFilters = new setFilters();

	// Initialize with the default document
	setDocument();

	// Override sizzle attribute retrieval
	Sizzle.attr = jQuery.attr;
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;


	})( window );
	var runtil = /Until$/,
		rparentsprev = /^(?:parents|prev(?:Until|All))/,
		isSimple = /^.[^:#\[\.,]*$/,
		rneedsContext = jQuery.expr.match.needsContext,
		// methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend({
		find: function( selector ) {
			var i, ret, self;

			if ( typeof selector !== "string" ) {
				self = this;
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < self.length; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}

			ret = [];
			for ( i = 0; i < this.length; i++ ) {
				jQuery.find( selector, this[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( jQuery.unique( ret ) );
			ret.selector = ( this.selector ? this.selector + " " : "" ) + selector;
			return ret;
		},

		has: function( target ) {
			var i,
				targets = jQuery( target, this ),
				len = targets.length;

			return this.filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},

		not: function( selector ) {
			return this.pushStack( winnow(this, selector, false) );
		},

		filter: function( selector ) {
			return this.pushStack( winnow(this, selector, true) );
		},

		is: function( selector ) {
			return !!selector && (
				typeof selector === "string" ?
					// If this is a positional/relative selector, check membership in the returned set
					// so $("p:first").is("p:last") won't return true for a doc with two "p".
					rneedsContext.test( selector ) ?
						jQuery( selector, this.context ).index( this[0] ) >= 0 :
						jQuery.filter( selector, this ).length > 0 :
					this.filter( selector ).length > 0 );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				ret = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				cur = this[i];

				while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
					if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
						ret.push( cur );
						break;
					}
					cur = cur.parentNode;
				}
			}

			return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
		},

		// Determine the position of an element within
		// the matched set of elements
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
			}

			// index in selector
			if ( typeof elem === "string" ) {
				return jQuery.inArray( this[0], jQuery( elem ) );
			}

			// Locate the position of the desired element
			return jQuery.inArray(
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[0] : elem, this );
		},

		add: function( selector, context ) {
			var set = typeof selector === "string" ?
					jQuery( selector, context ) :
					jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
				all = jQuery.merge( this.get(), set );

			return this.pushStack( jQuery.unique(all) );
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	function sibling( cur, dir ) {
		do {
			cur = cur[ dir ];
		} while ( cur && cur.nodeType !== 1 );

		return cur;
	}

	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return jQuery.nodeName( elem, "iframe" ) ?
				elem.contentDocument || elem.contentWindow.document :
				jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var ret = jQuery.map( this, fn, until );

			if ( !runtil.test( name ) ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				ret = jQuery.filter( selector, ret );
			}

			ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

			if ( this.length > 1 && rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}

			return this.pushStack( ret );
		};
	});

	jQuery.extend({
		filter: function( expr, elems, not ) {
			if ( not ) {
				expr = ":not(" + expr + ")";
			}

			return elems.length === 1 ?
				jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
				jQuery.find.matches(expr, elems);
		},

		dir: function( elem, dir, until ) {
			var matched = [],
				cur = elem[ dir ];

			while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
				if ( cur.nodeType === 1 ) {
					matched.push( cur );
				}
				cur = cur[dir];
			}
			return matched;
		},

		sibling: function( n, elem ) {
			var r = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					r.push( n );
				}
			}

			return r;
		}
	});

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, keep ) {

		// Can't pass null or undefined to indexOf in Firefox 4
		// Set to 0 to skip string check
		qualifier = qualifier || 0;

		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep(elements, function( elem, i ) {
				var retVal = !!qualifier.call( elem, i, elem );
				return retVal === keep;
			});

		} else if ( qualifier.nodeType ) {
			return jQuery.grep(elements, function( elem ) {
				return ( elem === qualifier ) === keep;
			});

		} else if ( typeof qualifier === "string" ) {
			var filtered = jQuery.grep(elements, function( elem ) {
				return elem.nodeType === 1;
			});

			if ( isSimple.test( qualifier ) ) {
				return jQuery.filter(qualifier, filtered, !keep);
			} else {
				qualifier = jQuery.filter( qualifier, filtered );
			}
		}

		return jQuery.grep(elements, function( elem ) {
			return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
		});
	}
	function createSafeFragment( document ) {
		var list = nodeNames.split( "|" ),
			safeFrag = document.createDocumentFragment();

		if ( safeFrag.createElement ) {
			while ( list.length ) {
				safeFrag.createElement(
					list.pop()
				);
			}
		}
		return safeFrag;
	}

	var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
			"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
		rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
		rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
		rleadingWhitespace = /^\s+/,
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rtbody = /<tbody/i,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

		// We have to close these tags to support XHTML (#13200)
		wrapMap = {
			option: [ 1, "<select multiple='multiple'>", "</select>" ],
			legend: [ 1, "<fieldset>", "</fieldset>" ],
			area: [ 1, "<map>", "</map>" ],
			param: [ 1, "<object>", "</object>" ],
			thead: [ 1, "<table>", "</table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
			// unless wrapped in a div with non-breaking characters in front of it.
			_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
		},
		safeFragment = createSafeFragment( document ),
		fragmentDiv = safeFragment.appendChild( document.createElement("div") );

	wrapMap.optgroup = wrapMap.option;
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	jQuery.fn.extend({
		text: function( value ) {
			return jQuery.access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().appendChild( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
			}, null, value, arguments.length );
		},

		wrapAll: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function(i) {
					jQuery(this).wrapAll( html.call(this, i) );
				});
			}

			if ( this[0] ) {
				// The elements to wrap the target around
				var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

				if ( this[0].parentNode ) {
					wrap.insertBefore( this[0] );
				}

				wrap.map(function() {
					var elem = this;

					while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
						elem = elem.firstChild;
					}

					return elem;
				}).appendChild( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function(i) {
					jQuery(this).wrapInner( html.call(this, i) );
				});
			}

			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.appendChild( html );
				}
			});
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each(function(i) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},

		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		},

		append: function() {
			return this.domManip(arguments, true, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					this.appendChild( elem );
				}
			});
		},

		prepend: function() {
			return this.domManip(arguments, true, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					this.insertBefore( elem, this.firstChild );
				}
			});
		},

		before: function() {
			return this.domManip( arguments, false, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},

		after: function() {
			return this.domManip( arguments, false, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},

		// keepData is for internal use only--do not document
		remove: function( selector, keepData ) {
			var elem,
				i = 0;

			for ( ; (elem = this[i]) != null; i++ ) {
				if ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {
					if ( !keepData && elem.nodeType === 1 ) {
						jQuery.cleanData( getAll( elem ) );
					}

					if ( elem.parentNode ) {
						if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
							setGlobalEval( getAll( elem, "script" ) );
						}
						elem.parentNode.removeChild( elem );
					}
				}
			}

			return this;
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; (elem = this[i]) != null; i++ ) {
				// Remove element nodes and prevent memory leaks
				if ( elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem, false ) );
				}

				// Remove any remaining nodes
				while ( elem.firstChild ) {
					elem.removeChild( elem.firstChild );
				}

				// If this is a select, ensure that it displays empty (#12336)
				// Support: IE<9
				if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
					elem.options.length = 0;
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function () {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},

		html: function( value ) {
			return jQuery.access( this, function( value ) {
				var elem = this[0] || {},
					i = 0,
					l = this.length;

				if ( value === undefined ) {
					return elem.nodeType === 1 ?
						elem.innerHTML.replace( rinlinejQuery, "" ) :
						undefined;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
					( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
					!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

					value = value.replace( rxhtmlTag, "<$1></$2>" );

					try {
						for (; i < l; i++ ) {
							// Remove element nodes and prevent memory leaks
							elem = this[i] || {};
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch(e) {}
				}

				if ( elem ) {
					this.empty().appendChild( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function( value ) {
			var isFunc = jQuery.isFunction( value );

			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( !isFunc && typeof value !== "string" ) {
				value = jQuery( value ).not( this ).detach();
			}

			return this.domManip( [ value ], true, function( elem ) {
				var next = this.nextSibling,
					parent = this.parentNode;

				if ( parent && this.nodeType === 1 || this.nodeType === 11 ) {

					jQuery( this ).remove();

					if ( next ) {
						next.parentNode.insertBefore( elem, next );
					} else {
						parent.appendChild( elem );
					}
				}
			});
		},

		detach: function( selector ) {
			return this.remove( selector, true );
		},

		domManip: function( args, table, callback ) {

			// Flatten any nested arrays
			args = core_concat.apply( [], args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[0],
				isFunction = jQuery.isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[0] = value.call( this, index, table ? self.html() : undefined );
					}
					self.domManip( args, table, callback );
				});
			}

			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				if ( first ) {
					table = table && jQuery.nodeName( first, "tr" );
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call(
							table && jQuery.nodeName( this[i], "table" ) ?
								findOrAppend( this[i], "tbody" ) :
								this[i],
							node,
							i
						);
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Reenable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

								if ( node.src ) {
									// Hope ajax is available...
									jQuery.ajax({
										url: node.src,
										type: "GET",
										dataType: "script",
										async: false,
										global: false,
										"throws": true
									});
								} else {
									jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
								}
							}
						}
					}

					// Fix #11809: Avoid leaking memory
					fragment = first = null;
				}
			}

			return this;
		}
	});

	function findOrAppend( elem, tag ) {
		return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		var attr = elem.getAttributeNode("type");
		elem.type = ( attr && attr.specified ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
		if ( match ) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}
		return elem;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var elem,
			i = 0;
		for ( ; (elem = elems[i]) != null; i++ ) {
			jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
		}
	}

	function cloneCopyEvent( src, dest ) {

		if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
			return;
		}

		var type, i, l,
			oldData = jQuery._data( src ),
			curData = jQuery._data( dest, oldData ),
			events = oldData.events;

		if ( events ) {
			delete curData.handle;
			curData.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}

		// make the cloned public data object a copy from the original
		if ( curData.data ) {
			curData.data = jQuery.extend( {}, curData.data );
		}
	}

	function fixCloneNodeIssues( src, dest ) {
		var nodeName, data, e;

		// We do not need to do anything for non-Elements
		if ( dest.nodeType !== 1 ) {
			return;
		}

		nodeName = dest.nodeName.toLowerCase();

		// IE6-8 copies events bound via attachEvent when using cloneNode.
		if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
			data = jQuery._data( dest );

			for ( e in data.events ) {
				jQuery.removeEvent( dest, e, data.handle );
			}

			// Event data gets referenced instead of copied if the expando gets copied too
			dest.removeAttribute( jQuery.expando );
		}

		// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
		if ( nodeName === "script" && dest.text !== src.text ) {
			disableScript( dest ).text = src.text;
			restoreScript( dest );

		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		} else if ( nodeName === "object" ) {
			if ( dest.parentNode ) {
				dest.outerHTML = src.outerHTML;
			}

			// This path appears unavoidable for IE9. When cloning an object
			// element in IE9, the outerHTML strategy above is not sufficient.
			// If the src has innerHTML and the destination does not,
			// copy the src.innerHTML into the dest.innerHTML. #10324
			if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
				dest.innerHTML = src.innerHTML;
			}

		} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
			// IE6-8 fails to persist the checked state of a cloned checkbox
			// or radio button. Worse, IE6-7 fail to give the cloned element
			// a checked appearance if the defaultChecked value isn't also set

			dest.defaultChecked = dest.checked = src.checked;

			// IE6-7 get confused and end up setting the value of a cloned
			// checkbox/radio button to an empty string instead of "on"
			if ( dest.value !== src.value ) {
				dest.value = src.value;
			}

		// IE6-8 fails to return the selected option to the default selected
		// state when cloning options
		} else if ( nodeName === "option" ) {
			dest.defaultSelected = dest.selected = src.defaultSelected;

		// IE6-8 fails to set the defaultValue to the correct value when
		// cloning other types of input fields
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				i = 0,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone(true);
				jQuery( insert[i] )[ original ]( elems );

				// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
				core_push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	});

	function getAll( context, tag ) {
		var elems, elem,
			i = 0,
			found = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll( tag || "*" ) :
				undefined;

		if ( !found ) {
			for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
				if ( !tag || jQuery.nodeName( elem, tag ) ) {
					found.push( elem );
				} else {
					jQuery.merge( found, getAll( elem, tag ) );
				}
			}
		}

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], found ) :
			found;
	}

	// Used in buildFragment, fixes the defaultChecked property
	function fixDefaultChecked( elem ) {
		if ( manipulation_rcheckableType.test( elem.type ) ) {
			elem.defaultChecked = elem.checked;
		}
	}

	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var destElements, srcElements, node, i, clone,
				inPage = jQuery.contains( elem.ownerDocument, elem );

			if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
				clone = elem.cloneNode( true );

			// IE<=8 does not properly clone detached, unknown element nodes
			} else {
				fragmentDiv.innerHTML = elem.outerHTML;
				fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
			}

			if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
					(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				// Fix all IE cloning issues
				for ( i = 0; (node = srcElements[i]) != null; ++i ) {
					// Ensure that the destination node is not null; Fixes #9587
					if ( destElements[i] ) {
						fixCloneNodeIssues( node, destElements[i] );
					}
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0; (node = srcElements[i]) != null; i++ ) {
						cloneCopyEvent( node, destElements[i] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			destElements = srcElements = node = null;

			// Return the cloned set
			return clone;
		},

		buildFragment: function( elems, context, scripts, selection ) {
			var contains, elem, tag, tmp, wrap, tbody, j,
				l = elems.length,

				// Ensure a safe fragment
				safe = createSafeFragment( context ),

				nodes = [],
				i = 0;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || safe.appendChild( context.createElement("div") );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;

						tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

						// Descend through wrappers to the right content
						j = wrap[0];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Manually add leading whitespace removed by IE
						if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
							nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
						}

						// Remove IE's autoinserted <tbody> from table fragments
						if ( !jQuery.support.tbody ) {

							// String was a <table>, *may* have spurious <tbody>
							elem = tag === "table" && !rtbody.test( elem ) ?
								tmp.firstChild :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !rtbody.test( elem ) ?
									tmp :
									0;

							j = elem && elem.childNodes.length;
							while ( j-- ) {
								if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
									elem.removeChild( tbody );
								}
							}
						}

						jQuery.merge( nodes, tmp.childNodes );

						// Fix #12392 for WebKit and IE > 9
						tmp.textContent = "";

						// Fix #12392 for oldIE
						while ( tmp.firstChild ) {
							tmp.removeChild( tmp.firstChild );
						}

						// Remember the top-level container for proper cleanup
						tmp = safe.lastChild;
					}
				}
			}

			// Fix #11356: Clear elements from fragment
			if ( tmp ) {
				safe.removeChild( tmp );
			}

			// Reset defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			if ( !jQuery.support.appendChecked ) {
				jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
			}

			i = 0;
			while ( (elem = nodes[ i++ ]) ) {

				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}

				contains = jQuery.contains( elem.ownerDocument, elem );

				// Append to fragment
				tmp = getAll( safe.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			tmp = null;

			return safe;
		},

		cleanData: function( elems, /* internal */ acceptData ) {
			var data, id, elem, type,
				i = 0,
				internalKey = jQuery.expando,
				cache = jQuery.cache,
				deleteExpando = jQuery.support.deleteExpando,
				special = jQuery.event.special;

			for ( ; (elem = elems[i]) != null; i++ ) {

				if ( acceptData || jQuery.acceptData( elem ) ) {

					id = elem[ internalKey ];
					data = id && cache[ id ];

					if ( data ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Remove cache only if it was not already removed by jQuery.event.remove
						if ( cache[ id ] ) {

							delete cache[ id ];

							// IE does not allow us to delete expando properties from nodes,
							// nor does it have a removeAttribute function on Document nodes;
							// we must handle all of these cases
							if ( deleteExpando ) {
								delete elem[ internalKey ];

							} else if ( typeof elem.removeAttribute !== "undefined" ) {
								elem.removeAttribute( internalKey );

							} else {
								elem[ internalKey ] = null;
							}

							core_deletedIds.push( id );
						}
					}
				}
			}
		}
	});
	var curCSS, getStyles, iframe,
		ralpha = /alpha\([^)]*\)/i,
		ropacity = /opacity\s*=\s*([^)]*)/,
		rposition = /^(top|right|bottom|left)$/,
		// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rmargin = /^margin/,
		rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
		rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
		elemdisplay = { BODY: "block" },

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: 0,
			fontWeight: 400
		},

		cssExpand = [ "Top", "Right", "Bottom", "Left" ],
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

	// return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {

		// shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}

		// check for vendor prefixed names
		var capName = name.charAt(0).toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}

		return origName;
	}

	function isHidden( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	}

	function showHide( elements, show ) {
		var elem,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			values[ index ] = jQuery._data( elem, "olddisplay" );
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && elem.style.display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
				}
			} else if ( !values[ index ] && !isHidden( elem ) ) {
				jQuery._data( elem, "olddisplay", jQuery.css( elem, "display" ) );
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.fn.extend({
		css: function( name, value ) {
			return jQuery.access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			var bool = typeof state === "boolean";

			return this.each(function() {
				if ( bool ? state : isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});

	jQuery.extend({
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Exclude the following css properties to add px
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			// normalize float css property
			"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// convert relative number strings (+= or -=) to relative numbers. #7345
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}

				// Make sure that NaN and null values aren't set. See: #7116
				if ( value == null || type === "number" && isNaN( value ) ) {
					return;
				}

				// If a number was passed in, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}

				// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
				// but it would mean to define eight (for every problematic property) identical functions
				if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

					// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
					// Fixes bug #5509
					try {
						style[ name ] = value;
					} catch(e) {}
				}

			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			//convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Return, converting to number if forced or a qualifier was provided and val looks numeric
			if ( extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		},

		// A method for quickly swapping in/out CSS properties to get correct calculations
		swap: function( elem, options, callback, args ) {
			var ret, name,
				old = {};

			// Remember the old values, and insert the new ones
			for ( name in options ) {
				old[ name ] = elem.style[ name ];
				elem.style[ name ] = options[ name ];
			}

			ret = callback.apply( elem, args || [] );

			// Revert the old values
			for ( name in options ) {
				elem.style[ name ] = old[ name ];
			}

			return ret;
		}
	});

	// NOTE: we've included the "window" in window.getComputedStyle
	// because jsdom on node.js will break without it.
	if ( window.getComputedStyle ) {
		getStyles = function( elem ) {
			return window.getComputedStyle( elem, null );
		};

		curCSS = function( elem, name, _computed ) {
			var width, minWidth, maxWidth,
				computed = _computed || getStyles( elem ),

				// getPropertyValue is only needed for .css('filter') in IE9, see #12537
				ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
				style = elem.style;

			if ( computed ) {

				if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
					ret = jQuery.style( elem, name );
				}

				// A tribute to the "awesome hack by Dean Edwards"
				// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
				// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
				// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
				if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

					// Remember the original values
					width = style.width;
					minWidth = style.minWidth;
					maxWidth = style.maxWidth;

					// Put in the new values to get a computed value out
					style.minWidth = style.maxWidth = style.width = ret;
					ret = computed.width;

					// Revert the changed values
					style.width = width;
					style.minWidth = minWidth;
					style.maxWidth = maxWidth;
				}
			}

			return ret;
		};
	} else if ( document.documentElement.currentStyle ) {
		getStyles = function( elem ) {
			return elem.currentStyle;
		};

		curCSS = function( elem, name, _computed ) {
			var left, rs, rsLeft,
				computed = _computed || getStyles( elem ),
				ret = computed ? computed[ name ] : undefined,
				style = elem.style;

			// Avoid setting ret to empty string here
			// so we don't default to auto
			if ( ret == null && style && style[ name ] ) {
				ret = style[ name ];
			}

			// From the awesome hack by Dean Edwards
			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

			// If we're not dealing with a regular pixel number
			// but a number that has a weird ending, we need to convert it to pixels
			// but not position css attributes, as those are proportional to the parent element instead
			// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
			if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

				// Remember the original values
				left = style.left;
				rs = elem.runtimeStyle;
				rsLeft = rs && rs.left;

				// Put in the new values to get a computed value out
				if ( rsLeft ) {
					rs.left = elem.currentStyle.left;
				}
				style.left = name === "fontSize" ? "1em" : ret;
				ret = style.pixelLeft + "px";

				// Revert the changed values
				style.left = left;
				if ( rsLeft ) {
					rs.left = rsLeft;
				}
			}

			return ret === "" ? "auto" : ret;
		};
	}

	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {
			// both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// at this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// at this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// at this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}

			// we need the check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	// Try to determine the default display value of an element
	function css_defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
				// Use the already-created iframe if possible
				iframe = ( iframe ||
					jQuery("<iframe frameborder='0' width='0' height='0'/>")
					.css( "cssText", "display:block !important" )
				).appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
				doc.write("<!doctype html><html><body>");
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}

	// Called ONLY from within css_defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
			display = jQuery.css( elem[0], "display" );
		elem.remove();
		return display;
	}

	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
					// certain elements can have dimension info if we invisibly show them
					// however, it must have a current display style that would benefit from this
					return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});

	if ( !jQuery.support.opacity ) {
		jQuery.cssHooks.opacity = {
			get: function( elem, computed ) {
				// IE uses filters for opacity
				return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
					computed ? "1" : "";
			},

			set: function( elem, value ) {
				var style = elem.style,
					currentStyle = elem.currentStyle,
					opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
					filter = currentStyle && currentStyle.filter || style.filter || "";

				// IE has trouble with opacity if it does not have layout
				// Force it by setting the zoom level
				style.zoom = 1;

				// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
				// if value === "", then remove inline opacity #12685
				if ( ( value >= 1 || value === "" ) &&
						jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
						style.removeAttribute ) {

					// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
					// if "filter:" is present at all, clearType is disabled, we want to avoid this
					// style.removeAttribute is IE Only, but so apparently is this code path...
					style.removeAttribute( "filter" );

					// if there is no filter style applied in a css rule or unset inline opacity, we are done
					if ( value === "" || currentStyle && !currentStyle.filter ) {
						return;
					}
				}

				// otherwise, set new filter values
				style.filter = ralpha.test( filter ) ?
					filter.replace( ralpha, opacity ) :
					filter + " " + opacity;
			}
		};
	}

	// These hooks cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	jQuery(function() {
		if ( !jQuery.support.reliableMarginRight ) {
			jQuery.cssHooks.marginRight = {
				get: function( elem, computed ) {
					if ( computed ) {
						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
						// Work around by temporarily setting element display to inline-block
						return jQuery.swap( elem, { "display": "inline-block" },
							curCSS, [ elem, "marginRight" ] );
					}
				}
			};
		}

		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
		// getComputedStyle returns percent when specified for top/left/bottom/right
		// rather than make the css module depend on the offset module, we just check for it here
		if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
			jQuery.each( [ "top", "left" ], function( i, prop ) {
				jQuery.cssHooks[ prop ] = {
					get: function( elem, computed ) {
						if ( computed ) {
							computed = curCSS( elem, prop );
							// if curCSS returns percentage, fallback to offset
							return rnumnonpx.test( computed ) ?
								jQuery( elem ).position()[ prop ] + "px" :
								computed;
						}
					}
				};
			});
		}

	});

	if ( jQuery.expr && jQuery.expr.filters ) {
		jQuery.expr.filters.hidden = function( elem ) {
			return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
		};

		jQuery.expr.filters.visible = function( elem ) {
			return !jQuery.expr.filters.hidden( elem );
		};
	}

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function(){
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function(){
				var type = this.type;
				// Use .is(":disabled") so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !manipulation_rcheckableType.test( type ) );
			})
			.map(function( i, elem ){
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ){
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});

	//Serialize an array of form elements or a set of
	//key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );

				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	var
		// Document location
		ajaxLocParts,
		ajaxLocation,
		
		ajax_nonce = jQuery.now(),

		ajax_rquery = /\?/,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

		// Keep a copy of the old load method
		_load = jQuery.fn.load,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat("*");

	// #8138, IE may throw an exception when accessing
	// a field from window.location if document.domain has been set
	try {
		ajaxLocation = location.href;
	} catch( e ) {
		// Use the href attribute of an A element
		// since IE will modify it given document.location
		ajaxLocation = document.createElement( "a" );
		ajaxLocation.href = "";
		ajaxLocation = ajaxLocation.href;
	}

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf(" ");

		if ( off >= 0 ) {
			selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,

				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").appendChild( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
		jQuery.fn[ type ] = function( fn ){
			return this.on( type, fn );
		};
	});

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": window.String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
				);
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			fireGlobals = s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}

			// aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// If successful, handle type chaining
				if ( status >= 200 && status < 300 || status === 304 ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// If not modified
					if ( status === 304 ) {
						isSuccess = true;
						statusText = "notmodified";

					// If we have data
					} else {
						isSuccess = ajaxConvert( s, response );
						statusText = isSuccess.state;
						success = isSuccess.data;
						error = isSuccess.error;
						isSuccess = !error;
					}
				} else {
					// We extract error from statusText
					// then normalize statusText and status for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		}
	});

	/* Handles responses to an ajax request:
	 * - sets all responseXXX fields accordingly
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes,
			responseFields = s.responseFields;

		// Fill responseXXX fields
		for ( type in responseFields ) {
			if ( type in responses ) {
				jqXHR[ responseFields[type] ] = responses[ type ];
			}
		}

		// Remove auto dataType and get content-type in the process
		while( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	// Chain conversions given the request and the original response
	function ajaxConvert( s, response ) {

		var conv, conv2, current, tmp,
			converters = {},
			i = 0,
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice(),
			prev = dataTypes[ 0 ];

		// Apply the dataFilter if provided
		if ( s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		// Convert to each sequential dataType, tolerating list modification
		for ( ; (current = dataTypes[++i]); ) {

			// There's only work to do if current dataType is non-auto
			if ( current !== "*" ) {

				// Convert response if prev dataType is non-auto and differs from current
				if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.splice( i--, 0, current );
									}

									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s["throws"] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}

				// Update prev for next iteration
				prev = current;
			}
		}

		return { state: "success", data: response };
	}
	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});

	// Handle cache's special case and global
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
			s.global = false;
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function(s) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {

			var script,
				head = document.head || jQuery("head")[0] || document.documentElement;

			return {

				send: function( _, callback ) {

					script = document.createElement("script");

					script.async = true;

					if ( s.scriptCharset ) {
						script.charset = s.scriptCharset;
					}

					script.src = s.url;

					// Attach handlers for all browsers
					script.onload = script.onreadystatechange = function( _, isAbort ) {

						if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

							// Handle memory leak in IE
							script.onload = script.onreadystatechange = null;

							// Remove the script
							if ( script.parentNode ) {
								script.parentNode.removeChild( script );
							}

							// Dereference the script
							script = null;

							// Callback if not abort
							if ( !isAbort ) {
								callback( 200, "success" );
							}
						}
					};

					// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					head.insertBefore( script, head.firstChild );
				},

				abort: function() {
					if ( script ) {
						script.onload( undefined, true );
					}
				}
			};
		}
	});
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;

				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});
	var xhrCallbacks, xhrSupported,
		xhrId = 0,
		// #5280: Internet Explorer will keep connections alive if we don't abort on unload
		xhrOnUnloadAbort = window.ActiveXObject && function() {
			// Abort all pending requests
			var key;
			for ( key in xhrCallbacks ) {
				xhrCallbacks[ key ]( undefined, true );
			}
		};

	// Functions to create xhrs
	function createStandardXHR() {
		try {
			return new window.XMLHttpRequest();
		} catch( e ) {}
	}

	function createActiveXHR() {
		try {
			return new window.ActiveXObject("Microsoft.XMLHTTP");
		} catch( e ) {}
	}

	// Create the request object
	// (This is still attached to ajaxSettings for backward compatibility)
	jQuery.ajaxSettings.xhr = window.ActiveXObject ?
		/* Microsoft failed to properly
		 * implement the XMLHttpRequest in IE7 (can't request local files),
		 * so we use the ActiveXObject when it is available
		 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
		 * we need a fallback.
		 */
		function() {
			return !this.isLocal && createStandardXHR() || createActiveXHR();
		} :
		// For all other browsers, use the standard XMLHttpRequest object
		createStandardXHR;

	// Determine support properties
	xhrSupported = jQuery.ajaxSettings.xhr();
	jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	xhrSupported = jQuery.support.ajax = !!xhrSupported;

	// Create transport if the browser can provide an xhr
	if ( xhrSupported ) {

		jQuery.ajaxTransport(function( s ) {
			// Cross domain only allowed if supported through XMLHttpRequest
			if ( !s.crossDomain || jQuery.support.cors ) {

				var callback;

				return {
					send: function( headers, complete ) {

						// Get a new xhr
						var handle, i,
							xhr = s.xhr();

						// Open the socket
						// Passing null username, generates a login popup on Opera (#2865)
						if ( s.username ) {
							xhr.open( s.type, s.url, s.async, s.username, s.password );
						} else {
							xhr.open( s.type, s.url, s.async );
						}

						// Apply custom fields if provided
						if ( s.xhrFields ) {
							for ( i in s.xhrFields ) {
								xhr[ i ] = s.xhrFields[ i ];
							}
						}

						// Override mime type if needed
						if ( s.mimeType && xhr.overrideMimeType ) {
							xhr.overrideMimeType( s.mimeType );
						}

						// X-Requested-With header
						// For cross-domain requests, seeing as conditions for a preflight are
						// akin to a jigsaw puzzle, we simply never set it to be sure.
						// (it can always be set on a per-request basis or even using ajaxSetup)
						// For same-domain requests, won't change header if already provided.
						if ( !s.crossDomain && !headers["X-Requested-With"] ) {
							headers["X-Requested-With"] = "XMLHttpRequest";
						}

						// Need an extra try/catch for cross domain requests in Firefox 3
						try {
							for ( i in headers ) {
								xhr.setRequestHeader( i, headers[ i ] );
							}
						} catch( err ) {}

						// Do send the request
						// This may raise an exception which is actually
						// handled in jQuery.ajax (so no try/catch here)
						xhr.send( ( s.hasContent && s.data ) || null );

						// Listener
						callback = function( _, isAbort ) {

							var status,
								statusText,
								responseHeaders,
								responses,
								xml;

							// Firefox throws exceptions when accessing properties
							// of an xhr when a network error occurred
							// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
							try {

								// Was never called and is aborted or complete
								if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

									// Only called once
									callback = undefined;

									// Do not keep as active anymore
									if ( handle ) {
										xhr.onreadystatechange = jQuery.noop;
										if ( xhrOnUnloadAbort ) {
											delete xhrCallbacks[ handle ];
										}
									}

									// If it's an abort
									if ( isAbort ) {
										// Abort it manually if needed
										if ( xhr.readyState !== 4 ) {
											xhr.abort();
										}
									} else {
										responses = {};
										status = xhr.status;
										xml = xhr.responseXML;
										responseHeaders = xhr.getAllResponseHeaders();

										// Construct response list
										if ( xml && xml.documentElement /* #4958 */ ) {
											responses.xml = xml;
										}

										// When requesting binary data, IE6-9 will throw an exception
										// on any attempt to access responseText (#11426)
										if ( typeof xhr.responseText === "string" ) {
											responses.text = xhr.responseText;
										}

										// Firefox throws an exception when accessing
										// statusText for faulty cross-domain requests
										try {
											statusText = xhr.statusText;
										} catch( e ) {
											// We normalize with Webkit giving an empty statusText
											statusText = "";
										}

										// Filter status for non standard behaviors

										// If the request is local and we have data: assume a success
										// (success with no data won't get notified, that's the best we
										// can do given current implementations)
										if ( !status && s.isLocal && !s.crossDomain ) {
											status = responses.text ? 200 : 404;
										// IE - #1450: sometimes returns 1223 when it should be 204
										} else if ( status === 1223 ) {
											status = 204;
										}
									}
								}
							} catch( firefoxAccessException ) {
								if ( !isAbort ) {
									complete( -1, firefoxAccessException );
								}
							}

							// Call complete if needed
							if ( responses ) {
								complete( status, statusText, responses, responseHeaders );
							}
						};

						if ( !s.async ) {
							// if we're in sync mode we fire the callback
							callback();
						} else if ( xhr.readyState === 4 ) {
							// (IE6 & IE7) if it's in cache and has been
							// retrieved directly we need to fire the callback
							setTimeout( callback );
						} else {
							handle = ++xhrId;
							if ( xhrOnUnloadAbort ) {
								// Create the active xhrs callbacks list if needed
								// and attach the unload handler
								if ( !xhrCallbacks ) {
									xhrCallbacks = {};
									jQuery( window ).unload( xhrOnUnloadAbort );
								}
								// Add to list of active xhrs callbacks
								xhrCallbacks[ handle ] = callback;
							}
							xhr.onreadystatechange = callback;
						}
					},

					abort: function() {
						if ( callback ) {
							callback( undefined, true );
						}
					}
				};
			}
		});
	}
	var fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [function( prop, value ) {
				var end, unit,
					tween = this.createTween( prop, value ),
					parts = rfxnum.exec( value ),
					target = tween.cur(),
					start = +target || 0,
					scale = 1,
					maxIterations = 20;

				if ( parts ) {
					end = +parts[2];
					unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

					// We need to compute starting value
					if ( unit !== "px" && start ) {
						// Iteratively approximate from a nonzero starting point
						// Prefer the current property, because this process will be trivial if it uses the same units
						// Fallback to end or a simple constant
						start = jQuery.css( tween.elem, prop, true ) || end || 1;

						do {
							// If previous iteration zeroed out, double until we get *something*
							// Use a string for doubling factor so we don't accidentally see scale as unchanged below
							scale = scale || ".5";

							// Adjust and apply
							start = start / scale;
							jQuery.style( tween.elem, prop, start + unit );

						// Update scale, tolerating zero or NaN from tween.cur()
						// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
						} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
					}

					tween.unit = unit;
					tween.start = start;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
				}
				return tween;
			}]
		};

	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}

	function createTweens( animation, props ) {
		jQuery.each( props, function( prop, value ) {
			var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
				index = 0,
				length = collection.length;
			for ( ; index < length; index++ ) {
				if ( collection[ index ].call( animation, prop, value ) ) {

					// we're done with this property
					return;
				}
			}
		});
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ]);

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// if we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// resolve when we played the last frame
					// otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}

		createTweens( animation, props );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// not quite $.extend, this wont overwrite keys already present.
				// also - reusing 'index' from above because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});

	function defaultPrefilter( elem, props, opts ) {
		/*jshint validthis:true */
		var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
			anim = this,
			style = elem.style,
			orig = {},
			handled = [],
			hidden = elem.nodeType && isHidden( elem );

		// handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function() {
				// doing this makes sure that the complete handler will be called
				// before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}

		// height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE does not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			if ( jQuery.css( elem, "display" ) === "inline" &&
					jQuery.css( elem, "float" ) === "none" ) {

				// inline-level elements accept inline-block;
				// block-level elements need to be inline with layout
				if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
					style.display = "inline-block";

				} else {
					style.zoom = 1;
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			if ( !jQuery.support.shrinkWrapBlocks ) {
				anim.done(function() {
					style.overflow = opts.overflow[ 0 ];
					style.overflowX = opts.overflow[ 1 ];
					style.overflowY = opts.overflow[ 2 ];
				});
			}
		}


		// show/hide pass
		for ( index in props ) {
			value = props[ index ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ index ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
					continue;
				}
				handled.push( index );
			}
		}

		length = handled.length;
		if ( length ) {
			dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}

			// store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;
				jQuery._removeData( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( index = 0 ; index < length ; index++ ) {
				prop = handled[ index ];
				tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
				orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
		}
	}

	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}

				// passing a non empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails
				// so, simple values such as "10px" are parsed to Float.
				// complex values such as "rotate(1rad)" are returned as is.
				result = jQuery.css( tween.elem, tween.prop, "auto" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// use step hook for back compat - use cssHook if its there - use .style if its
				// available and use plain properties where available
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Remove in 2.0 - this supports IE8's panic based approach
	// to setting things on disconnected nodes

	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});

	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {

			// show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
					doAnimation.finish = function() {
						anim.stop( true );
					};
					// Empty animations, or finishing resolves immediately
					if ( empty || jQuery._data( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = jQuery._data( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// start the next in the queue if the last step wasn't forced
				// timers currently will call their complete callbacks, which will dequeue
				// but only if they were gotoEnd
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = jQuery._data( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// enable finishing flag on private data
				data.finish = true;

				// empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.cur && hooks.cur.finish ) {
					hooks.cur.finish.call( this );
				}

				// look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// turn off finishing flag
				delete data.finish;
			});
		}
	});

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			attrs = { height: type },
			i = 0;

		// if we include width, step value is 1 to do all cssExpand values,
		// if we don't include width, step value is 2 to skip over Left and Right
		includeWidth = includeWidth? 1 : 0;
		for( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p*Math.PI ) / 2;
		}
	};

	jQuery.timers = [];
	jQuery.fx = Tween.prototype.init;
	jQuery.fx.tick = function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		if ( timer() && jQuery.timers.push( timer ) ) {
			jQuery.fx.start();
		}
	};

	jQuery.fx.interval = 13;

	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	if ( jQuery.expr && jQuery.expr.filters ) {
		jQuery.expr.filters.animated = function( elem ) {
			return jQuery.grep(jQuery.timers, function( fn ) {
				return elem === fn.elem;
			}).length;
		};
	}
	jQuery.fn.offset = function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== "undefined" ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	};

	jQuery.offset = {

		setOffset: function( elem, options, i ) {
			var position = jQuery.css( elem, "position" );

			// set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			var curElem = jQuery( elem ),
				curOffset = curElem.offset(),
				curCSSTop = jQuery.css( elem, "top" ),
				curCSSLeft = jQuery.css( elem, "left" ),
				calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
				props = {}, curPosition = {}, curTop, curLeft;

			// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );
			} else {
				curElem.css( props );
			}
		}
	};


	jQuery.fn.extend({

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				parentOffset = { top: 0, left: 0 },
				elem = this[ 0 ];

			// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// we assume that getBoundingClientRect is available when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			// note: when an element has margin: auto the offsetLeft and marginLeft
			// are the same in Safari causing offset.left to incorrectly be 0
			return {
				top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
			};
		},

		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || document.documentElement;
				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}
				return offsetParent || document.documentElement;
			});
		}
	});


	// Create scrollLeft and scrollTop methods
	jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
		var top = /Y/.test( prop );

		jQuery.fn[ method ] = function( val ) {
			return jQuery.access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? (prop in win) ? win[ prop ] :
						win.document.documentElement[ method ] :
						elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : jQuery( win ).scrollLeft(),
						top ? val : jQuery( win ).scrollTop()
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});

	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ?
			elem :
			elem.nodeType === 9 ?
				elem.defaultView || elem.parentWindow :
				false;
	}
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return jQuery.access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
						// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});
	// Limit scope pollution from any deprecated API
	// (function() {

	// })();
	// Expose jQuery to the global object
	window.jQuery = window.$ = jQuery;

	// Expose jQuery as an AMD module, but only for AMD loaders that
	// understand the issues with loading multiple versions of jQuery
	// in a page that all might call define(). The loader will indicate
	// they have special allowances for multiple jQuery versions by
	// specifying define.amd.jQuery = true. Register as a named module,
	// since jQuery can be concatenated with other files that may use define,
	// but not use a proper concatenation script that understands anonymous
	// AMD modules. A named AMD is safest and most robust way to register.
	// Lowercase jquery is used because AMD module names are derived from
	// file names, and jQuery is normally delivered in a lowercase file name.
	// Do this after creating the global so that if an AMD module wants to call
	// noConflict to hide this version of jQuery, it will work.
	if ( "function" === "function" && __webpack_require__(3) && __webpack_require__(3).jQuery ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return jQuery; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	})( window );
	module.exports = jQuery;


/***/ }),

/***/ 3:
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

	// File:src/Three.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var THREE = { REVISION: '69' };

	// browserify support

	if ( true ) {

		module.exports = THREE;

	}

	// polyfills

	if ( Math.sign === undefined ) {

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

		};

	}

	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	// GL STATE CONSTANTS

	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;

	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;

	// SHADOWING TYPES

	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;

	// MATERIAL CONSTANTS

	// side

	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;

	// shading

	THREE.NoShading = 0;
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;

	// colors

	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;

	// blending modes

	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;

	// custom blending equations
	// (numbers start from 100 not to clash with other
	//  mappings to OpenGL constants defined in Texture.js)

	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;

	// custom blending destination factors

	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;

	// custom blending source factors

	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;


	// TEXTURE CONSTANTS

	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;

	// Mapping modes

	THREE.UVMapping = function () {};

	THREE.CubeReflectionMapping = function () {};
	THREE.CubeRefractionMapping = function () {};

	THREE.SphericalReflectionMapping = function () {};
	THREE.SphericalRefractionMapping = function () {};

	// Wrapping modes

	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;

	// Filters

	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;

	// Data types

	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;

	// Pixel types

	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;

	// Pixel formats

	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;

	// DDS / ST3C Compressed texture formats

	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;


	// PVRTC compressed texture formats

	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function ( color ) {

		if ( arguments.length === 3 ) {

			return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

		}

		return this.set( color )

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value instanceof THREE.Color ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var hue2rgb = function ( p, q, t ) {

					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;

				};

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		},

		setStyle: function ( style ) {

			// rgb(255,0,0)

			if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

				var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

				this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
				this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
				this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

				return this;

			}

			// rgb(100%,0%,0%)

			if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

				var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

				this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
				this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
				this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

				return this;

			}

			// #ff0000

			if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

				var color = /^\#([0-9a-f]{6})$/i.exec( style );

				this.setHex( parseInt( color[ 1 ], 16 ) );

				return this;

			}

			// #f00

			if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

				var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

				this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

				return this;

			}

			// red

			if ( /^(\w+)$/i.test( style ) ) {

				this.setHex( THREE.ColorKeywords[ style ] );

				return this;

			}


		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color ) {

			this.r = color.r * color.r;
			this.g = color.g * color.g;
			this.b = color.b * color.b;

			return this;

		},

		copyLinearToGamma: function ( color ) {

			this.r = Math.sqrt( color.r );
			this.g = Math.sqrt( color.g );
			this.b = Math.sqrt( color.b );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array ) {

			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];

			return this;

		},

		toArray: function () {

			return [ this.r, this.g, this.b ];

		},

		clone: function () {

			return new THREE.Color().setRGB( this.r, this.g, this.b );

		}

	};

	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Quaternion = function ( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		_x: 0,_y: 0, _z: 0, _w: 0,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get w () {

			return this._w;

		},

		set w ( value ) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( euler instanceof THREE.Euler === false ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );

			if ( euler.order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( euler.order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( euler.order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function ( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				this.normalize();

				return this;

			}

		}(),

		inverse: function () {

			this.conjugate().normalize();

			return this;

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {},

		clone: function () {

			return new THREE.Quaternion( this._x, this._y, this._z, this._w );

		}

	};

	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	}

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function ( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.x *= s;
			this.y *= s;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			return this;
		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );
			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		clone: function () {

			return new THREE.Vector2( this.x, this.y );

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function ( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function ( euler ) {

				if ( euler instanceof THREE.Euler === false ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromEuler( euler ) );

				return this;

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function ( axis, angle ) {

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				return this;

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

			return this;

		},

		applyProjection: function ( m ) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function ( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );

			};

		}(),

		unproject: function () {

			var matrix;

			return function ( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			this.normalize();

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			return this;

		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength  ) {

				this.multiplyScalar( l / oldLength );
			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function () {

			var v1, dot;

			return function ( vector ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( vector ).normalize();

				dot = this.dot( v1 );

				return this.copy( v1 ).multiplyScalar( dot );

			};

		}(),

		projectOnPlane: function () {

			var v1;

			return function ( planeNormal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			}

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function ( normal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			}

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( this.length() * v.length() );

			// clamp, to handle numerical problems

			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setEulerFromRotationMatrix: function ( m, order ) {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},

		setEulerFromQuaternion: function ( q, order ) {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},

		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

			return this.setFromMatrixPosition( m );

		},

		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

			return this.setFromMatrixScale( m );
		},

		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

			return this.setFromMatrixColumn( index, matrix );

		},

		setFromMatrixPosition: function ( m ) {

			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;
		},

		setFromMatrixColumn: function ( index, matrix ) {

			var offset = index * 4;

			var me = matrix.elements;

			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		clone: function () {

			return new THREE.Vector3( this.x, this.y, this.z );

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;

			}

			return this;

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				 this.x = 1;
				 this.y = 0;
				 this.z = 0;

			} else {

				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) { // m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else { // m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			if ( this.w > v.w ) {

				this.w = v.w;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			if ( this.w < v.w ) {

				this.w = v.w;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			if ( this.w < min.w ) {

				this.w = min.w;

			} else if ( this.w > max.w ) {

				this.w = max.w;

			}

			return this;

		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

	    floor: function () {

	        this.x = Math.floor( this.x );
	        this.y = Math.floor( this.y );
	        this.z = Math.floor( this.z );
	        this.w = Math.floor( this.w );

	        return this;

	    },

	    ceil: function () {

	        this.x = Math.ceil( this.x );
	        this.y = Math.ceil( this.y );
	        this.z = Math.ceil( this.z );
	        this.w = Math.ceil( this.w );

	        return this;

	    },

	    round: function () {

	        this.x = Math.round( this.x );
	        this.y = Math.round( this.y );
	        this.z = Math.round( this.z );
	        this.w = Math.round( this.w );

	        return this;

	    },

	    roundToZero: function () {

	        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
	        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

	        return this;

	    },

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		clone: function () {

			return new THREE.Vector4( this.x, this.y, this.z, this.w );

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Euler = function ( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get order () {

			return this._order;

		},

		set order ( value ) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order ) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

			}

			this._order = order;

			this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function ( q, order, update ) {

			var clamp = THREE.Math.clamp;

			// q is assumed to be normalized

			// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

			var sqx = q.x * q.x;
			var sqy = q.y * q.y;
			var sqz = q.z * q.z;
			var sqw = q.w * q.w;

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
				this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ), - 1, 1 ) );
				this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

			} else if ( order ===  'YXZ' ) {

				this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ), - 1, 1 ) );
				this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
				this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ), - 1, 1 ) );
				this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
				this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

			} else if ( order === 'ZYX' ) {

				this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
				this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ), - 1, 1 ) );
				this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

			} else if ( order === 'YZX' ) {

				this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
				this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
				this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ), - 1, 1 ) );

			} else if ( order === 'XZY' ) {

				this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
				this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
				this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ), - 1, 1 ) );

			} else {

				console.warn( 'THREE.Euler: .setFromQuaternion() given unsupported order: ' + order )

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function ( newOrder ) {

				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );

			};


		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function () {

			return [ this._x, this._y, this._z, this._order ];

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {},

		clone: function () {

			return new THREE.Euler( this._x, this._y, this._z, this._order );

		}

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Line3 = function ( start, end ) {

		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function ( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = THREE.Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		},

		clone: function () {

			return new THREE.Line3().copy( this );

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Box2 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;
		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;
		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;
		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		},

		clone: function () {

			return new THREE.Box2().copy( this );

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and childrens', world transforms

			var v1 = new THREE.Vector3();

			return function ( object ) {

				var scope = this;

				object.updateMatrixWorld( true );

				this.makeEmpty();

				object.traverse( function ( node ) {

					var geometry = node.geometry;

					if ( geometry !== undefined ) {

						if ( geometry instanceof THREE.Geometry ) {

							var vertices = geometry.vertices;

							for ( var i = 0, il = vertices.length; i < il; i ++ ) {

								v1.copy( vertices[ i ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

							var positions = geometry.attributes[ 'position' ].array;

							for ( var i = 0, il = positions.length; i < il; i += 3 ) {

								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				} );

				return this;

			};

		}(),

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function ( matrix ) {

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

				this.makeEmpty();
				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		},

		clone: function () {

			return new THREE.Box3().copy( this );

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array( [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		copy: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]

			);

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1 = new THREE.Vector3();

			return function ( array, offset, length ) {

				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];

					v1.applyMatrix3( this );

					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;

				}

				return array;

			};

		}(),

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnInvertible ) {

			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )

			var me = matrix.elements;
			var te = this.elements;

			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

			// no inverse

			if ( det === 0 ) {

				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1.0 / det );

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];

			return array;

		},

		getNormalMatrix: function ( m ) {

			// input: THREE.Matrix4

			this.getInverse( m ).transpose();

			return this;

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];

		},

		clone: function () {

			return new THREE.Matrix3().fromArray( this.elements );

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		copy: function ( m ) {

			this.elements.set( m.elements );

			return this;

		},

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},

		copyPosition: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractRotation: function () {

			var v1 = new THREE.Vector3();

			return function ( m ) {

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

			return this.makeRotationFromQuaternion( q );

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x = new THREE.Vector3();
			var y = new THREE.Vector3();
			var z = new THREE.Vector3();

			return function ( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target ).normalize();

				if ( z.length() === 0 ) {

					z.z = 1;

				}

				x.crossVectors( up, z ).normalize();

				if ( x.length() === 0 ) {

					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();

				}

				y.crossVectors( z, x );


				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function ( a, b, r ) {

			var te = this.elements;

			this.multiplyMatrices( a, b );

			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );

		},

		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1 = new THREE.Vector3();

			return function ( array, offset, length ) {

				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];

					v1.applyMatrix4( this );

					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;

				}

				return array;

			};

		}(),

		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

			v.transformDirection( this );

		},

		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		getPosition: function () {

			var v1 = new THREE.Vector3();

			return function () {

				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

			};

		}(),

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnInvertible ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;

			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

			if ( det == 0 ) {

				var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;
			}

			this.multiplyScalar( 1 / det );

			return this;

		},

		translate: function ( v ) {

			console.warn( 'THREE.Matrix4: .translate() has been removed.' );

		},

		rotateX: function ( angle ) {

			console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );

		},

		rotateY: function ( angle ) {

			console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );

		},

		rotateZ: function ( angle ) {

			console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},

		rotateByAxis: function ( axis, angle ) {

			console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector = new THREE.Vector3();
			var matrix = new THREE.Matrix4();

			return function ( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
					sx = - sx;
				}

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part

				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function ( left, right, bottom, top, near, far ) {

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makePerspective: function ( fov, aspect, near, far ) {

			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;

			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;

			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];

		},

		clone: function () {

			return new THREE.Matrix4().fromArray( this.elements );

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Ray = function ( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function ( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceTo( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceTo( point );

			};

		}(),

		distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
			var segDir = v1.clone().sub( v0 ).normalize();
			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var diff = this.origin.clone().sub( segCenter );
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det >= 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

			}

			return sqrDist;

		},

		isIntersectionSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		intersectSphere: function () {

			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

			var v1 = new THREE.Vector3();

			return function ( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );

				var tca = v1.dot( this.direction );

				var d2 = v1.dot( v1 ) - tca * tca;

				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0 
				return this.at( t0, optionalTarget );

			}

		}(),

		isIntersectionPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );
			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) == 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t :  null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;
			}

			return this.at( t, optionalTarget );

		},

		isIntersectionBox: function () {

			var v = new THREE.Vector3();

			return function ( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		}(),

		intersectBox: function ( box , optionalTarget ) {

			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

			var tmin,tmax,tymin,tymax,tzmin,tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function ( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();

			return this;
		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		},

		clone: function () {

			return new THREE.Ray().copy( this );

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function ( center, radius ) {

		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;
		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function ( points, optionalCenter )  {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).center( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

	 		};

		}(),

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new THREE.Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		},

		clone: function () {

			return new THREE.Sphere().copy( this );

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6 ; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}
				}

				return true;
			};

		}(),


		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		},

		clone: function () {

			return new THREE.Frustum().copy( this );

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Plane = function ( normal, constant ) {

		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function ( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),


		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

		},

		orthoPoint: function ( point, optionalTarget ) {

			var perpendicularMagnitude = this.distanceToPoint( point );

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

		},

		isIntersectionLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function ( line, optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator == 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) == 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),


		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function ( matrix, optionalNormalMatrix ) {

				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );

				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant = this.constant - offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

		},

		clone: function () {

			return new THREE.Plane().copy( this );

		}

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function () {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

						uuid[ i ] = '-';

					} else if ( i == 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}
				}

				return uuid.join( '' );

			};

		}(),

		// Clamp value to range <a, b>

		clamp: function ( x, a, b ) {

			return ( x < a ) ? a : ( ( x > b ) ? b : x );

		},

		// Clamp value to range <a, inf)

		clampBottom: function ( x, a ) {

			return x < a ? a : x;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)

		random16: function () {

			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function () {

			var degreeToRadiansFactor = Math.PI / 180;

			return function ( degrees ) {

				return degrees * degreeToRadiansFactor;

			};

		}(),

		radToDeg: function () {

			var radianToDegreesFactor = 180 / Math.PI;

			return function ( radians ) {

				return radians * radianToDegreesFactor;

			};

		}(),

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function ( points ) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		this.initFromArray = function ( a ) {

			this.points = [];

			for ( var i = 0; i < a.length; i ++ ) {

				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

			}

		};

		this.getPoint = function ( k ) {

			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for ( i = 0; i < l; i ++ ) {

				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function ( nSubDivisions ) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[ 0 ] = 0;

			if ( ! nSubDivisions ) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy( this.points[ 0 ] );

			for ( i = 1; i < nSamples; i ++ ) {

				index = i / nSamples;

				position = this.getPoint( index );
				tmpVec.copy( position );

				totalLength += tmpVec.distanceTo( oldPosition );

				oldPosition.copy( position );

				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );

				if ( intPoint != oldIntPoint ) {

					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[ chunkLengths.length ] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function ( samplingCoef ) {

			var i, j,
				index, indexCurrent, indexNext,
				linearDistance, realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

			for ( i = 1; i < this.points.length; i ++ ) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

				sampling = Math.ceil( samplingCoef * realDistance / sl.total );

				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );

				for ( j = 1; j < sampling - 1; j ++ ) {

					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );

				}

				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		};

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function ( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function ( a, b, c, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}();

	// static/instance method to calculate barycoordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new THREE.Vector3();

			// colinear or singular triangle
			if ( denom == 0 ) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycoordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function ( point, a, b, c ) {

			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function () {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		},

		clone: function () {

			return new THREE.Triangle().copy( this );

		}

	};

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function ( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

			this.oldTime = this.startTime;
			this.running = true;
		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();

			}

			if ( this.running ) {

				var newTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () {}

	THREE.EventDispatcher.prototype = {

		constructor: THREE.EventDispatcher,

		apply: function ( object ) {

			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

		},

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

				return true;

			}

			return false;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = [];
				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */

	( function ( THREE ) {

		THREE.Raycaster = function ( origin, direction, near, far ) {

			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Sprite: {},
				Mesh: {},
				PointCloud: { threshold: 1 },
				LOD: {},
				Line: {}
			};

		};

		var descSort = function ( a, b ) {

			return a.distance - b.distance;

		};

		var intersectObject = function ( object, raycaster, intersects, recursive ) {

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		};

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			precision: 0.0001,
			linePrecision: 1,

			set: function ( origin, direction ) {

				this.ray.set( origin, direction );
				// direction is assumed to be normalized (for accurate distance calculations)

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( descSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( objects instanceof Array === false ) {

					console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( descSort );

				return intersects;

			}

		};

	}( THREE ) );

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Object3D = function () {

		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = undefined;
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var scope = this;

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );

		var onRotationChange = function () {
			quaternion.setFromEuler( rotation, false );
		};

		var onQuaternionChange = function () {
			rotation.setFromQuaternion( quaternion, undefined, false );
		};

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
		} );

		this.renderDepth = null;

		this.rotationAutoUpdate = true;

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = true;
		this.matrixWorldNeedsUpdate = false;

		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

	THREE.Object3D.prototype = {

		constructor: THREE.Object3D,

		get eulerOrder () {

			console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			return this.rotation.order;

		},

		set eulerOrder ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			this.rotation.order = value;

		},

		get useQuaternion () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set useQuaternion ( value ) {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function ( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			}

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function ( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			}

		}(),

		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},

		translateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				m1.lookAt( vector, this.position, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			};

			if ( object === this ) {

				console.error( "THREE.Object3D.add:", object, "can't be added as a child of itself." );
				return this;

			}

			if ( object instanceof THREE.Object3D ) {

				if ( object.parent !== undefined ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add:", object, "is not an instance of THREE.Object3D." );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i++ ) {

					this.remove( arguments[ i ] );

				}

			};

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = undefined;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

		},

		getChildByName: function ( name, recursive ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name, recursive );

		},

		getObjectById: function ( id, recursive ) {

			if ( this.id === id ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectById( id, recursive );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getObjectByName: function ( name, recursive ) {

			if ( this.name === name ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByName( name, recursive );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			}

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			}

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			}

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			}

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].traverseVisible( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate === true ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate === true || force === true ) {

				if ( this.parent === undefined ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.3,
					type: 'Object',
					generator: 'ObjectExporter'
				}
			};

			//

			var geometries = {};

			var parseGeometry = function ( geometry ) {

				if ( output.geometries === undefined ) {

					output.geometries = [];

				}

				if ( geometries[ geometry.uuid ] === undefined ) {

					var json = geometry.toJSON();

					delete json.metadata;

					geometries[ geometry.uuid ] = json;

					output.geometries.push( json );

				}

				return geometry.uuid;

			};

			//

			var materials = {};

			var parseMaterial = function ( material ) {

				if ( output.materials === undefined ) {

					output.materials = [];

				}

				if ( materials[ material.uuid ] === undefined ) {

					var json = material.toJSON();

					delete json.metadata;

					materials[ material.uuid ] = json;

					output.materials.push( json );

				}

				return material.uuid;

			};

			//

			var parseObject = function ( object ) {

				var data = {};

				data.uuid = object.uuid;
				data.type = object.type;

				if ( object.name !== '' ) data.name = object.name;
				if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
				if ( object.visible !== true ) data.visible = object.visible;

				if ( object instanceof THREE.PerspectiveCamera ) {

					data.fov = object.fov;
					data.aspect = object.aspect;
					data.near = object.near;
					data.far = object.far;

				} else if ( object instanceof THREE.OrthographicCamera ) {

					data.left = object.left;
					data.right = object.right;
					data.top = object.top;
					data.bottom = object.bottom;
					data.near = object.near;
					data.far = object.far;

				} else if ( object instanceof THREE.AmbientLight ) {

					data.color = object.color.getHex();

				} else if ( object instanceof THREE.DirectionalLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;

				} else if ( object instanceof THREE.PointLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;

				} else if ( object instanceof THREE.SpotLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.angle = object.angle;
					data.exponent = object.exponent;

				} else if ( object instanceof THREE.HemisphereLight ) {

					data.color = object.color.getHex();
					data.groundColor = object.groundColor.getHex();

				} else if ( object instanceof THREE.Mesh ) {

					data.geometry = parseGeometry( object.geometry );
					data.material = parseMaterial( object.material );

				} else if ( object instanceof THREE.Line ) {

					data.geometry = parseGeometry( object.geometry );
					data.material = parseMaterial( object.material );

				} else if ( object instanceof THREE.Sprite ) {

					data.material = parseMaterial( object.material );

				}

				data.matrix = object.matrix.toArray();

				if ( object.children.length > 0 ) {

					data.children = [];

					for ( var i = 0; i < object.children.length; i ++ ) {

						data.children.push( parseObject( object.children[ i ] ) );

					}

				}

				return data;

			}

			output.object = parseObject( this );

			return output;

		},

		clone: function ( object, recursive ) {

			if ( object === undefined ) object = new THREE.Object3D();
			if ( recursive === undefined ) recursive = true;

			object.name = this.name;

			object.up.copy( this.up );

			object.position.copy( this.position );
			object.quaternion.copy( this.quaternion );
			object.scale.copy( this.scale );

			object.renderDepth = this.renderDepth;

			object.rotationAutoUpdate = this.rotationAutoUpdate;

			object.matrix.copy( this.matrix );
			object.matrixWorld.copy( this.matrixWorld );

			object.matrixAutoUpdate = this.matrixAutoUpdate;
			object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

			object.visible = this.visible;

			object.castShadow = this.castShadow;
			object.receiveShadow = this.receiveShadow;

			object.frustumCulled = this.frustumCulled;

			object.userData = JSON.parse( JSON.stringify( this.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < this.children.length; i ++ ) {

					var child = this.children[ i ];
					object.add( child.clone() );

				}

			}

			return object;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

	THREE.Object3DIdCount = 0;

	// File:src/core/Projector.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Projector = function () {

		console.warn( 'THREE.Projector has been moved to /examples/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function ( vector, camera ) {

			console.error( 'THREE.Projector: .pickingRay() has been removed.' );

		};

	};

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];

		this.vertexTangents = [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			var face = new THREE.Face3( this.a, this.b, this.c );

			face.normal.copy( this.normal );
			face.color.copy( this.color );

			face.materialIndex = this.materialIndex;

			for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

				face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

				face.vertexColors[ i ] = this.vertexColors[ i ].clone();

			}

			for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

				face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

			}

			return face;

		}

	};

	// File:src/core/Face4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
		return new THREE.Face3( a, b, c, normal, color, materialIndex );

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function ( array, itemSize ) {

		this.array = array;
		this.itemSize = itemSize;

		this.needsUpdate = false;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get length () {

			return this.array.length;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

		},

		set: function ( value ) {

			this.array.set( value );

			return this;

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		clone: function () {

			return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

		}

	};

	//

	THREE.Int8Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint8Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );


	};

	THREE.Int16Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint16Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Int32Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint32Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Float32Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Float64Attribute = function ( data, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.attributes = {};
		this.attributesKeys = [];

		this.drawcalls = [];
		this.offsets = this.drawcalls; // backwards compatibility

		this.boundingBox = null;
		this.boundingSphere = null;

	};

	THREE.BufferGeometry.prototype = {

		constructor: THREE.BufferGeometry,

		addAttribute: function ( name, attribute ) {

			if ( attribute instanceof THREE.BufferAttribute === false ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

				return;

			}

			this.attributes[ name ] = attribute;
			this.attributesKeys = Object.keys( this.attributes );

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		addDrawCall: function ( start, count, indexOffset ) {

			this.drawcalls.push( {

				start: start,
				count: count,
				index: indexOffset !== undefined ? indexOffset : 0

			} );

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;

			}

		},

		center: function () {

			// TODO

		},

		fromGeometry: function ( geometry, settings ) {

			settings = settings || { 'vertexColors': THREE.NoColors };

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs;
			var vertexColors = settings.vertexColors;
			var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

			var positions = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

			var normals = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

			if ( vertexColors !== THREE.NoColors ) {

				var colors = new Float32Array( faces.length * 3 * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

			}

			if ( hasFaceVertexUv === true ) {

				var uvs = new Float32Array( faces.length * 3 * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

			}

			for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

				var face = faces[ i ];

				var a = vertices[ face.a ];
				var b = vertices[ face.b ];
				var c = vertices[ face.c ];

				positions[ i3     ] = a.x;
				positions[ i3 + 1 ] = a.y;
				positions[ i3 + 2 ] = a.z;

				positions[ i3 + 3 ] = b.x;
				positions[ i3 + 4 ] = b.y;
				positions[ i3 + 5 ] = b.z;

				positions[ i3 + 6 ] = c.x;
				positions[ i3 + 7 ] = c.y;
				positions[ i3 + 8 ] = c.z;

				if ( hasFaceVertexNormals === true ) {

					var na = face.vertexNormals[ 0 ];
					var nb = face.vertexNormals[ 1 ];
					var nc = face.vertexNormals[ 2 ];

					normals[ i3     ] = na.x;
					normals[ i3 + 1 ] = na.y;
					normals[ i3 + 2 ] = na.z;

					normals[ i3 + 3 ] = nb.x;
					normals[ i3 + 4 ] = nb.y;
					normals[ i3 + 5 ] = nb.z;

					normals[ i3 + 6 ] = nc.x;
					normals[ i3 + 7 ] = nc.y;
					normals[ i3 + 8 ] = nc.z;

				} else {

					var n = face.normal;

					normals[ i3     ] = n.x;
					normals[ i3 + 1 ] = n.y;
					normals[ i3 + 2 ] = n.z;

					normals[ i3 + 3 ] = n.x;
					normals[ i3 + 4 ] = n.y;
					normals[ i3 + 5 ] = n.z;

					normals[ i3 + 6 ] = n.x;
					normals[ i3 + 7 ] = n.y;
					normals[ i3 + 8 ] = n.z;

				}

				if ( vertexColors === THREE.FaceColors ) {

					var fc = face.color;

					colors[ i3     ] = fc.r;
					colors[ i3 + 1 ] = fc.g;
					colors[ i3 + 2 ] = fc.b;

					colors[ i3 + 3 ] = fc.r;
					colors[ i3 + 4 ] = fc.g;
					colors[ i3 + 5 ] = fc.b;

					colors[ i3 + 6 ] = fc.r;
					colors[ i3 + 7 ] = fc.g;
					colors[ i3 + 8 ] = fc.b;

				} else if ( vertexColors === THREE.VertexColors ) {

					var vca = face.vertexColors[ 0 ];
					var vcb = face.vertexColors[ 1 ];
					var vcc = face.vertexColors[ 2 ];

					colors[ i3     ] = vca.r;
					colors[ i3 + 1 ] = vca.g;
					colors[ i3 + 2 ] = vca.b;

					colors[ i3 + 3 ] = vcb.r;
					colors[ i3 + 4 ] = vcb.g;
					colors[ i3 + 5 ] = vcb.b;

					colors[ i3 + 6 ] = vcc.r;
					colors[ i3 + 7 ] = vcc.g;
					colors[ i3 + 8 ] = vcc.b;

				}

				if ( hasFaceVertexUv === true ) {

					var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
					var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
					var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

					uvs[ i2     ] = uva.x;
					uvs[ i2 + 1 ] = uva.y;

					uvs[ i2 + 2 ] = uvb.x;
					uvs[ i2 + 3 ] = uvb.y;

					uvs[ i2 + 4 ] = uvc.x;
					uvs[ i2 + 5 ] = uvc.y;

				}

			}

			this.computeBoundingSphere()

			return this;

		},

		computeBoundingBox: function () {

			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new THREE.Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					var bb = this.boundingBox;
					bb.makeEmpty();

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						bb.expandByPoint( vector );

					}

				}

				if ( positions === undefined || positions.length === 0 ) {

					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

				}

			}

		}(),

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					box.makeEmpty();

					var center = this.boundingSphere.center;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						box.expandByPoint( vector );

					}

					box.center( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

					}

				}

			}

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var attributes = this.attributes;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var normals = attributes.normal.array;

					for ( var i = 0, il = normals.length; i < il; i ++ ) {

						normals[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),

				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();

				// indexed elements

				if ( attributes.index ) {

					var indices = attributes.index.array;

					var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

					for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

						var start = offsets[ j ].start;
						var count = offsets[ j ].count;
						var index = offsets[ j ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = ( index + indices[ i     ] ) * 3;
							vB = ( index + indices[ i + 1 ] ) * 3;
							vC = ( index + indices[ i + 2 ] ) * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA     ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB     ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC     ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i     ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		computeTangents: function () {

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( this.attributes.index === undefined ||
				 this.attributes.position === undefined ||
				 this.attributes.normal === undefined ||
				 this.attributes.uv === undefined ) {

				console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
				return;

			}

			var indices = this.attributes.index.array;
			var positions = this.attributes.position.array;
			var normals = this.attributes.normal.array;
			var uvs = this.attributes.uv.array;

			var nVertices = positions.length / 3;

			if ( this.attributes.tangent === undefined ) {

				this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			var tangents = this.attributes.tangent.array;

			var tan1 = [], tan2 = [];

			for ( var k = 0; k < nVertices; k ++ ) {

				tan1[ k ] = new THREE.Vector3();
				tan2[ k ] = new THREE.Vector3();

			}

			var vA = new THREE.Vector3(),
				vB = new THREE.Vector3(),
				vC = new THREE.Vector3(),

				uvA = new THREE.Vector2(),
				uvB = new THREE.Vector2(),
				uvC = new THREE.Vector2(),

				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r;

			var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;

				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;

				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;

				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;

				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;

				r = 1.0 / ( s1 * t2 - s2 * t1 );

				sdir.set(
					( t2 * x1 - t1 * x2 ) * r,
					( t2 * y1 - t1 * y2 ) * r,
					( t2 * z1 - t1 * z2 ) * r
				);

				tdir.set(
					( s1 * x2 - s2 * x1 ) * r,
					( s1 * y2 - s2 * y1 ) * r,
					( s1 * z2 - s2 * z1 ) * r
				);

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			var i, il;
			var j, jl;
			var iA, iB, iC;

			if ( this.drawcalls.length === 0 ) {

				this.addDrawCall( 0, indices.length, 0 );

			}

			var drawcalls = this.drawcalls;

			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;

				for ( i = start, il = start + count; i < il; i += 3 ) {

					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];

					handleTriangle( iA, iB, iC );

				}

			}

			var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
			var n = new THREE.Vector3(), n2 = new THREE.Vector3();
			var w, t, test;

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				test = tmp2.dot( tan2[ v ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4     ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;

				for ( i = start, il = start + count; i < il; i += 3 ) {

					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];

					handleVertex( iA );
					handleVertex( iB );
					handleVertex( iC );

				}

			}

		},

		/*
			computeOffsets
			Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
			This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
			WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
			indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
		*/
		computeOffsets: function ( indexBufferSize ) {

			var size = indexBufferSize;
			if ( indexBufferSize === undefined )
				size = 65535; //WebGL limits type of index buffer values to 16-bit.

			var s = Date.now();

			var indices = this.attributes.index.array;
			var vertices = this.attributes.position.array;

			var verticesCount = ( vertices.length / 3 );
			var facesCount = ( indices.length / 3 );

			/*
			console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
			console.log("Faces to process: "+(indices.length/3));
			console.log("Reordering "+verticesCount+" vertices.");
			*/

			var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
			var indexPtr = 0;
			var vertexPtr = 0;

			var offsets = [ { start:0, count:0, index:0 } ];
			var offset = offsets[ 0 ];

			var duplicatedVertices = 0;
			var newVerticeMaps = 0;
			var faceVertices = new Int32Array( 6 );
			var vertexMap = new Int32Array( vertices.length );
			var revVertexMap = new Int32Array( vertices.length );
			for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

			/*
				Traverse every face and reorder vertices in the proper offsets of 65k.
				We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
			*/
			for ( var findex = 0; findex < facesCount; findex ++ ) {
				newVerticeMaps = 0;

				for ( var vo = 0; vo < 3; vo ++ ) {
					var vid = indices[ findex * 3 + vo ];
					if ( vertexMap[ vid ] == - 1 ) {
						//Unmapped vertice
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						newVerticeMaps ++;
					} else if ( vertexMap[ vid ] < offset.index ) {
						//Reused vertices from previous block (duplicate)
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						duplicatedVertices ++;
					} else {
						//Reused vertice in the current block
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
					}
				}

				var faceMax = vertexPtr + newVerticeMaps;
				if ( faceMax > ( offset.index + size ) ) {
					var new_offset = { start:indexPtr, count:0, index:vertexPtr };
					offsets.push( new_offset );
					offset = new_offset;

					//Re-evaluate reused vertices in light of new offset.
					for ( var v = 0; v < 6; v += 2 ) {
						var new_vid = faceVertices[ v + 1 ];
						if ( new_vid > - 1 && new_vid < offset.index )
							faceVertices[ v + 1 ] = - 1;
					}
				}

				//Reindex the face.
				for ( var v = 0; v < 6; v += 2 ) {
					var vid = faceVertices[ v ];
					var new_vid = faceVertices[ v + 1 ];

					if ( new_vid === - 1 )
						new_vid = vertexPtr ++;

					vertexMap[ vid ] = new_vid;
					revVertexMap[ new_vid ] = vid;
					sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
					offset.count ++;
				}
			}

			/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
			this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
			this.offsets = offsets;

			/*
			var orderTime = Date.now();
			console.log("Reorder time: "+(orderTime-s)+"ms");
			console.log("Duplicated "+duplicatedVertices+" vertices.");
			console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
			console.log("Draw offsets: "+offsets.length);
			*/

			return offsets;
		},

		merge: function () {

			console.log( 'BufferGeometry.merge(): TODO' );

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for ( var i = 0, il = normals.length; i < il; i += 3 ) {

				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];

				n = 1.0 / Math.sqrt( x * x + y * y + z * z );

				normals[ i     ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;

			}

		},

		/*
			reoderBuffers:
			Reorder attributes based on a new indexBuffer and indexMap.
			indexBuffer - Uint16Array of the new ordered indices.
			indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
			vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
		*/
		reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

			/* Create a copy of all attributes for reordering. */
			var sortedAttributes = {};
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var sourceArray = this.attributes[ attr ].array;
				sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
			}

			/* Move attribute positions based on the new index map */
			for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
				var vid = indexMap[ new_vid ];
				for ( var attr in this.attributes ) {
					if ( attr == 'index' )
						continue;
					var attrArray = this.attributes[ attr ].array;
					var attrSize = this.attributes[ attr ].itemSize;
					var sortedAttr = sortedAttributes[ attr ];
					for ( var k = 0; k < attrSize; k ++ )
						sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
				}
			}

			/* Carry the new sorted buffers locally */
			this.attributes[ 'index' ].array = indexBuffer;
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				this.attributes[ attr ].array = sortedAttributes[ attr ];
				this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
			}
		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type,
				data: {
					attributes: {}
				}
			};

			var attributes = this.attributes;
			var offsets = this.offsets;
			var boundingSphere = this.boundingSphere;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = [], typeArray = attribute.array;

				for ( var i = 0, l = typeArray.length; i < l; i ++ ) {

					array[ i ] = typeArray[ i ];

				}

				output.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				}

			}

			if ( offsets.length > 0 ) {

				output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

			}

			if ( boundingSphere !== null ) {

				output.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				}

			}

			return output;

		},

		clone: function () {

			var geometry = new THREE.BufferGeometry();

			for ( var attr in this.attributes ) {

				var sourceAttr = this.attributes[ attr ];
				geometry.addAttribute( attr, sourceAttr.clone() );

			}

			for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

				var offset = this.offsets[ i ];

				geometry.offsets.push( {

					start: offset.start,
					index: offset.index,
					count: offset.count

				} );

			}

			return geometry;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Geometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];  // one-to-one vertex colors, used in Points and Line

		this.faces = [];

		this.faceVertexUvs = [ [] ];

		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.hasTangents = false;

		this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.tangentsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;

		this.groupsNeedUpdate = false;

	};

	THREE.Geometry.prototype = {

		constructor: THREE.Geometry,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox instanceof THREE.Box3 ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere instanceof THREE.Sphere ) {

				this.computeBoundingSphere();

			}

		},

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var attributes = geometry.attributes;

			var vertices = attributes.position.array;
			var indices = attributes.index !== undefined ? attributes.index.array : undefined;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

			var tempNormals = [];
			var tempUVs = [];

			for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

			}

			var addFace = function ( a, b, c ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );
				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ], tempUVs[ b ], tempUVs[ c ] ] );

			};

			if ( indices !== undefined ) {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			} else {

				for ( var i = 0; i < vertices.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}
			
			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = new THREE.Vector3();

			offset.addVectors( this.boundingBox.min, this.boundingBox.max );
			offset.multiplyScalar( - 0.5 );

			this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
			this.computeBoundingBox();

			return offset;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC, vD;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
					db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
				face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
				face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			// based on http://www.terathon.com/code/tangent.html
			// tangents go to vertices

			var f, fl, v, vl, i, il, vertexIndex,
				face, uv, vA, vB, vC, uvA, uvB, uvC,
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r, t, test,
				tan1 = [], tan2 = [],
				sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
				tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
				n = new THREE.Vector3(), w;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				tan1[ v ] = new THREE.Vector3();
				tan2[ v ] = new THREE.Vector3();

			}

			function handleTriangle( context, a, b, c, ua, ub, uc ) {

				vA = context.vertices[ a ];
				vB = context.vertices[ b ];
				vC = context.vertices[ c ];

				uvA = uv[ ua ];
				uvB = uv[ ub ];
				uvC = uv[ uc ];

				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;

				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;

				r = 1.0 / ( s1 * t2 - s2 * t1 );
				sdir.set( ( t2 * x1 - t1 * x2 ) * r,
						  ( t2 * y1 - t1 * y2 ) * r,
						  ( t2 * z1 - t1 * z2 ) * r );
				tdir.set( ( s1 * x2 - s2 * x1 ) * r,
						  ( s1 * y2 - s2 * y1 ) * r,
						  ( s1 * z2 - s2 * z1 ) * r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];
				uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

			}

			var faceIndex = [ 'a', 'b', 'c', 'd' ];

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

					n.copy( face.vertexNormals[ i ] );

					vertexIndex = face[ faceIndex[ i ] ];

					t = tan1[ vertexIndex ];

					// Gram-Schmidt orthogonalize

					tmp.copy( t );
					tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

					// Calculate handedness

					tmp2.crossVectors( face.vertexNormals[ i ], t );
					test = tmp2.dot( tan2[ vertexIndex ] );
					w = ( test < 0.0 ) ? - 1.0 : 1.0;

					face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

				}

			}

			this.hasTangents = true;

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( geometry instanceof THREE.Geometry === false ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

				}

				uvs1.push( uvCopy );

			}

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i,il, face;
			var indices, k, j, jl, u;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			};


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
					if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}
				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type
			};

			if ( this.name !== "" ) output.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

				}

				return output;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );


				/*
				if ( hasMaterial ) {

					faces.push( face.materialIndex );

				}
				*/

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			output.data = {};

			output.data.vertices = vertices;
			output.data.normals = normals;
			if ( colors.length > 0 ) output.data.colors = colors;
			if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
			output.data.faces = faces;

			//

			return output;

		},

		clone: function () {

			var geometry = new THREE.Geometry();

			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				geometry.vertices.push( vertices[ i ].clone() );

			}

			var faces = this.faces;

			for ( var i = 0, il = faces.length; i < il; i ++ ) {

				geometry.faces.push( faces[ i ].clone() );

			}

			var uvs = this.faceVertexUvs[ 0 ];

			for ( var i = 0, il = uvs.length; i < il; i ++ ) {

				var uv = uvs[ i ], uvCopy = [];

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

				}

				geometry.faceVertexUvs[ 0 ].push( uvCopy );

			}

			return geometry;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

	THREE.GeometryIdCount = 0;

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		}

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( this.position, vector, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}();

	THREE.Camera.prototype.clone = function ( camera ) {

		if ( camera === undefined ) camera = new THREE.Camera();

		THREE.Object3D.prototype.clone.call( this, camera );

		camera.matrixWorldInverse.copy( this.matrixWorldInverse );
		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;
	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function ( near, far, cubeResolution ) {

		THREE.Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

		this.updateCubeMap = function ( renderer, scene ) {

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;

			renderTarget.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

		};

	};

	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

		THREE.Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

	};

	THREE.OrthographicCamera.prototype.clone = function () {

		var camera = new THREE.OrthographicCamera();

		THREE.Camera.prototype.clone.call( this, camera );

		camera.zoom = this.zoom;

		camera.left = this.left;
		camera.right = this.right;
		camera.top = this.top;
		camera.bottom = this.bottom;

		camera.near = this.near;
		camera.far = this.far;

		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;
	};

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

		THREE.Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.zoom = 1;

		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (fullframe) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */

	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

		if ( frameHeight === undefined ) frameHeight = 24;

		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();

	}


	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.updateProjectionMatrix();

	};


	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

		if ( this.fullWidth ) {

			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );

			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);

		} else {

			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

		}

	};

	THREE.PerspectiveCamera.prototype.clone = function () {

		var camera = new THREE.PerspectiveCamera();

		THREE.Camera.prototype.clone.call( this, camera );

		camera.zoom = this.zoom;

		camera.fov = this.fov;
		camera.aspect = this.aspect;
		camera.near = this.near;
		camera.far = this.far;

		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;

	};

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function ( color ) {

		THREE.Object3D.call( this );

		this.type = 'Light';
		
		this.color = new THREE.Color( color );

	};

	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Light.prototype.clone = function ( light ) {

		if ( light === undefined ) light = new THREE.Light();

		THREE.Object3D.prototype.clone.call( this, light );

		light.color.copy( this.color );

		return light;

	};

	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function ( color ) {

		THREE.Light.call( this, color );

		this.type = 'AmbientLight';

	};

	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

	THREE.AmbientLight.prototype.clone = function () {

		var light = new THREE.AmbientLight();

		THREE.Light.prototype.clone.call( this, light );

		return light;

	};

	// File:src/lights/AreaLight.js

	/**
	 * @author MPanknin / http://www.redplant.de/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.AreaLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'AreaLight';

		this.normal = new THREE.Vector3( 0, - 1, 0 );
		this.right = new THREE.Vector3( 1, 0, 0 );

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.width = 1.0;
		this.height = 1.0;

		this.constantAttenuation = 1.5;
		this.linearAttenuation = 0.5;
		this.quadraticAttenuation = 0.1;

	};

	THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'DirectionalLight';

		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.castShadow = false;
		this.onlyShadow = false;

		//

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;

		this.shadowCameraLeft = - 500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = - 500;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		//

		this.shadowCascade = false;

		this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
		this.shadowCascadeCount = 2;

		this.shadowCascadeBias = [ 0, 0, 0 ];
		this.shadowCascadeWidth = [ 512, 512, 512 ];
		this.shadowCascadeHeight = [ 512, 512, 512 ];

		this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
		this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

		this.shadowCascadeArray = [];

		//

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

	THREE.DirectionalLight.prototype.clone = function () {

		var light = new THREE.DirectionalLight();

		THREE.Light.prototype.clone.call( this, light );

		light.target = this.target.clone();

		light.intensity = this.intensity;

		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;

		//

		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;

		light.shadowCameraLeft = this.shadowCameraLeft;
		light.shadowCameraRight = this.shadowCameraRight;
		light.shadowCameraTop = this.shadowCameraTop;
		light.shadowCameraBottom = this.shadowCameraBottom;

		light.shadowCameraVisible = this.shadowCameraVisible;

		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;

		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;

		//

		light.shadowCascade = this.shadowCascade;

		light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
		light.shadowCascadeCount = this.shadowCascadeCount;

		light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
		light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
		light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

		light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
		light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

		return light;

	};

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

		THREE.Light.call( this, skyColor );

		this.type = 'HemisphereLight';

		this.position.set( 0, 100, 0 );

		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;

	};

	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

	THREE.HemisphereLight.prototype.clone = function () {

		var light = new THREE.HemisphereLight();

		THREE.Light.prototype.clone.call( this, light );

		light.groundColor.copy( this.groundColor );
		light.intensity = this.intensity;

		return light;

	};

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLight = function ( color, intensity, distance ) {

		THREE.Light.call( this, color );

		this.type = 'PointLight';

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;

	};

	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

	THREE.PointLight.prototype.clone = function () {

		var light = new THREE.PointLight();

		THREE.Light.prototype.clone.call( this, light );

		light.intensity = this.intensity;
		light.distance = this.distance;

		return light;

	};

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

		THREE.Light.call( this, color );

		this.type = 'SpotLight';

		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;

		this.castShadow = false;
		this.onlyShadow = false;

		//

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		//

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

	THREE.SpotLight.prototype.clone = function () {

		var light = new THREE.SpotLight();

		THREE.Light.prototype.clone.call( this, light );

		light.target = this.target.clone();

		light.intensity = this.intensity;
		light.distance = this.distance;
		light.angle = this.angle;
		light.exponent = this.exponent;

		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;

		//

		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;
		light.shadowCameraFov = this.shadowCameraFov;

		light.shadowCameraVisible = this.shadowCameraVisible;

		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;

		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;

		return light;

	};

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = function () {

		this.files = {};

	};

	THREE.Cache.prototype = {

		constructor: THREE.Cache,

		add: function ( key, file ) {

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {}

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function ( showStatus ) {

		this.showStatus = showStatus;
		this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

		this.imageLoader = new THREE.ImageLoader();

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		addStatusElement: function () {

			var e = document.createElement( 'div' );

			e.style.position = 'absolute';
			e.style.right = '0px';
			e.style.top = '0px';
			e.style.fontSize = '0.8em';
			e.style.textAlign = 'left';
			e.style.background = 'rgba(0,0,0,0.25)';
			e.style.color = '#fff';
			e.style.width = '120px';
			e.style.padding = '0.5em 0.5em 0.5em 0.5em';
			e.style.zIndex = 1000;

			e.innerHTML = 'Loading ...';

			return e;

		},

		updateProgress: function ( progress ) {

			var message = 'Loaded ';

			if ( progress.total ) {

				message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


			} else {

				message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

			}

			this.statusDomElement.innerHTML = message;

		},

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		},

		initMaterials: function ( materials, texturePath ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath );

			}

			return array;

		},

		needsTangents: function ( materials ) {

			for ( var i = 0, il = materials.length; i < il; i ++ ) {

				var m = materials[ i ];

				if ( m instanceof THREE.ShaderMaterial ) return true;

			}

			return false;

		},

		createMaterial: function ( m, texturePath ) {

			var scope = this;

			function nearest_pow2( n ) {

				var l = Math.log( n ) / Math.LN2;
				return Math.pow( 2, Math.round(  l ) );

			}

			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + sourceFile;

				var texture;

				var loader = THREE.Loader.Handlers.get( fullPath );

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					texture = new THREE.Texture();

					loader = scope.imageLoader;
					loader.crossOrigin = scope.crossOrigin;
					loader.load( fullPath, function ( image ) {

						if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
							 THREE.Math.isPowerOfTwo( image.height ) === false ) {

							var width = nearest_pow2( image.width );
							var height = nearest_pow2( image.height );

							var canvas = document.createElement( 'canvas' );
							canvas.width = width;
							canvas.height = height;

							var context = canvas.getContext( '2d' );
							context.drawImage( image, 0, 0, width, height );

							texture.image = canvas;

						} else {

							texture.image = image;

						}

						texture.needsUpdate = true;

					} );

				}

				texture.sourceFile = sourceFile;

				if ( repeat ) {

					texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset ) {

					texture.offset.set( offset[ 0 ], offset[ 1 ] );

				}

				if ( wrap ) {

					var wrapMap = {
						'repeat': THREE.RepeatWrapping,
						'mirror': THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

				}

				if ( anisotropy ) {

					texture.anisotropy = anisotropy;

				}

				where[ name ] = texture;

			}

			function rgb2hex( rgb ) {

				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

			}

			// defaults

			var mtype = 'MeshLambertMaterial';
			var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

			// parameters from model file

			if ( m.shading ) {

				var shading = m.shading.toLowerCase();

				if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
				else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

			}

			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

				mpars.blending = THREE[ m.blending ];

			}

			if ( m.transparent !== undefined || m.opacity < 1.0 ) {

				mpars.transparent = m.transparent;

			}

			if ( m.depthTest !== undefined ) {

				mpars.depthTest = m.depthTest;

			}

			if ( m.depthWrite !== undefined ) {

				mpars.depthWrite = m.depthWrite;

			}

			if ( m.visible !== undefined ) {

				mpars.visible = m.visible;

			}

			if ( m.flipSided !== undefined ) {

				mpars.side = THREE.BackSide;

			}

			if ( m.doubleSided !== undefined ) {

				mpars.side = THREE.DoubleSide;

			}

			if ( m.wireframe !== undefined ) {

				mpars.wireframe = m.wireframe;

			}

			if ( m.vertexColors !== undefined ) {

				if ( m.vertexColors === 'face' ) {

					mpars.vertexColors = THREE.FaceColors;

				} else if ( m.vertexColors ) {

					mpars.vertexColors = THREE.VertexColors;

				}

			}

			// colors

			if ( m.colorDiffuse ) {

				mpars.color = rgb2hex( m.colorDiffuse );

			} else if ( m.DbgColor ) {

				mpars.color = m.DbgColor;

			}

			if ( m.colorSpecular ) {

				mpars.specular = rgb2hex( m.colorSpecular );

			}

			if ( m.colorAmbient ) {

				mpars.ambient = rgb2hex( m.colorAmbient );

			}

			if ( m.colorEmissive ) {

				mpars.emissive = rgb2hex( m.colorEmissive );

			}

			// modifiers

			if ( m.transparency ) {

				mpars.opacity = m.transparency;

			}

			if ( m.specularCoef ) {

				mpars.shininess = m.specularCoef;

			}

			// textures

			if ( m.mapDiffuse && texturePath ) {

				create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

			}

			if ( m.mapLight && texturePath ) {

				create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

			}

			if ( m.mapBump && texturePath ) {

				create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

			}

			if ( m.mapNormal && texturePath ) {

				create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

			}

			if ( m.mapSpecular && texturePath ) {

				create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

			}

			if ( m.mapAlpha && texturePath ) {

				create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

			}

			//

			if ( m.mapBumpScale ) {

				mpars.bumpScale = m.mapBumpScale;

			}

			// special case for normal mapped material

			if ( m.mapNormal ) {

				var shader = THREE.ShaderLib[ 'normalmap' ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

				uniforms[ 'tNormal' ].value = mpars.normalMap;

				if ( m.mapNormalFactor ) {

					uniforms[ 'uNormalScale' ].value.set( m.mapNormalFactor, m.mapNormalFactor );

				}

				if ( mpars.map ) {

					uniforms[ 'tDiffuse' ].value = mpars.map;
					uniforms[ 'enableDiffuse' ].value = true;

				}

				if ( mpars.specularMap ) {

					uniforms[ 'tSpecular' ].value = mpars.specularMap;
					uniforms[ 'enableSpecular' ].value = true;

				}

				if ( mpars.lightMap ) {

					uniforms[ 'tAO' ].value = mpars.lightMap;
					uniforms[ 'enableAO' ].value = true;

				}

				// for the moment don't handle displacement texture

				uniforms[ 'diffuse' ].value.setHex( mpars.color );
				uniforms[ 'specular' ].value.setHex( mpars.specular );
				uniforms[ 'ambient' ].value.setHex( mpars.ambient );

				uniforms[ 'shininess' ].value = mpars.shininess;

				if ( mpars.opacity !== undefined ) {

					uniforms[ 'opacity' ].value = mpars.opacity;

				}

				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
				var material = new THREE.ShaderMaterial( parameters );

				if ( mpars.transparent ) {

					material.transparent = true;

				}

			} else {

				var material = new THREE[ mtype ]( mpars );

			}

			if ( m.DbgName !== undefined ) material.name = m.DbgName;

			return material;

		}

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

				var regex = this.handlers[ i ];
				var loader  = this.handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function ( manager ) {

		this.cache = new THREE.Cache();
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.XHRLoader.prototype = {

		constructor: THREE.XHRLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = scope.cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) onLoad( cached );
				return;

			}

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				scope.cache.add( url, this.response );

				if ( onLoad ) onLoad( this.response );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			if ( onError !== undefined ) {

				request.addEventListener( 'error', function ( event ) {

					onError( event );

				}, false );

			}

			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;

			request.send( null );

			scope.manager.itemStart( url );

		},

		setResponseType: function ( value ) {

			this.responseType = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function ( manager ) {

		this.cache = new THREE.Cache();
		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ImageLoader.prototype = {

		constructor: THREE.ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = scope.cache.get( url );

			if ( cached !== undefined ) {

				onLoad( cached );
				return;

			}

			var image = document.createElement( 'img' );

			if ( onLoad !== undefined ) {

				image.addEventListener( 'load', function ( event ) {

					scope.cache.add( url, this );

					onLoad( this );
					scope.manager.itemEnd( url );

				}, false );

			}

			if ( onProgress !== undefined ) {

				image.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			if ( onError !== undefined ) {

				image.addEventListener( 'error', function ( event ) {

					onError( event );

				}, false );

			}

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			image.src = url;

			scope.manager.itemStart( url );

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	}

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function ( showStatus ) {

		THREE.Loader.call( this, showStatus );

		this.withCredentials = false;

	};

	THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

	THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

		var scope = this;

		// todo: unify load API to for easier SceneLoader use

		texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

		this.onLoadStart();
		this.loadAjaxJSON( this, url, callback, texturePath );

	};

	THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

		var xhr = new XMLHttpRequest();

		var length = 0;

		xhr.onreadystatechange = function () {

			if ( xhr.readyState === xhr.DONE ) {

				if ( xhr.status === 200 || xhr.status === 0 ) {

					if ( xhr.responseText ) {

						var json = JSON.parse( xhr.responseText );

						if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {

							console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
							return;

						}

						var result = context.parse( json, texturePath );
						callback( result.geometry, result.materials );

					} else {

						console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

					}

					// in context of more complex asset initialization
					// do not block on single failed file
					// maybe should go even one more level up

					context.onLoadComplete();

				} else {

					console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

				}

			} else if ( xhr.readyState === xhr.LOADING ) {

				if ( callbackProgress ) {

					if ( length === 0 ) {

						length = xhr.getResponseHeader( 'Content-Length' );

					}

					callbackProgress( { total: length, loaded: xhr.responseText.length } );

				}

			} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

				if ( callbackProgress !== undefined ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

			}

		};

		xhr.open( 'GET', url, true );
		xhr.withCredentials = this.withCredentials;
		xhr.send( null );

	};

	THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

		var scope = this,
		geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, color, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = []

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {
			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i     ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i     ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}


			// could change this to json.animations[0] or remove completely

			geometry.animation = json.animation;
			geometry.animations = json.animations;

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				var i, l, v, vl, dstVertices, srcVertices;

				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					dstVertices = geometry.morphTargets[ i ].vertices;
					srcVertices = json.morphTargets [ i ].vertices;

					for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined ) {

				var i, l, c, cl, dstColors, srcColors, color;

				for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

					geometry.morphColors[ i ] = {};
					geometry.morphColors[ i ].name = json.morphColors[ i ].name;
					geometry.morphColors[ i ].colors = [];

					dstColors = geometry.morphColors[ i ].colors;
					srcColors = json.morphColors [ i ].colors;

					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

						color = new THREE.Color( 0xffaa00 );
						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
						dstColors.push( color );

					}

				}

			}

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = this.initMaterials( json.materials, texturePath );

			if ( this.needsTangents( materials ) ) {

				geometry.computeTangents();

			}

			return { geometry: geometry, materials: materials };

		}

	};

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

		var scope = this;

		var loaded = 0, total = 0;

		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			total ++;

		};

		this.itemEnd = function ( url ) {

			loaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, loaded, total );

			}

			if ( loaded === total && scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.BufferGeometryLoader.prototype = {

		constructor: THREE.BufferGeometryLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader();
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometry = new THREE.BufferGeometry();

			var attributes = json.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

			}

			var offsets = json.offsets;

			if ( offsets !== undefined ) {

				geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

			}

			var boundingSphere = json.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new THREE.Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	};

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.MaterialLoader.prototype = {

		constructor: THREE.MaterialLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader();
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var material = new THREE[ json.type ];

			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;		
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

			if ( json.materials !== undefined ) {

				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

					material.materials.push( this.parse( json.materials[ i ] ) );

				}

			}

			return material;

		}

	};

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ObjectLoader.prototype = {

		constructor: THREE.ObjectLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometries = this.parseGeometries( json.geometries );
			var materials = this.parseMaterials( json.materials );
			var object = this.parseObject( json.object, geometries, materials );

			return object;

		},

		parseGeometries: function ( json ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':

							geometry = new THREE.PlaneGeometry(
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':

							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments
							);

							break;

						case 'CylinderGeometry':

							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded
							);

							break;

						case 'SphereGeometry':

							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'IcosahedronGeometry':

							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'TorusGeometry':

							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':

							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data.data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data.data ).geometry;

							break;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new THREE.MaterialLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];
					var material = loader.parse( data );

					material.uuid = data.uuid;

					if ( data.name !== undefined ) material.name = data.name;

					materials[ data.uuid ] = material;

				}

			}

			return materials;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function ( data, geometries, materials ) {

				var object;

				switch ( data.type ) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight( data.color );

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new THREE.PointLight( data.color, data.intensity, data.distance );

						break;

					case 'SpotLight':

						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'Mesh':

						var geometry = geometries[ data.geometry ];
						var material = materials[ data.material ];

						if ( geometry === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

						}

						if ( material === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

						}

						object = new THREE.Mesh( geometry, material );

						break;

					case 'Line':

						var geometry = geometries[ data.geometry ];
						var material = materials[ data.material ];

						if ( geometry === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

						}

						if ( material === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

						}

						object = new THREE.Line( geometry, material );

						break;

					case 'Sprite':

						var material = materials[ data.material ];

						if ( material === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

						}

						object = new THREE.Sprite( material );

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					for ( var child in data.children ) {

						object.add( this.parseObject( data.children[ child ], geometries, materials ) );

					}

				}

				return object;

			}

		}()

	};

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.TextureLoader.prototype = {

		constructor: THREE.TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {

				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function () {

		// override in sub classes
		this._parser = null;

	};


	THREE.CompressedTextureLoader.prototype = {

		constructor: THREE.CompressedTextureLoader,

		load: function ( url, onLoad, onError ) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );

			if ( url instanceof Array ) {

				var loaded = 0;

				var loadTexture = function ( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

	 						if (texDatas.mipmapCount == 1)
	 							texture.minFilter = THREE.LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					} );

				};

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps : [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				} );

			}

			return texture;

		}

	};

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.side = THREE.FrontSide;

		this.opacity = 1;
		this.transparent = false;

		this.blending = THREE.NormalBlending;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;

		this.depthTest = true;
		this.depthWrite = true;

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this.needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				if ( key in this ) {

					var currentValue = this[ key ];

					if ( currentValue instanceof THREE.Color ) {

						currentValue.set( newValue );

					} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

						currentValue.copy( newValue );

					} else if ( key == 'overdraw' ) {

						// ensure overdraw is backwards-compatable with legacy boolean type
						this[ key ] = Number( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			}

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type
			};

			if ( this.name !== "" ) output.name = this.name;

			if ( this instanceof THREE.MeshBasicMaterial ) {

				output.color = this.color.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshLambertMaterial ) {

				output.color = this.color.getHex();
				output.ambient = this.ambient.getHex();
				output.emissive = this.emissive.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshPhongMaterial ) {

				output.color = this.color.getHex();
				output.ambient = this.ambient.getHex();
				output.emissive = this.emissive.getHex();
				output.specular = this.specular.getHex();
				output.shininess = this.shininess;
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshNormalMaterial ) {

				if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshDepthMaterial ) {

				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.ShaderMaterial ) {

				output.uniforms = this.uniforms;
				output.vertexShader = this.vertexShader;
				output.fragmentShader = this.fragmentShader;

			} else if ( this instanceof THREE.SpriteMaterial ) {

				output.color = this.color.getHex();

			}

			if ( this.opacity < 1 ) output.opacity = this.opacity;
			if ( this.transparent !== false ) output.transparent = this.transparent;
			if ( this.wireframe !== false ) output.wireframe = this.wireframe;

			return output;

		},

		clone: function ( material ) {

			if ( material === undefined ) material = new THREE.Material();

			material.name = this.name;

			material.side = this.side;

			material.opacity = this.opacity;
			material.transparent = this.transparent;

			material.blending = this.blending;

			material.blendSrc = this.blendSrc;
			material.blendDst = this.blendDst;
			material.blendEquation = this.blendEquation;

			material.depthTest = this.depthTest;
			material.depthWrite = this.depthWrite;

			material.polygonOffset = this.polygonOffset;
			material.polygonOffsetFactor = this.polygonOffsetFactor;
			material.polygonOffsetUnits = this.polygonOffsetUnits;

			material.alphaTest = this.alphaTest;

			material.overdraw = this.overdraw;

			material.visible = this.visible;

			return material;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.LineBasicMaterial.prototype.clone = function () {

		var material = new THREE.LineBasicMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.linewidth = this.linewidth;
		material.linecap = this.linecap;
		material.linejoin = this.linejoin;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineDashedMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.vertexColors = false;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.LineDashedMaterial.prototype.clone = function () {

		var material = new THREE.LineDashedMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.linewidth = this.linewidth;

		material.scale = this.scale;
		material.dashSize = this.dashSize;
		material.gapSize = this.gapSize;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.MeshBasicMaterial.prototype.clone = function () {

		var material = new THREE.MeshBasicMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;

		return material;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  ambient: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.ambient = new THREE.Color( 0xffffff );
		this.emissive = new THREE.Color( 0x000000 );

		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

		this.map = null;

		this.lightMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.MeshLambertMaterial.prototype.clone = function () {

		var material = new THREE.MeshLambertMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.ambient.copy( this.ambient );
		material.emissive.copy( this.emissive );

		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  ambient: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.ambient = new THREE.Color( 0xffffff );
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.metal = false;

		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

		this.map = null;

		this.lightMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.MeshPhongMaterial.prototype.clone = function () {

		var material = new THREE.MeshPhongMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.ambient.copy( this.ambient );
		material.emissive.copy( this.emissive );
		material.specular.copy( this.specular );
		material.shininess = this.shininess;

		material.metal = this.metal;

		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.bumpMap = this.bumpMap;
		material.bumpScale = this.bumpScale;

		material.normalMap = this.normalMap;
		material.normalScale.copy( this.normalScale );

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	};

	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.MeshDepthMaterial.prototype.clone = function () {

		var material = new THREE.MeshDepthMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		return material;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function ( parameters ) {

		THREE.Material.call( this, parameters );

		this.type = 'MeshNormalMaterial';

		this.shading = THREE.FlatShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.MeshNormalMaterial.prototype.clone = function () {

		var material = new THREE.MeshNormalMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		return material;

	};

	// File:src/materials/MeshFaceMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MeshFaceMaterial = function ( materials ) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MeshFaceMaterial';
		
		this.materials = materials instanceof Array ? materials : [];

	};

	THREE.MeshFaceMaterial.prototype = {

		constructor: THREE.MeshFaceMaterial,

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

				output.materials.push( this.materials[ i ].toJSON() );

			}

			return output;

		},

		clone: function () {

			var material = new THREE.MeshFaceMaterial();

			for ( var i = 0; i < this.materials.length; i ++ ) {

				material.materials.push( this.materials[ i ].clone() );

			}

			return material;

		}

	};

	// File:src/materials/PointCloudMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.PointCloudMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'PointCloudMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.PointCloudMaterial.prototype.clone = function () {

		var material = new THREE.PointCloudMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.map = this.map;

		material.size = this.size;
		material.sizeAttenuation = this.sizeAttenuation;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// backwards compatibility

	THREE.ParticleBasicMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );

	};

	THREE.ParticleSystemMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.attributes = null;

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.shading = THREE.SmoothShading;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		this.setValues( parameters );

	};

	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.ShaderMaterial.prototype.clone = function () {

		var material = new THREE.ShaderMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.fragmentShader = this.fragmentShader;
		material.vertexShader = this.vertexShader;

		material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

		material.attributes = this.attributes;
		material.defines = this.defines;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		material.fog = this.fog;

		material.lights = this.lights;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;

		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function ( parameters ) {

		THREE.ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

	THREE.RawShaderMaterial.prototype.clone = function () {

		var material = new THREE.RawShaderMaterial();

		THREE.ShaderMaterial.prototype.clone.call( this, material );

		return material;

	};

	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.SpriteMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;

		// set parameters

		this.setValues( parameters );

	};

	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

	THREE.SpriteMaterial.prototype.clone = function () {

		var material = new THREE.SpriteMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.map = this.map;

		material.rotation = this.rotation;

		material.fog = this.fog;

		return material;

	};

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this._needsUpdate = false;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping();

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		clone: function ( texture ) {

			if ( texture === undefined ) texture = new THREE.Texture();

			texture.image = this.image;
			texture.mipmaps = this.mipmaps.slice( 0 );

			texture.mapping = this.mapping;

			texture.wrapS = this.wrapS;
			texture.wrapT = this.wrapT;

			texture.magFilter = this.magFilter;
			texture.minFilter = this.minFilter;

			texture.anisotropy = this.anisotropy;

			texture.format = this.format;
			texture.type = this.type;

			texture.offset.copy( this.offset );
			texture.repeat.copy( this.repeat );

			texture.generateMipmaps = this.generateMipmaps;
			texture.premultiplyAlpha = this.premultiplyAlpha;
			texture.flipY = this.flipY;
			texture.unpackAlignment = this.unpackAlignment;

			return texture;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

	THREE.TextureIdCount = 0;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.images = images;

	};

	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );

	THREE.CubeTexture.clone = function ( texture ) {

		if ( texture === undefined ) texture = new THREE.CubeTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		texture.images = this.images;

		return texture;

	};

	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

	THREE.CompressedTexture.prototype.clone = function () {

		var texture = new THREE.CompressedTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		return texture;

	};

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { data: data, width: width, height: height };

	};

	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

	THREE.DataTexture.prototype.clone = function () {

		var texture = new THREE.DataTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		return texture;

	};

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		var scope = this;

		var update = function () {

			requestAnimationFrame( update );

			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

				scope.needsUpdate = true;

			}

		};

		update();

	};

	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call( this );

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );

	// File:src/objects/PointCloud.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.PointCloud = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'PointCloud';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

		this.sortParticles = false;

	};

	THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );

	THREE.PointCloud.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();

		return function ( raycaster, intersects ) {

			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.PointCloud.threshold;

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var position = new THREE.Vector3();

			var testPoint = function ( point, index ) {

				var rayPointDistance = ray.distanceToPoint( point );

				if ( rayPointDistance < localThreshold ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					intersects.push( {

						distance: distance,
						distanceToRay: rayPointDistance,
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			};

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						var offset = {
							start: 0,
							count: indices.length,
							index: 0
						};

						offsets = [ offset ];

					}

					for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i ++ ) {

							var a = index + indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					}

				} else {

					var pointCount = positions.length / 3;

					for ( var i = 0; i < pointCount; i ++ ) {

						position.set(
							positions[ 3 * i ],
							positions[ 3 * i + 1 ],
							positions[ 3 * i + 2 ]
						);

						testPoint( position, i );

					}

				}

			} else {

				var vertices = this.geometry.vertices;

				for ( var i = 0; i < vertices.length; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() );

	THREE.PointCloud.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

		object.sortParticles = this.sortParticles;

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// Backwards compatibility

	THREE.ParticleSystem = function ( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
		return new THREE.PointCloud( geometry, material );

	};

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function ( geometry, material, mode ) {

		THREE.Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

		this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;

	};

	THREE.LineStrip = 0;
	THREE.LinePieces = 1;

	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Line.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function ( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			/* if ( geometry instanceof THREE.BufferGeometry ) {

			} else */ if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = this.mode === THREE.LineStrip ? 1 : 2;

				for ( var i = 0; i < nbVertices - 1; i = i + step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Line.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Mesh';
		
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Mesh.prototype.updateMorphTargets = function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	};

	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	};


	THREE.Mesh.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			var geometry = this.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {

					return;

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = this.material;

				if ( material === undefined ) return;

				var attributes = geometry.attributes;

				var a, b, c;
				var precision = raycaster.precision;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						offsets = [ { start: 0, count: indices.length, index: 0 } ];

					}

					for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ];
							c = index + indices[ i + 2 ];

							vA.fromArray( positions, a * 3 );
							vB.fromArray( positions, b * 3 );
							vC.fromArray( positions, c * 3 );

							if ( material.side === THREE.BackSide ) {

								var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

							} else {

								var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( this.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
								faceIndex: null,
								object: this

							} );

						}

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.fromArray( positions, j );
						vB.fromArray( positions, j + 3 );
						vC.fromArray( positions, j + 6 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

				var a, b, c, d;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;

							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;

							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( c, b, a, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Mesh.prototype.clone = function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

		THREE.Object3D.prototype.clone.call( this, object, recursive );

		return object;

	};

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function ( belongsToSkin ) {

		THREE.Object3D.call( this );

		this.skin = belongsToSkin;

	};

	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );


	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );

		// create a bone texture or an array of floats

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//       16x16 pixel texture max   64 bones (16 * 16 / 4)
			//       32x32 pixel texture max  256 bones (32 * 32 / 4)
			//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( this.bones.length > 256 )
				size = 64;
			else if ( this.bones.length > 64 )
				size = 32;
			else if ( this.bones.length > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * this.bones.length );

		}

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					this.boneInverses.push( new THREE.Matrix4() );

				}

			}

		}

	};

	THREE.Skeleton.prototype.calculateInverses = function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	};

	THREE.Skeleton.prototype.pose = function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	};

	THREE.Skeleton.prototype.update = ( function () {

		var offsetMatrix = new THREE.Matrix4();
		
		return function () {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}
			
		};

	} )();


	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if ( this.geometry && this.geometry.bones !== undefined ) {

			var bone, gbone, p, q, s;

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

				gbone = this.geometry.bones[ b ];

				p = gbone.pos;
				q = gbone.rotq;
				s = gbone.scl;

				bone = new THREE.Bone( this );
				bones.push( bone );

				bone.name = gbone.name;
				bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
				bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

				if ( s !== undefined ) {

					bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

				} else {

					bone.scale.set( 1, 1, 1 );

				}

			}

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

				gbone = this.geometry.bones[ b ];

				if ( gbone.parent !== - 1 ) {

					bones[ gbone.parent ].add( bones[ b ] );

				} else {

					this.add( bones[ b ] );

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

	};


	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	};

	THREE.SkinnedMesh.prototype.pose = function () {

		this.skeleton.pose();

	};

	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1 ); // this will be normalized by the shader anyway

				}

			}

		} else {

			// skinning weights assumed to be normalized for THREE.BufferGeometry

		}

	};

	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

		}

	};

	THREE.SkinnedMesh.prototype.clone = function( object ) {

		if ( object === undefined ) {

			object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

		}

		THREE.Mesh.prototype.clone.call( this, object );

		return object;

	};


	// File:src/objects/MorphAnimMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphAnimMesh = function ( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'MorphAnimMesh';

		// API

		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;

		// internals

		this.lastKeyframe = 0;
		this.currentKeyframe = 0;

		this.direction = 1;
		this.directionBackwards = false;

		this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

	};

	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

		this.startKeyframe = start;
		this.endKeyframe = end;

		this.length = this.endKeyframe - this.startKeyframe + 1;

	};

	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

		this.direction = 1;
		this.directionBackwards = false;

	};

	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

		this.direction = - 1;
		this.directionBackwards = true;

	};

	THREE.MorphAnimMesh.prototype.parseAnimations = function () {

		var geometry = this.geometry;

		if ( ! geometry.animations ) geometry.animations = {};

		var firstAnimation, animations = geometry.animations;

		var pattern = /([a-z]+)_?(\d+)/;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var label = parts[ 1 ];
				var num = parts[ 2 ];

				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

				var animation = animations[ label ];

				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;

				if ( ! firstAnimation ) firstAnimation = label;

			}

		}

		geometry.firstAnimation = firstAnimation;

	};

	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

		if ( ! this.geometry.animations ) this.geometry.animations = {};

		this.geometry.animations[ label ] = { start: start, end: end };

	};

	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

		var animation = this.geometry.animations[ label ];

		if ( animation ) {

			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;

		} else {

			console.warn( 'animation[' + label + '] undefined' );

		}

	};

	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

		var frameTime = this.duration / this.length;

		this.time += this.direction * delta;

		if ( this.mirroredLoop ) {

			if ( this.time > this.duration || this.time < 0 ) {

				this.direction *= - 1;

				if ( this.time > this.duration ) {

					this.time = this.duration;
					this.directionBackwards = true;

				}

				if ( this.time < 0 ) {

					this.time = 0;
					this.directionBackwards = false;

				}

			}

		} else {

			this.time = this.time % this.duration;

			if ( this.time < 0 ) this.time += this.duration;

		}

		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

		if ( keyframe !== this.currentKeyframe ) {

			this.morphTargetInfluences[ this.lastKeyframe ] = 0;
			this.morphTargetInfluences[ this.currentKeyframe ] = 1;

			this.morphTargetInfluences[ keyframe ] = 0;

			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;

		}

		var mix = ( this.time % frameTime ) / frameTime;

		if ( this.directionBackwards ) {

			mix = 1 - mix;

		}

		this.morphTargetInfluences[ this.currentKeyframe ] = mix;
		this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

	};

	THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

		var influences = this.morphTargetInfluences;

		for ( var i = 0, l = influences.length; i < l; i ++ ) {

			influences[ i ] = 0;

		}

		if ( a > -1 ) influences[ a ] = 1 - t;
		if ( b > -1 ) influences[ b ] = t;

	};

	THREE.MorphAnimMesh.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

		object.duration = this.duration;
		object.mirroredLoop = this.mirroredLoop;
		object.time = this.time;

		object.lastKeyframe = this.lastKeyframe;
		object.currentKeyframe = this.currentKeyframe;

		object.direction = this.direction;
		object.directionBackwards = this.directionBackwards;

		THREE.Mesh.prototype.clone.call( this, object );

		return object;

	};

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call( this );

		this.objects = [];

	};


	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

	THREE.LOD.prototype.addLevel = function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		for ( var l = 0; l < this.objects.length; l ++ ) {

			if ( distance < this.objects[ l ].distance ) {

				break;

			}

		}

		this.objects.splice( l, 0, { distance: distance, object: object } );
		this.add( object );

	};

	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

		for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

			if ( distance < this.objects[ i ].distance ) {

				break;

			}

		}

		return this.objects[ i - 1 ].object;

	};

	THREE.LOD.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() );

	THREE.LOD.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( camera ) {

			if ( this.objects.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				this.objects[ 0 ].object.visible = true;

				for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

					if ( distance >= this.objects[ i ].distance ) {

						this.objects[ i - 1 ].object.visible = false;
						this.objects[ i     ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					this.objects[ i ].object.visible = false;

				}

			}

		};

	}();

	THREE.LOD.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.LOD();

		THREE.Object3D.prototype.clone.call( this, object );

		for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
			var x = this.objects[ i ].object.clone();
			x.visible = i === 0;
			object.addLevel( x, this.objects[ i ].distance );
		}

		return object;

	};

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = ( function () {

		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return function ( material ) {

			THREE.Object3D.call( this );

			this.type = 'Sprite';

			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

		};

	} )();

	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Sprite.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > this.scale.x ) {

				return;

			}

			intersects.push( {

				distance: distance,
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() );

	THREE.Sprite.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Sprite( this.material );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// Backwards compatibility

	THREE.Particle = THREE.Sprite;

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function ( texture, size, distance, blending, color ) {

		THREE.Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	};

	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


	/*
	 * Add: adds another flare
	 */

	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture, 			// THREE.Texture
			size: size, 				// size in pixels (-1 = use texture.width)
			distance: distance, 		// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
			scale: 1, 					// scale
			rotation: 1, 				// rotation
			opacity: opacity,			// opacity
			color: color,				// color
			blending: blending			// blending
		} );

	};

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	THREE.LensFlare.prototype.updateLensFlares = function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	};


	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call( this );

		this.type = 'Scene';

		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Scene.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Scene();

		THREE.Object3D.prototype.clone.call( this, object );

		if ( this.fog !== null ) object.fog = this.fog.clone();
		if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

		object.autoUpdate = this.autoUpdate;
		object.matrixAutoUpdate = this.matrixAutoUpdate;

		return object;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function ( color, near, far ) {

		this.name = '';

		this.color = new THREE.Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog( this.color.getHex(), this.near, this.far );

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function ( color, density ) {

		this.name = '';

		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2( this.color.getHex(), this.density );

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

	THREE.ShaderChunk[ 'default_vertex'] = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

	THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

	THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

	THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( parameter_src instanceof Array ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },

			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"lightMap" : { type: "t", value: null },
			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },

			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"useRefract" : { type: "i", value: 0 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 },
			"combine" : { type: "i", value: 0 },

			"morphTargetInfluences" : { type: "f", value: 0 }

		},

		bump: {

			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }

		},

		normalmap: {

			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
		},

		fog : {

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		lights: {

			"ambientLightColor" : { type: "fv", value: [] },

			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },

			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },

			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },

			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] }

		},

		particle: {

			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		shadowmap: {

			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },

			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },

			"shadowMatrix" : { type: "m4v", value: [] }

		}

	};

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],

				"	#ifdef USE_ENVMAP",

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	#endif",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n")

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}

			] ),

			vertexShader: [

				"#define LAMBERT",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float opacity;",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	#ifdef DOUBLE_SIDED",

						//"float isFront = float( gl_FrontFacing );",
						//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

				"		if ( gl_FrontFacing )",
				"			gl_FragColor.xyz *= vLightFront;",
				"		else",
				"			gl_FragColor.xyz *= vLightBack;",

				"	#else",

				"		gl_FragColor.xyz *= vLightFront;",

				"	#endif",

					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n")

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "bump" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}

			] ),

			vertexShader: [

				"#define PHONG",

				"varying vec3 vViewPosition;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	vNormal = normalize( transformedNormal );",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"	vViewPosition = -mvPosition.xyz;",

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"#define PHONG",

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform vec3 ambient;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",

				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

					THREE.ShaderChunk[ "lights_phong_fragment" ],

					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n")

		},

		'particle_basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "particle" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				"uniform float size;",
				"uniform float scale;",

				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 psColor;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( psColor, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n")

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],

				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}

			] ),

			vertexShader: [

				"uniform float scale;",
				"attribute float lineDistance;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vLineDistance = scale * lineDistance;",

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform float dashSize;",
				"uniform float totalSize;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

				"		discard;",

				"	}",

				"	gl_FragColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n")

		},

		'depth': {

			uniforms: {

				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

				"	#else",

				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

				"	#endif",

				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",

				"}"

			].join("\n")

		},

		'normal': {

			uniforms: {

				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vNormal = normalize( normalMatrix * normal );",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float opacity;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Normal map shader
		//		- Blinn-Phong
		//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
		//		- point and directional lights (use with "lights: true" material option)
		 ------------------------------------------------------------------------- */

		'normalmap' : {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{

				"enableAO"          : { type: "i", value: 0 },
				"enableDiffuse"     : { type: "i", value: 0 },
				"enableSpecular"    : { type: "i", value: 0 },
				"enableReflection"  : { type: "i", value: 0 },
				"enableDisplacement": { type: "i", value: 0 },

				"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
				"tDiffuse"     : { type: "t", value: null },
				"tCube"        : { type: "t", value: null },
				"tNormal"      : { type: "t", value: null },
				"tSpecular"    : { type: "t", value: null },
				"tAO"          : { type: "t", value: null },

				"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

				"uDisplacementBias": { type: "f", value: 0.0 },
				"uDisplacementScale": { type: "f", value: 1.0 },

				"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
				"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
				"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
				"shininess": { type: "f", value: 30 },
				"opacity": { type: "f", value: 1 },

				"useRefract": { type: "i", value: 0 },
				"refractionRatio": { type: "f", value: 0.98 },
				"reflectivity": { type: "f", value: 0.5 },

				"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
				"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

				"wrapRGB" : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

				}

			] ),

			fragmentShader: [

				"uniform vec3 ambient;",
				"uniform vec3 diffuse;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",

				"uniform bool enableDiffuse;",
				"uniform bool enableSpecular;",
				"uniform bool enableAO;",
				"uniform bool enableReflection;",

				"uniform sampler2D tDiffuse;",
				"uniform sampler2D tNormal;",
				"uniform sampler2D tSpecular;",
				"uniform sampler2D tAO;",

				"uniform samplerCube tCube;",

				"uniform vec2 uNormalScale;",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",
				"uniform float reflectivity;",

				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",

				"uniform vec3 ambientLightColor;",

				"#if MAX_DIR_LIGHTS > 0",

				"	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

				"#endif",

				"#if MAX_HEMI_LIGHTS > 0",

				"	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

				"#endif",

				"#if MAX_POINT_LIGHTS > 0",

				"	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

				"#endif",

				"#if MAX_SPOT_LIGHTS > 0",

				"	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
				"	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

				"#endif",

				"#ifdef WRAP_AROUND",

				"	uniform vec3 wrapRGB;",

				"#endif",

				"varying vec3 vWorldPosition;",
				"varying vec3 vViewPosition;",

				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",
					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				"	vec3 specularTex = vec3( 1.0 );",

				"	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
				"	normalTex.xy *= uNormalScale;",
				"	normalTex = normalize( normalTex );",

				"	if( enableDiffuse ) {",

				"		#ifdef GAMMA_INPUT",

				"			vec4 texelColor = texture2D( tDiffuse, vUv );",
				"			texelColor.xyz *= texelColor.xyz;",

				"			gl_FragColor = gl_FragColor * texelColor;",

				"		#else",

				"			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

				"		#endif",

				"	}",

				"	if( enableAO ) {",

				"		#ifdef GAMMA_INPUT",

				"			vec4 aoColor = texture2D( tAO, vUv );",
				"			aoColor.xyz *= aoColor.xyz;",

				"			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

				"		#else",

				"			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

				"		#endif",

				"	}",
				
				THREE.ShaderChunk[ "alphatest_fragment" ],

				"	if( enableSpecular )",
				"		specularTex = texture2D( tSpecular, vUv ).xyz;",

				"	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
				"	vec3 finalNormal = tsb * normalTex;",

				"	#ifdef FLIP_SIDED",

				"		finalNormal = -finalNormal;",

				"	#endif",

				"	vec3 normal = normalize( finalNormal );",
				"	vec3 viewPosition = normalize( vViewPosition );",

					// point lights

				"	#if MAX_POINT_LIGHTS > 0",

				"		vec3 pointDiffuse = vec3( 0.0 );",
				"		vec3 pointSpecular = vec3( 0.0 );",

				"		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

				"			float pointDistance = 1.0;",
				"			if ( pointLightDistance[ i ] > 0.0 )",
				"				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

				"			pointVector = normalize( pointVector );",

							// diffuse

				"			#ifdef WRAP_AROUND",

				"				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
				"				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

				"				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

				"			#else",

				"				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

				"			#endif",

				"			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

							// specular

				"			vec3 pointHalfVector = normalize( pointVector + viewPosition );",
				"			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

				"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );",
				"			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

				"		}",

				"	#endif",

					// spot lights

				"	#if MAX_SPOT_LIGHTS > 0",

				"		vec3 spotDiffuse = vec3( 0.0 );",
				"		vec3 spotSpecular = vec3( 0.0 );",

				"		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

				"			float spotDistance = 1.0;",
				"			if ( spotLightDistance[ i ] > 0.0 )",
				"				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

				"			spotVector = normalize( spotVector );",

				"			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"			if ( spotEffect > spotLightAngleCos[ i ] ) {",

				"				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );",

								// diffuse

				"				#ifdef WRAP_AROUND",

				"					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
				"					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

				"					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

				"				#else",

				"					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

				"				#endif",

				"				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

								// specular

				"				vec3 spotHalfVector = normalize( spotVector + viewPosition );",
				"				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
				"				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

				"				float specularNormalization = ( shininess + 2.0 ) / 8.0;",

				"				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );",
				"				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

				"			}",

				"		}",

				"	#endif",

					// directional lights

				"	#if MAX_DIR_LIGHTS > 0",

				"		vec3 dirDiffuse = vec3( 0.0 );",
				"		vec3 dirSpecular = vec3( 0.0 );",

				"		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

				"			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"			vec3 dirVector = normalize( lDirection.xyz );",

							// diffuse

				"			#ifdef WRAP_AROUND",

				"				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
				"				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

				"				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

				"			#else",

				"				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

				"			#endif",

				"			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

							// specular

				"			vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

				"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

				"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
				"			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

				"		}",

				"	#endif",

					// hemisphere lights

				"	#if MAX_HEMI_LIGHTS > 0",

				"		vec3 hemiDiffuse = vec3( 0.0 );",
				"		vec3 hemiSpecular = vec3( 0.0 );" ,

				"		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"			vec3 lVector = normalize( lDirection.xyz );",

							// diffuse

				"			float dotProduct = dot( normal, lVector );",
				"			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"			hemiDiffuse += diffuse * hemiColor;",

							// specular (sky light)


				"			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );",

							// specular (ground light)

				"			vec3 lVectorGround = -lVector;",

				"			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );",

				"			float dotProductGround = dot( normal, lVectorGround );",

				"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

				"			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
				"			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
				"			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

				"		}",

				"	#endif",

					// all lights contribution summation

				"	vec3 totalDiffuse = vec3( 0.0 );",
				"	vec3 totalSpecular = vec3( 0.0 );",

				"	#if MAX_DIR_LIGHTS > 0",

				"		totalDiffuse += dirDiffuse;",
				"		totalSpecular += dirSpecular;",

				"	#endif",

				"	#if MAX_HEMI_LIGHTS > 0",

				"		totalDiffuse += hemiDiffuse;",
				"		totalSpecular += hemiSpecular;",

				"	#endif",

				"	#if MAX_POINT_LIGHTS > 0",

				"		totalDiffuse += pointDiffuse;",
				"		totalSpecular += pointSpecular;",

				"	#endif",

				"	#if MAX_SPOT_LIGHTS > 0",

				"		totalDiffuse += spotDiffuse;",
				"		totalSpecular += spotSpecular;",

				"	#endif",

				"	#ifdef METAL",

				"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

				"	#else",

				"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

				"	#endif",

				"	if ( enableReflection ) {",

				"		vec3 vReflect;",
				"		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

				"		if ( useRefract ) {",

				"			vReflect = refract( cameraToVertex, normal, refractionRatio );",

				"		} else {",

				"			vReflect = reflect( cameraToVertex, normal );",

				"		}",

				"		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

				"		#ifdef GAMMA_INPUT",

				"			cubeColor.xyz *= cubeColor.xyz;",

				"		#endif",

				"		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

				"	}",

					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"}"

			].join("\n"),

			vertexShader: [

				"attribute vec4 tangent;",

				"uniform vec2 uOffset;",
				"uniform vec2 uRepeat;",

				"uniform bool enableDisplacement;",

				"#ifdef VERTEX_TEXTURES",

				"	uniform sampler2D tDisplacement;",
				"	uniform float uDisplacementScale;",
				"	uniform float uDisplacementBias;",

				"#endif",

				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",

				"varying vec3 vWorldPosition;",
				"varying vec3 vViewPosition;",

				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],

					// normal, tangent and binormal vectors

				"	#ifdef USE_SKINNING",

				"		vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

				"		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
				"		vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

				"	#else",

				"		vNormal = normalize( normalMatrix * normal );",
				"		vTangent = normalize( normalMatrix * tangent.xyz );",

				"	#endif",

				"	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

				"	vUv = uv * uRepeat + uOffset;",

					// displacement mapping

				"	vec3 displacedPosition;",

				"	#ifdef VERTEX_TEXTURES",

				"		if ( enableDisplacement ) {",

				"			vec3 dv = texture2D( tDisplacement, uv ).xyz;",
				"			float df = uDisplacementScale * dv.x + uDisplacementBias;",
				"			displacedPosition = position + normalize( normal ) * df;",

				"		} else {",

				"			#ifdef USE_SKINNING",

				"				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

				"				vec4 skinned = vec4( 0.0 );",
				"				skinned += boneMatX * skinVertex * skinWeight.x;",
				"				skinned += boneMatY * skinVertex * skinWeight.y;",
				"				skinned += boneMatZ * skinVertex * skinWeight.z;",
				"				skinned += boneMatW * skinVertex * skinWeight.w;",
				"				skinned  = bindMatrixInverse * skinned;",

				"				displacedPosition = skinned.xyz;",

				"			#else",

				"				displacedPosition = position;",

				"			#endif",

				"		}",

				"	#else",

				"		#ifdef USE_SKINNING",

				"			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

				"			vec4 skinned = vec4( 0.0 );",
				"			skinned += boneMatX * skinVertex * skinWeight.x;",
				"			skinned += boneMatY * skinVertex * skinWeight.y;",
				"			skinned += boneMatZ * skinVertex * skinWeight.z;",
				"			skinned += boneMatW * skinVertex * skinWeight.w;",
				"			skinned  = bindMatrixInverse * skinned;",

				"			displacedPosition = skinned.xyz;",

				"		#else",

				"			displacedPosition = position;",

				"		#endif",

				"	#endif",

					//

				"	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
				"	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					//

				"	vWorldPosition = worldPosition.xyz;",
				"	vViewPosition = -mvPosition.xyz;",

					// shadows

				"	#ifdef USE_SHADOWMAP",

				"		for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

				"		}",

				"	#endif",

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"	vWorldPosition = worldPosition.xyz;",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */

		'depthRGBA': {

			uniforms: {},

			vertexShader: [

				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"vec4 pack_depth( const in float depth ) {",

				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",

				"}",

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

				"	#else",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				"	#endif",

					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

				"}"

			].join("\n")

		}

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.WebGLRenderer = function ( parameters ) {

		console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;

		var lights = [];

		var _webglObjects = {};
		var _webglObjectsImmediate = [];

		var opaqueObjects = [];
		var transparentObjects = [];

		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;
		this.devicePixelRatio = parameters.devicePixelRatio !== undefined
					 ? parameters.devicePixelRatio
					 : self.devicePixelRatio !== undefined
						 ? self.devicePixelRatio
						 : 1;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// physically based shading

		this.gammaInput = false;
		this.gammaOutput = false;

		// shadow map

		this.shadowMapEnabled = false;
		this.shadowMapType = THREE.PCFShadowMap;
		this.shadowMapCullFace = THREE.CullFaceFront;
		this.shadowMapDebug = false;
		this.shadowMapCascade = false;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// flags

		this.autoScaleCubemaps = true;

		// info

		this.info = {

			memory: {

				programs: 0,
				geometries: 0,
				textures: 0

			},

			render: {

				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			}

		};

		// internal properties

		var _this = this,

		_programs = [],

		// internal state cache

		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryGroupHash = - 1,
		_currentCamera = null,

		_usedTextureUnits = 0,

		// GL state cache

		_oldDoubleSided = - 1,
		_oldFlipSided = - 1,

		_oldBlending = - 1,

		_oldBlendEquation = - 1,
		_oldBlendSrc = - 1,
		_oldBlendDst = - 1,

		_oldDepthTest = - 1,
		_oldDepthWrite = - 1,

		_oldPolygonOffset = null,
		_oldPolygonOffsetFactor = null,
		_oldPolygonOffsetUnits = null,

		_oldLineWidth = null,

		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,

		_newAttributes = new Uint8Array( 16 ),
		_enabledAttributes = new Uint8Array( 16 ),

		// frustum

		_frustum = new THREE.Frustum(),

		 // camera matrices cache

		_projScreenMatrix = new THREE.Matrix4(),
		_projScreenMatrixPS = new THREE.Matrix4(),

		_vector3 = new THREE.Vector3(),

		// light arrays cache

		_direction = new THREE.Vector3(),

		_lightsNeedUpdate = true,

		_lights = {

			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors:[], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

		};

		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl') !== null ) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

		} catch ( error ) {

			console.error( error );

		}

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return {
					'rangeMin': 1,
					'rangeMax': 1,
					'precision': 1
				};

			}

		}

		var extensions = new THREE.WebGLExtensions( _gl );

		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_standard_derivatives' );

		if ( _logarithmicDepthBuffer ) {

			extensions.get( 'EXT_frag_depth' );

		}

		//

		function setDefaultGLState() {

			_gl.clearColor( 0, 0, 0, 1 );
			_gl.clearDepth( 1 );
			_gl.clearStencil( 0 );

			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthFunc( _gl.LEQUAL );

			_gl.frontFace( _gl.CCW );
			_gl.cullFace( _gl.BACK );
			_gl.enable( _gl.CULL_FACE );

			_gl.enable( _gl.BLEND );
			_gl.blendEquation( _gl.FUNC_ADD );
			_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		}

		setDefaultGLState();

		this.context = _gl;

		// GPU capabilities

		var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
		var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
		var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var _supportsVertexTextures = _maxVertexTextures > 0;
		var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

		//

		var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
		var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
		var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

		var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
		var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
		var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

		var getCompressedTextureFormats = ( function () {

			var array;

			return function () {

				if ( array !== undefined ) {

					return array;

				}

				array = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

					var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ){

						array.push( formats[ i ] );

					}

				}
				
				return array;

			};

		} )();

		// clamp precision to maximum available

		var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
		var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

		if ( _precision === 'highp' && ! highpAvailable ) {

			if ( mediumpAvailable ) {

				_precision = 'mediump';
				console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

			} else {

				_precision = 'lowp';
				console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

			}

		}

		if ( _precision === 'mediump' && ! mediumpAvailable ) {

			_precision = 'lowp';
			console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

		}

		// Plugins

		var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

		// API

		this.getContext = function () {

			return _gl;

		};

		this.supportsVertexTextures = function () {

			return _supportsVertexTextures;

		};

		this.supportsFloatTextures = function () {

			return extensions.get( 'OES_texture_float' );

		};

		this.supportsStandardDerivatives = function () {

			return extensions.get( 'OES_standard_derivatives' );

		};

		this.supportsCompressedTextureS3TC = function () {

			return extensions.get( 'WEBGL_compressed_texture_s3tc' );

		};

		this.supportsCompressedTexturePVRTC = function () {

			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		};

		this.supportsBlendMinMax = function () {

			return extensions.get( 'EXT_blend_minmax' );

		};

		this.getMaxAnisotropy = ( function () {

			var value;

			return function () {

				if ( value !== undefined ) {

					return value;

				}

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

				return value;

			}

		} )();

		this.getPrecision = function () {

			return _precision;

		};

		this.setSize = function ( width, height, updateStyle ) {

			_canvas.width = width * this.devicePixelRatio;
			_canvas.height = height * this.devicePixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewportX = x * this.devicePixelRatio;
			_viewportY = y * this.devicePixelRatio;

			_viewportWidth = width * this.devicePixelRatio;
			_viewportHeight = height * this.devicePixelRatio;

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		};

		this.setScissor = function ( x, y, width, height ) {

			_gl.scissor(
				x * this.devicePixelRatio,
				y * this.devicePixelRatio,
				width * this.devicePixelRatio,
				height * this.devicePixelRatio
			);

		};

		this.enableScissorTest = function ( enable ) {

			enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

		};

		// Clearing

		this.setClearColor = function ( color, alpha ) {

			_clearColor.set( color );
			_clearAlpha = alpha !== undefined ? alpha : 1;

			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.setClearColorHex = function ( hex, alpha ) {

			console.warn( 'THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
			this.setClearColor( hex, alpha );

		};

		this.getClearColor = function () {

			return _clearColor;

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			_gl.clear( _gl.COLOR_BUFFER_BIT );

		};

		this.clearDepth = function () {

			_gl.clear( _gl.DEPTH_BUFFER_BIT );

		};

		this.clearStencil = function () {

			_gl.clear( _gl.STENCIL_BUFFER_BIT );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		// Reset

		this.resetGLState = function () {

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = - 1;
			_oldDepthTest = - 1;
			_oldDepthWrite = - 1;
			_oldDoubleSided = - 1;
			_oldFlipSided = - 1;
			_currentGeometryGroupHash = - 1;
			_currentMaterialId = - 1;

			_lightsNeedUpdate = true;

		};

		// Buffer allocation

		function createParticleBuffers ( geometry ) {

			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();

			_this.info.memory.geometries ++;

		};

		function createLineBuffers ( geometry ) {

			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglLineDistanceBuffer = _gl.createBuffer();

			_this.info.memory.geometries ++;

		};

		function createMeshBuffers ( geometryGroup ) {

			geometryGroup.__webglVertexBuffer = _gl.createBuffer();
			geometryGroup.__webglNormalBuffer = _gl.createBuffer();
			geometryGroup.__webglTangentBuffer = _gl.createBuffer();
			geometryGroup.__webglColorBuffer = _gl.createBuffer();
			geometryGroup.__webglUVBuffer = _gl.createBuffer();
			geometryGroup.__webglUV2Buffer = _gl.createBuffer();

			geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
			geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

			geometryGroup.__webglFaceBuffer = _gl.createBuffer();
			geometryGroup.__webglLineBuffer = _gl.createBuffer();

			var m, ml;

			if ( geometryGroup.numMorphTargets ) {

				geometryGroup.__webglMorphTargetsBuffers = [];

				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

					geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

				}

			}

			if ( geometryGroup.numMorphNormals ) {

				geometryGroup.__webglMorphNormalsBuffers = [];

				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

					geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

				}

			}

			_this.info.memory.geometries ++;

		};

		// Events

		var onObjectRemoved = function ( event ) {

			var object = event.target;

			object.traverse( function ( child ) {

				child.removeEventListener( 'remove', onObjectRemoved );

				removeObject( child );

			} );

		};

		var onGeometryDispose = function ( event ) {

			var geometry = event.target;

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			deallocateGeometry( geometry );

		};

		var onTextureDispose = function ( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			_this.info.memory.textures --;


		};

		var onRenderTargetDispose = function ( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			_this.info.memory.textures --;

		};

		var onMaterialDispose = function ( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		};

		// Buffer deallocation

		var deleteBuffers = function ( geometry ) {
		
			var buffers = [
				'__webglVertexBuffer',
				'__webglNormalBuffer',
				'__webglTangentBuffer',
				'__webglColorBuffer',
				'__webglUVBuffer',
				'__webglUV2Buffer',
				
				'__webglSkinIndicesBuffer',
				'__webglSkinWeightsBuffer',
				
				'__webglFaceBuffer',
				'__webglLineBuffer',
				
				'__webglLineDistanceBuffer'
			];

			for ( var i = 0, l = buffers.length; i < l; i ++ ) {

				var name = buffers[ i ];

				if ( geometry[ name ] !== undefined ) {

					_gl.deleteBuffer( geometry[ name ] );

					delete geometry[ name ];

				}

			}

			// custom attributes

			if ( geometry.__webglCustomAttributesList !== undefined ) {

				for ( var name in geometry.__webglCustomAttributesList ) {

					_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

				}

				delete geometry.__webglCustomAttributesList;

			}

			_this.info.memory.geometries --;

		};

		var deallocateGeometry = function ( geometry ) {

			delete geometry.__webglInit;

			if ( geometry instanceof THREE.BufferGeometry ) {

				for ( var name in geometry.attributes ) {
				
					var attribute = geometry.attributes[ name ];

					if ( attribute.buffer !== undefined ) {

						_gl.deleteBuffer( attribute.buffer );

						delete attribute.buffer;

					}

				}

				_this.info.memory.geometries --;

			} else {

				var geometryGroupsList = geometryGroups[ geometry.id ];

				if ( geometryGroupsList !== undefined ) {

					for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

						var geometryGroup = geometryGroupsList[ i ];

						if ( geometryGroup.numMorphTargets !== undefined ) {

							for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

								_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

							}

							delete geometryGroup.__webglMorphTargetsBuffers;

						}

						if ( geometryGroup.numMorphNormals !== undefined ) {

							for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

								_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

							}

							delete geometryGroup.__webglMorphNormalsBuffers;

						}

						deleteBuffers( geometryGroup );

					}

					delete geometryGroups[ geometry.id ];

				} else {

					deleteBuffers( geometry );

				}

			}

			// TOFIX: Workaround for deleted geometry being currently bound

			_currentGeometryGroupHash = - 1;

		};

		var deallocateTexture = function ( texture ) {

			if ( texture.image && texture.image.__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( texture.image.__webglTextureCube );

				delete texture.image.__webglTextureCube;

			} else {

				// 2D texture

				if ( texture.__webglInit === undefined ) return;

				_gl.deleteTexture( texture.__webglTexture );

				delete texture.__webglTexture;
				delete texture.__webglInit;

			}

		};

		var deallocateRenderTarget = function ( renderTarget ) {

			if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

			_gl.deleteTexture( renderTarget.__webglTexture );

			delete renderTarget.__webglTexture;

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

			}

			delete renderTarget.__webglFramebuffer;
			delete renderTarget.__webglRenderbuffer;

		};

		var deallocateMaterial = function ( material ) {

			var program = material.program.program;

			if ( program === undefined ) return;

			material.program = undefined;

			// only deallocate GL program if this was the last use of shared program
			// assumed there is only single copy of any program in the _programs list
			// (that's how it's constructed)

			var i, il, programInfo;
			var deleteProgram = false;

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program === program ) {

					programInfo.usedTimes --;

					if ( programInfo.usedTimes === 0 ) {

						deleteProgram = true;

					}

					break;

				}

			}

			if ( deleteProgram === true ) {

				// avoid using array.splice, this is costlier than creating new array from scratch

				var newPrograms = [];

				for ( i = 0, il = _programs.length; i < il; i ++ ) {

					programInfo = _programs[ i ];

					if ( programInfo.program !== program ) {

						newPrograms.push( programInfo );

					}

				}

				_programs = newPrograms;

				_gl.deleteProgram( program );

				_this.info.memory.programs --;

			}

		};

		// Buffer initialization

		function initCustomAttributes ( object ) {

			var geometry = object.geometry;
			var material = object.material;

			var nvertices = geometry.vertices.length;

			if ( material.attributes ) {

				if ( geometry.__webglCustomAttributesList === undefined ) {

					geometry.__webglCustomAttributesList = [];

				}

				for ( var name in material.attributes ) {

					var attribute = material.attributes[ name ];

					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

						attribute.__webglInitialized = true;

						var size = 1;   // "f" and "i"

						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;

						attribute.size = size;

						attribute.array = new Float32Array( nvertices * size );

						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;

						attribute.needsUpdate = true;

					}

					geometry.__webglCustomAttributesList.push( attribute );

				}

			}

		};

		function initParticleBuffers ( geometry, object ) {

			var nvertices = geometry.vertices.length;

			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );

			geometry.__sortArray = [];

			geometry.__webglParticleCount = nvertices;

			initCustomAttributes( object );

		};

		function initLineBuffers ( geometry, object ) {

			var nvertices = geometry.vertices.length;

			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

			geometry.__webglLineCount = nvertices;

			initCustomAttributes( object );

		};

		function initMeshBuffers ( geometryGroup, object ) {

			var geometry = object.geometry,
				faces3 = geometryGroup.faces3,

				nvertices = faces3.length * 3,
				ntris     = faces3.length * 1,
				nlines    = faces3.length * 3,

				material = getBufferMaterial( object, geometryGroup );

			geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
			geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

			if ( geometry.hasTangents ) {

				geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

			}

			if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

				geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
				geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

			}

			var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

			geometryGroup.__typeArray = UintArray;
			geometryGroup.__faceArray = new UintArray( ntris * 3 );
			geometryGroup.__lineArray = new UintArray( nlines * 2 );

			var m, ml;

			if ( geometryGroup.numMorphTargets ) {

				geometryGroup.__morphTargetsArrays = [];

				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

					geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

				}

			}

			if ( geometryGroup.numMorphNormals ) {

				geometryGroup.__morphNormalsArrays = [];

				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

					geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

				}

			}

			geometryGroup.__webglFaceCount = ntris * 3;
			geometryGroup.__webglLineCount = nlines * 2;


			// custom attributes

			if ( material.attributes ) {

				if ( geometryGroup.__webglCustomAttributesList === undefined ) {

					geometryGroup.__webglCustomAttributesList = [];

				}

				for ( var name in material.attributes ) {

					// Do a shallow copy of the attribute object so different geometryGroup chunks use different
					// attribute buffers which are correctly indexed in the setMeshBuffers function

					var originalAttribute = material.attributes[ name ];

					var attribute = {};

					for ( var property in originalAttribute ) {

						attribute[ property ] = originalAttribute[ property ];

					}

					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

						attribute.__webglInitialized = true;

						var size = 1;   // "f" and "i"

						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;

						attribute.size = size;

						attribute.array = new Float32Array( nvertices * size );

						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;

						originalAttribute.needsUpdate = true;
						attribute.__original = originalAttribute;

					}

					geometryGroup.__webglCustomAttributesList.push( attribute );

				}

			}

			geometryGroup.__inittedArrays = true;

		};

		function getBufferMaterial( object, geometryGroup ) {

			return object.material instanceof THREE.MeshFaceMaterial
				 ? object.material.materials[ geometryGroup.materialIndex ]
				 : object.material;

		};

		function materialNeedsSmoothNormals ( material ) {

			return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

		};

		// Buffer setting

		function setParticleBuffers ( geometry, hint, object ) {

			var v, c, vertex, offset, index, color,

			vertices = geometry.vertices,
			vl = vertices.length,

			colors = geometry.colors,
			cl = colors.length,

			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,

			sortArray = geometry.__sortArray,

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,

			customAttributes = geometry.__webglCustomAttributesList,
			i, il,
			a, ca, cal, value,
			customAttribute;

			if ( object.sortParticles ) {

				_projScreenMatrixPS.copy( _projScreenMatrix );
				_projScreenMatrixPS.multiply( object.matrixWorld );

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					_vector3.copy( vertex );
					_vector3.applyProjection( _projScreenMatrixPS );

					sortArray[ v ] = [ _vector3.z, v ];

				}

				sortArray.sort( numericalSort );

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ sortArray[ v ][ 1 ] ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

				for ( c = 0; c < cl; c ++ ) {

					offset = c * 3;

					color = colors[ sortArray[ c ][ 1 ] ];

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

				if ( customAttributes ) {

					for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

						customAttribute = customAttributes[ i ];

						if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) continue;

						offset = 0;

						cal = customAttribute.value.length;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								customAttribute.array[ ca ] = customAttribute.value[ index ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									index = sortArray[ ca ][ 1 ];

									value = customAttribute.value[ index ];

									customAttribute.array[ offset ]     = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									index = sortArray[ ca ][ 1 ];

									value = customAttribute.value[ index ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			} else {

				if ( dirtyVertices ) {

					for ( v = 0; v < vl; v ++ ) {

						vertex = vertices[ v ];

						offset = v * 3;

						vertexArray[ offset ]     = vertex.x;
						vertexArray[ offset + 1 ] = vertex.y;
						vertexArray[ offset + 2 ] = vertex.z;

					}

				}

				if ( dirtyColors ) {

					for ( c = 0; c < cl; c ++ ) {

						color = colors[ c ];

						offset = c * 3;

						colorArray[ offset ]     = color.r;
						colorArray[ offset + 1 ] = color.g;
						colorArray[ offset + 2 ] = color.b;

					}

				}

				if ( customAttributes ) {

					for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

						customAttribute = customAttributes[ i ];

						if ( customAttribute.needsUpdate &&
							 ( customAttribute.boundTo === undefined ||
								 customAttribute.boundTo === 'vertices' ) ) {

							cal = customAttribute.value.length;

							offset = 0;

							if ( customAttribute.size === 1 ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									customAttribute.array[ ca ] = customAttribute.value[ ca ];

								}

							} else if ( customAttribute.size === 2 ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;

									offset += 2;

								}

							} else if ( customAttribute.size === 3 ) {

								if ( customAttribute.type === 'c' ) {

									for ( ca = 0; ca < cal; ca ++ ) {

										value = customAttribute.value[ ca ];

										customAttribute.array[ offset ]   = value.r;
										customAttribute.array[ offset + 1 ] = value.g;
										customAttribute.array[ offset + 2 ] = value.b;

										offset += 3;

									}

								} else {

									for ( ca = 0; ca < cal; ca ++ ) {

										value = customAttribute.value[ ca ];

										customAttribute.array[ offset ]   = value.x;
										customAttribute.array[ offset + 1 ] = value.y;
										customAttribute.array[ offset + 2 ] = value.z;

										offset += 3;

									}

								}

							} else if ( customAttribute.size === 4 ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]      = value.x;
									customAttribute.array[ offset + 1  ] = value.y;
									customAttribute.array[ offset + 2  ] = value.z;
									customAttribute.array[ offset + 3  ] = value.w;

									offset += 4;

								}

							}

						}

					}

				}

			}

			if ( dirtyVertices || object.sortParticles ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyColors || object.sortParticles ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate || object.sortParticles ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

					}

				}

			}

		}

		function setLineBuffers ( geometry, hint ) {

			var v, c, d, vertex, offset, color,

			vertices = geometry.vertices,
			colors = geometry.colors,
			lineDistances = geometry.lineDistances,

			vl = vertices.length,
			cl = colors.length,
			dl = lineDistances.length,

			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			lineDistanceArray = geometry.__lineDistanceArray,

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyLineDistances = geometry.lineDistancesNeedUpdate,

			customAttributes = geometry.__webglCustomAttributesList,

			i, il,
			a, ca, cal, value,
			customAttribute;

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

			if ( dirtyLineDistances ) {

				for ( d = 0; d < dl; d ++ ) {

					lineDistanceArray[ d ] = lineDistances[ d ];

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
							 customAttribute.boundTo === 'vertices' ) ) {

						offset = 0;

						cal = customAttribute.value.length;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]    = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

					}

				}

			}

		}

		function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

			if ( ! geometryGroup.__inittedArrays ) {

				return;

			}

			var needsSmoothNormals = materialNeedsSmoothNormals( material );

			var f, fl, fi, face,
			vertexNormals, faceNormal, normal,
			vertexColors, faceColor,
			vertexTangents,
			uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
			c1, c2, c3,
			sw1, sw2, sw3, sw4,
			si1, si2, si3, si4,
			sa1, sa2, sa3, sa4,
			sb1, sb2, sb3, sb4,
			m, ml, i, il,
			vn, uvi, uv2i,
			vk, vkl, vka,
			nka, chf, faceVertexNormals,
			a,

			vertexIndex = 0,

			offset = 0,
			offset_uv = 0,
			offset_uv2 = 0,
			offset_face = 0,
			offset_normal = 0,
			offset_tangent = 0,
			offset_line = 0,
			offset_color = 0,
			offset_skin = 0,
			offset_morphTarget = 0,
			offset_custom = 0,
			offset_customSrc = 0,

			value,

			vertexArray = geometryGroup.__vertexArray,
			uvArray = geometryGroup.__uvArray,
			uv2Array = geometryGroup.__uv2Array,
			normalArray = geometryGroup.__normalArray,
			tangentArray = geometryGroup.__tangentArray,
			colorArray = geometryGroup.__colorArray,

			skinIndexArray = geometryGroup.__skinIndexArray,
			skinWeightArray = geometryGroup.__skinWeightArray,

			morphTargetsArrays = geometryGroup.__morphTargetsArrays,
			morphNormalsArrays = geometryGroup.__morphNormalsArrays,

			customAttributes = geometryGroup.__webglCustomAttributesList,
			customAttribute,

			faceArray = geometryGroup.__faceArray,
			lineArray = geometryGroup.__lineArray,

			geometry = object.geometry, // this is shared for all chunks

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyUvs = geometry.uvsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
			dirtyTangents = geometry.tangentsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

			vertices = geometry.vertices,
			chunk_faces3 = geometryGroup.faces3,
			obj_faces = geometry.faces,

			obj_uvs  = geometry.faceVertexUvs[ 0 ],
			obj_uvs2 = geometry.faceVertexUvs[ 1 ],

			obj_colors = geometry.colors,

			obj_skinIndices = geometry.skinIndices,
			obj_skinWeights = geometry.skinWeights,

			morphTargets = geometry.morphTargets,
			morphNormals = geometry.morphNormals;

			if ( dirtyVertices ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];

					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;

					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;

					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;

					offset += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyMorphTargets ) {

				for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

					offset_morphTarget = 0;

					for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

						chf = chunk_faces3[ f ];
						face = obj_faces[ chf ];

						// morph positions

						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];

						vka = morphTargetsArrays[ vk ];

						vka[ offset_morphTarget ]     = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;

						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;

						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;

						// morph normals

						if ( material.morphNormals ) {

							if ( needsSmoothNormals ) {

								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;

							} else {

								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;

							}

							nka = morphNormalsArrays[ vk ];

							nka[ offset_morphTarget ]     = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;

							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;

							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;

						}

						//

						offset_morphTarget += 9;

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

					if ( material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
						_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

					}

				}

			}

			if ( obj_skinWeights.length ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					// weights

					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];

					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;

					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;

					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;

					// indices

					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];

					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;

					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;

					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;

					offset_skin += 12;

				}

				if ( offset_skin > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

				}

			}

			if ( dirtyColors ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexColors = face.vertexColors;
					faceColor = face.color;

					if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];

					} else {

						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;

					}

					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;

					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;

					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;

					offset_color += 9;

				}

				if ( offset_color > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

				}

			}

			if ( dirtyTangents && geometry.hasTangents ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexTangents = face.vertexTangents;

					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];

					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;

					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;

					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;

					offset_tangent += 12;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

			}

			if ( dirtyNormals ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;

					if ( vertexNormals.length === 3 && needsSmoothNormals ) {

						for ( i = 0; i < 3; i ++ ) {

							vn = vertexNormals[ i ];

							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;

							offset_normal += 3;

						}

					} else {

						for ( i = 0; i < 3; i ++ ) {

							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;

							offset_normal += 3;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

			}

			if ( dirtyUvs && obj_uvs ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					fi = chunk_faces3[ f ];

					uv = obj_uvs[ fi ];

					if ( uv === undefined ) continue;

					for ( i = 0; i < 3; i ++ ) {

						uvi = uv[ i ];

						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;

						offset_uv += 2;

					}

				}

				if ( offset_uv > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

				}

			}

			if ( dirtyUvs && obj_uvs2 ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					fi = chunk_faces3[ f ];

					uv2 = obj_uvs2[ fi ];

					if ( uv2 === undefined ) continue;

					for ( i = 0; i < 3; i ++ ) {

						uv2i = uv2[ i ];

						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;

						offset_uv2 += 2;

					}

				}

				if ( offset_uv2 > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

				}

			}

			if ( dirtyElements ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					faceArray[ offset_face ]   = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 2;

					offset_face += 3;

					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;

					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 2;

					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;

					offset_line += 6;

					vertexIndex += 3;

				}

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! customAttribute.__original.needsUpdate ) continue;

					offset_custom = 0;
					offset_customSrc = 0;

					if ( customAttribute.size === 1 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

								offset_custom += 3;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								customAttribute.array[ offset_custom ]     = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;

								offset_custom += 3;

							}

						}

					} else if ( customAttribute.size === 2 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;

								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;

								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;

								offset_custom += 6;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;

								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;

								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;

								offset_custom += 6;

							}

						}

					} else if ( customAttribute.size === 3 ) {

						var pp;

						if ( customAttribute.type === 'c' ) {

							pp = [ 'r', 'g', 'b' ];

						} else {

							pp = [ 'x', 'y', 'z' ];

						}

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						} else if ( customAttribute.boundTo === 'faceVertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						} else if ( customAttribute.boundTo === 'faceVertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

			if ( dispose ) {

				delete geometryGroup.__inittedArrays;
				delete geometryGroup.__colorArray;
				delete geometryGroup.__normalArray;
				delete geometryGroup.__tangentArray;
				delete geometryGroup.__uvArray;
				delete geometryGroup.__uv2Array;
				delete geometryGroup.__faceArray;
				delete geometryGroup.__vertexArray;
				delete geometryGroup.__lineArray;
				delete geometryGroup.__skinIndexArray;
				delete geometryGroup.__skinWeightArray;

			}

		};

		function setDirectBuffers( geometry ) {

			var attributes = geometry.attributes;
			var attributesKeys = geometry.attributesKeys;

			for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

				var key = attributesKeys[ i ];
				var attribute = attributes[ key ];

				if ( attribute.buffer === undefined ) {

					attribute.buffer = _gl.createBuffer();
					attribute.needsUpdate = true;

				}

				if ( attribute.needsUpdate === true ) {

					var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

					_gl.bindBuffer( bufferType, attribute.buffer );
					_gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

					attribute.needsUpdate = false;

				}

			}

		}

		// Buffer rendering

		this.renderBufferImmediate = function ( object, program, material ) {

			initAttributes();

			if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
			if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
			if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
			if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
				enableAttribute( program.attributes.position );
				_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

				if ( material.shading === THREE.FlatShading ) {

					var nx, ny, nz,
						nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
						normalArray,
						i, il = object.count * 3;

					for ( i = 0; i < il; i += 9 ) {

						normalArray = object.normalArray;

						nax  = normalArray[ i ];
						nay  = normalArray[ i + 1 ];
						naz  = normalArray[ i + 2 ];

						nbx  = normalArray[ i + 3 ];
						nby  = normalArray[ i + 4 ];
						nbz  = normalArray[ i + 5 ];

						ncx  = normalArray[ i + 6 ];
						ncy  = normalArray[ i + 7 ];
						ncz  = normalArray[ i + 8 ];

						nx = ( nax + nbx + ncx ) / 3;
						ny = ( nay + nby + ncy ) / 3;
						nz = ( naz + nbz + ncz ) / 3;

						normalArray[ i ]   = nx;
						normalArray[ i + 1 ] = ny;
						normalArray[ i + 2 ] = nz;

						normalArray[ i + 3 ] = nx;
						normalArray[ i + 4 ] = ny;
						normalArray[ i + 5 ] = nz;

						normalArray[ i + 6 ] = nx;
						normalArray[ i + 7 ] = ny;
						normalArray[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
				enableAttribute( program.attributes.normal );
				_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
				enableAttribute( program.attributes.uv );
				_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
				enableAttribute( program.attributes.color );
				_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.attributes;
			var programAttributesKeys = program.attributesKeys;

			for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

				var key = programAttributesKeys[ i ];
				var programAttribute = programAttributes[ key ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ key ];

					if ( geometryAttribute !== undefined ) {

						var size = geometryAttribute.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

						enableAttribute( programAttribute );

						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

					} else if ( material.defaultAttributeValues !== undefined ) {

						if ( material.defaultAttributeValues[ key ].length === 2 ) {

							_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

						} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

							_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

			if ( material.visible === false ) return;

			var program = setProgram( camera, lights, fog, material, object );

			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

			if ( geometryHash !== _currentGeometryGroupHash ) {

				_currentGeometryGroupHash = geometryHash;
				updateBuffers = true;

			}

			if ( updateBuffers ) {

				initAttributes();

			}

			// render mesh

			if ( object instanceof THREE.Mesh ) {

				var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed triangles

					var type, size;

					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0 );

						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
						_this.info.render.faces += index.array.length / 3;

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed triangles

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
							_this.info.render.faces += offsets[ i ].count / 3;

						}

					}

				} else {

					// non-indexed triangles

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes[ 'position' ];

					// render non-indexed triangles

					_gl.drawArrays( mode, 0, position.array.length / 3 );

					_this.info.render.calls ++;
					_this.info.render.vertices += position.array.length / 3;
					_this.info.render.faces += position.array.length / 9;

				}

			} else if ( object instanceof THREE.PointCloud ) {

				// render particles

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes.position;

				// render particles

				_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.array.length / 3;

			} else if ( object instanceof THREE.Line ) {

				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				setLineWidth( material.linewidth );

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed lines

					var type, size;

					if ( index.array instanceof Uint32Array ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						if ( offsets.length > 1 ) updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed lines

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

						}

					}

				} else {

					// non-indexed lines

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes.position;

					_gl.drawArrays( mode, 0, position.array.length / 3 );

					_this.info.render.calls ++;
					_this.info.render.points += position.array.length / 3;

				}

			}

		};

		this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

			if ( material.visible === false ) return;

			var program = setProgram( camera, lights, fog, material, object );

			var attributes = program.attributes;

			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

			if ( geometryGroupHash !== _currentGeometryGroupHash ) {

				_currentGeometryGroupHash = geometryGroupHash;
				updateBuffers = true;

			}

			if ( updateBuffers ) {

				initAttributes();

			}

			// vertices

			if ( ! material.morphTargets && attributes.position >= 0 ) {

				if ( updateBuffers ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
					enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

				}

			} else {

				if ( object.morphTargetBase ) {

					setupMorphTargets( material, geometryGroup, object );

				}

			}


			if ( updateBuffers ) {

				// custom attributes

				// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

				if ( geometryGroup.__webglCustomAttributesList ) {

					for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

						var attribute = geometryGroup.__webglCustomAttributesList[ i ];

						if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
							enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
							_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

						}

					}

				}


				// colors

				if ( attributes.color >= 0 ) {

					if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
						enableAttribute( attributes.color );
						_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

					}

				}

				// normals

				if ( attributes.normal >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
					enableAttribute( attributes.normal );
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

				}

				// tangents

				if ( attributes.tangent >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
					enableAttribute( attributes.tangent );
					_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

				}

				// uvs

				if ( attributes.uv >= 0 ) {

					if ( object.geometry.faceVertexUvs[ 0 ] ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
						enableAttribute( attributes.uv );
						_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

					}

				}

				if ( attributes.uv2 >= 0 ) {

					if ( object.geometry.faceVertexUvs[ 1 ] ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
						enableAttribute( attributes.uv2 );
						_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

					}

				}

				if ( material.skinning &&
					 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					enableAttribute( attributes.skinIndex );
					_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					enableAttribute( attributes.skinWeight );
					_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

				}

				// line distances

				if ( attributes.lineDistance >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
					enableAttribute( attributes.lineDistance );
					_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

				}

			}

			disableUnusedAttributes();

			// render mesh

			if ( object instanceof THREE.Mesh ) {

				var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

				// wireframe

				if ( material.wireframe ) {

					setLineWidth( material.wireframeLinewidth );
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
					_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

				// triangles

				} else {

					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
					_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

				}

				_this.info.render.calls ++;
				_this.info.render.vertices += geometryGroup.__webglFaceCount;
				_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

			// render lines

			} else if ( object instanceof THREE.Line ) {

				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				setLineWidth( material.linewidth );

				_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

				_this.info.render.calls ++;

			// render particles

			} else if ( object instanceof THREE.PointCloud ) {

				_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

				_this.info.render.calls ++;
				_this.info.render.points += geometryGroup.__webglParticleCount;

			}

		};

		function initAttributes() {

			for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

				_newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			_newAttributes[ attribute ] = 1;

			if ( _enabledAttributes[ attribute ] === 0 ) {

				_gl.enableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = 1;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

				if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

					_gl.disableVertexAttribArray( i );
					_enabledAttributes[ i ] = 0;

				}

			}

		}

		function setupMorphTargets ( material, geometryGroup, object ) {

			// set base

			var attributes = material.program.attributes;

			if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			} else if ( attributes.position >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.morphTargetForcedOrder.length ) {

				// set forced order

				var m = 0;
				var order = object.morphTargetForcedOrder;
				var influences = object.morphTargetInfluences;

				while ( m < material.numSupportedMorphTargets && m < order.length ) {

					if ( attributes[ 'morphTarget' + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
						enableAttribute( attributes[ 'morphTarget' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
						enableAttribute( attributes[ 'morphNormal' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

					m ++;
				}

			} else {

				// find the most influencing

				var influence, activeInfluenceIndices = [];
				var influences = object.morphTargetInfluences;
				var i, il = influences.length;

				for ( i = 0; i < il; i ++ ) {

					influence = influences[ i ];

					if ( influence > 0 ) {

						activeInfluenceIndices.push( [ influence, i ] );

					}

				}

				if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

					activeInfluenceIndices.sort( numericalSort );
					activeInfluenceIndices.length = material.numSupportedMorphTargets;

				} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

					activeInfluenceIndices.sort( numericalSort );

				} else if ( activeInfluenceIndices.length === 0 ) {

					activeInfluenceIndices.push( [ 0, 0 ] );

				};

				var influenceIndex, m = 0;

				while ( m < material.numSupportedMorphTargets ) {

					if ( activeInfluenceIndices[ m ] ) {

						influenceIndex = activeInfluenceIndices[ m ][ 1 ];

						if ( attributes[ 'morphTarget' + m ] >= 0 ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
							enableAttribute( attributes[ 'morphTarget' + m ] );
							_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

						}

						if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
							enableAttribute( attributes[ 'morphNormal' + m ] );
							_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );


						}

						object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

					} else {

						/*
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

						if ( material.morphNormals ) {

							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

						}
						*/

						object.__webglMorphTargetInfluences[ m ] = 0;

					}

					m ++;

				}

			}

			// load updated influences uniform

			if ( material.program.uniforms.morphTargetInfluences !== null ) {

				_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

			}

		}

		// Sorting

		function painterSortStable ( a, b ) {

			if ( a.material.id !== b.material.id ) {

				return b.material.id - a.material.id;

			} else if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function numericalSort ( a, b ) {

			return b[ 0 ] - a[ 0 ];

		}

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( camera instanceof THREE.Camera === false ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryGroupHash = - 1;
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === undefined ) camera.updateMatrixWorld();

			// update Skeleton objects

			scene.traverse( function ( object ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

			} );

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lights.length = 0;
			opaqueObjects.length = 0;
			transparentObjects.length = 0;

			sprites.length = 0;
			lensFlares.length = 0;

			projectObject( scene, scene );

			if ( _this.sortObjects === true ) {

				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );

			}

			// custom render plugins (pre pass)

			shadowMapPlugin.render( scene, camera );

			//

			_this.info.render.calls = 0;
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_this.info.render.points = 0;

			this.setRenderTarget( renderTarget );

			if ( this.autoClear || forceClear ) {

				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

			}

			// set matrices for immediate objects

			for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

				var webglObject = _webglObjectsImmediate[ i ];
				var object = webglObject.object;

				if ( object.visible ) {

					setupMatrices( object, camera );

					unrollImmediateBufferMaterial( webglObject );

				}

			}

			if ( scene.overrideMaterial ) {

				var material = scene.overrideMaterial;

				this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				this.setDepthTest( material.depthTest );
				this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				renderObjects( opaqueObjects, camera, lights, fog, true, material );
				renderObjects( transparentObjects, camera, lights, fog, true, material );
				renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );

			} else {

				var material = null;

				// opaque pass (front-to-back order)

				this.setBlending( THREE.NoBlending );

				renderObjects( opaqueObjects, camera, lights, fog, false, material );
				renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog, true, material );
				renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );

			}

			// custom render plugins (post pass)

			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

				updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			this.setDepthTest( true );
			this.setDepthWrite( true );

			// _gl.finish();

		};

		function projectObject( scene, object ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

				// skip

			} else {

				initObject( object, scene );

				if ( object instanceof THREE.Light ) {

					lights.push( object );

				} else if ( object instanceof THREE.Sprite ) {

					sprites.push( object );

				} else if ( object instanceof THREE.LensFlare ) {

					lensFlares.push( object );

				} else {

					var webglObjects = _webglObjects[ object.id ];

					if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

						updateObject( object, scene );

						for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

							var webglObject = webglObjects[i];

							unrollBufferMaterial( webglObject );

							webglObject.render = true;

							if ( _this.sortObjects === true ) {

								if ( object.renderDepth !== null ) {

									webglObject.z = object.renderDepth;

								} else {

									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyProjection( _projScreenMatrix );

									webglObject.z = _vector3.z;

								}

							}

						}

					}

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( scene, object.children[ i ] );

			}

		}

		function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

			var material;

			for ( var i = renderList.length - 1; i !== - 1; i -- ) {

				var webglObject = renderList[ i ];

				var object = webglObject.object;
				var buffer = webglObject.buffer;

				setupMatrices( object, camera );

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject.material;

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

		function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

			var material;

			for ( var i = 0, il = renderList.length; i < il; i ++ ) {

				var webglObject = renderList[ i ];
				var object = webglObject.object;

				if ( object.visible ) {

					if ( overrideMaterial ) {

						material = overrideMaterial;

					} else {

						material = webglObject[ materialType ];

						if ( ! material ) continue;

						if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

						_this.setDepthTest( material.depthTest );
						_this.setDepthWrite( material.depthWrite );
						setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

					}

					_this.renderImmediateObject( camera, lights, fog, material, object );

				}

			}

		}

		this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

			var program = setProgram( camera, lights, fog, material, object );

			_currentGeometryGroupHash = - 1;

			_this.setMaterialFaces( material );

			if ( object.immediateRenderCallback ) {

				object.immediateRenderCallback( program, _gl, _frustum );

			} else {

				object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

			}

		};

		function unrollImmediateBufferMaterial ( globject ) {

			var object = globject.object,
				material = object.material;

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		}

		function unrollBufferMaterial ( globject ) {

			var object = globject.object;
			var buffer = globject.buffer;

			var geometry = object.geometry;
			var material = object.material;

			if ( material instanceof THREE.MeshFaceMaterial ) {

				var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

				material = material.materials[ materialIndex ];

				globject.material = material;

				if ( material.transparent ) {

					transparentObjects.push( globject );

				} else {

					opaqueObjects.push( globject );

				}

			} else if ( material ) {

				globject.material = material;

				if ( material.transparent ) {

					transparentObjects.push( globject );

				} else {

					opaqueObjects.push( globject );

				}

			}

		}

		function initObject( object, scene ) {

			if ( object.__webglInit === undefined ) {

				object.__webglInit = true;
				object._modelViewMatrix = new THREE.Matrix4();
				object._normalMatrix = new THREE.Matrix3();

				object.addEventListener( 'removed', onObjectRemoved );

			}

			var geometry = object.geometry;

			if ( geometry === undefined ) {

				// ImmediateRenderObject

			} else if ( geometry.__webglInit === undefined ) {

				geometry.__webglInit = true;
				geometry.addEventListener( 'dispose', onGeometryDispose );

				if ( geometry instanceof THREE.BufferGeometry ) {

					//

				} else if ( object instanceof THREE.Mesh ) {

					initGeometryGroups( scene, object, geometry );

				} else if ( object instanceof THREE.Line ) {

					if ( geometry.__webglVertexBuffer === undefined ) {

						createLineBuffers( geometry );
						initLineBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
						geometry.lineDistancesNeedUpdate = true;

					}

				} else if ( object instanceof THREE.PointCloud ) {

					if ( geometry.__webglVertexBuffer === undefined ) {

						createParticleBuffers( geometry );
						initParticleBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					}

				}

			}

			if ( object.__webglActive === undefined) {

				object.__webglActive = true;

				if ( object instanceof THREE.Mesh ) {

					if ( geometry instanceof THREE.BufferGeometry ) {

						addBuffer( _webglObjects, geometry, object );

					} else if ( geometry instanceof THREE.Geometry ) {

						var geometryGroupsList = geometryGroups[ geometry.id ];

						for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

							addBuffer( _webglObjects, geometryGroupsList[ i ], object );

						}

					}

				} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

					addBufferImmediate( _webglObjectsImmediate, object );

				}

			}

		}

		// Geometry splitting

		var geometryGroups = {};
		var geometryGroupCounter = 0;

		function makeGroups( geometry, usesFaceMaterial ) {

			var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

			var groupHash, hash_map = {};

			var numMorphTargets = geometry.morphTargets.length;
			var numMorphNormals = geometry.morphNormals.length;

			var group;
			var groups = {};
			var groupsList = [];

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];
				var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

				if ( ! ( materialIndex in hash_map ) ) {

					hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

				}

				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};
					
					groups[ groupHash ] = group;
					groupsList.push( group );

				}

				if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

					if ( ! ( groupHash in groups ) ) {

						group = {
							id: geometryGroupCounter ++,
							faces3: [],
							materialIndex: materialIndex,
							vertices: 0,
							numMorphTargets: numMorphTargets,
							numMorphNormals: numMorphNormals
						};
						
						groups[ groupHash ] = group;
						groupsList.push( group );

					}

				}

				groups[ groupHash ].faces3.push( f );
				groups[ groupHash ].vertices += 3;

			}

			return groupsList;

		}

		function initGeometryGroups( scene, object, geometry ) {

			var material = object.material, addBuffers = false;

			if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

				delete _webglObjects[ object.id ];

				geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

				geometry.groupsNeedUpdate = false;

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			// create separate VBOs per geometry chunk

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				// initialise VBO on the first access

				if ( geometryGroup.__webglVertexBuffer === undefined ) {

					createMeshBuffers( geometryGroup );
					initMeshBuffers( geometryGroup, object );

					geometry.verticesNeedUpdate = true;
					geometry.morphTargetsNeedUpdate = true;
					geometry.elementsNeedUpdate = true;
					geometry.uvsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;
					geometry.tangentsNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

					addBuffers = true;

				} else {

					addBuffers = false;

				}

				if ( addBuffers || object.__webglActive === undefined ) {

					addBuffer( _webglObjects, geometryGroup, object );

				}

			}

			object.__webglActive = true;

		}

		function addBuffer( objlist, buffer, object ) {

			var id = object.id;
			objlist[id] = objlist[id] || [];
			objlist[id].push(
				{
					id: id,
					buffer: buffer,
					object: object,
					material: null,
					z: 0
				}
			);

		};

		function addBufferImmediate( objlist, object ) {

			objlist.push(
				{
					id: null,
					object: object,
					opaque: null,
					transparent: null,
					z: 0
				}
			);

		};

		// Objects updates

		function updateObject( object, scene ) {

			var geometry = object.geometry, customAttributesDirty, material;

			if ( geometry instanceof THREE.BufferGeometry ) {

				setDirectBuffers( geometry );

			} else if ( object instanceof THREE.Mesh ) {

				// check all geometry groups

				if ( geometry.groupsNeedUpdate === true ) {

					initGeometryGroups( scene, object, geometry );

				}

				var geometryGroupsList = geometryGroups[ geometry.id ];

				for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];

					material = getBufferMaterial( object, geometryGroup );

					if ( geometry.groupsNeedUpdate === true ) {

						initMeshBuffers( geometryGroup, object );

					}

					customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			} else if ( object instanceof THREE.Line ) {

				material = getBufferMaterial( object, geometry );

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

					setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.lineDistancesNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );


			} else if ( object instanceof THREE.PointCloud ) {

				material = getBufferMaterial( object, geometry );

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

					setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			}

		}

		// Objects updates - custom attributes check

		function areCustomAttributesDirty( material ) {

			for ( var name in material.attributes ) {

				if ( material.attributes[ name ].needsUpdate ) return true;

			}

			return false;

		}

		function clearCustomAttributes( material ) {

			for ( var name in material.attributes ) {

				material.attributes[ name ].needsUpdate = false;

			}

		}

		// Objects removal

		function removeObject( object ) {

			if ( object instanceof THREE.Mesh  ||
				 object instanceof THREE.PointCloud ||
				 object instanceof THREE.Line ) {

				delete _webglObjects[ object.id ];

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				removeInstances( _webglObjectsImmediate, object );

			}

			delete object.__webglInit;
			delete object._modelViewMatrix;
			delete object._normalMatrix;

			delete object.__webglActive;

		}

		function removeInstances( objlist, object ) {

			for ( var o = objlist.length - 1; o >= 0; o -- ) {

				if ( objlist[ o ].object === object ) {

					objlist.splice( o, 1 );

				}

			}

		}

		// Materials

		function initMaterial( material, lights, fog, object ) {

			material.addEventListener( 'dispose', onMaterialDispose );

			var shaderID;

			if ( material instanceof THREE.MeshDepthMaterial ) {

				shaderID = 'depth';

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				shaderID = 'normal';

			} else if ( material instanceof THREE.MeshBasicMaterial ) {

				shaderID = 'basic';

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				shaderID = 'lambert';

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				shaderID = 'phong';

			} else if ( material instanceof THREE.LineBasicMaterial ) {

				shaderID = 'basic';

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				shaderID = 'dashed';

			} else if ( material instanceof THREE.PointCloudMaterial ) {

				shaderID = 'particle_basic';

			}

			if ( shaderID ) {

				var shader = THREE.ShaderLib[ shaderID ];

				material.__webglShader = {
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				}

			} else {

				material.__webglShader = {
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				}

			}

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxLightCount = allocateLights( lights );
			var maxShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );

			var parameters = {

				precision: _precision,
				supportsVertexTextures: _supportsVertexTextures,

				map: !! material.map,
				envMap: !! material.envMap,
				lightMap: !! material.lightMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: _logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: _this.maxMorphTargets,
				maxMorphNormals: _this.maxMorphNormals,

				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,

				maxShadows: maxShadows,
				shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
				shadowMapType: _this.shadowMapType,
				shadowMapDebug: _this.shadowMapDebug,
				shadowMapCascade: _this.shadowMapCascade,

				alphaTest: material.alphaTest,
				metal: material.metal,
				wrapAround: material.wrapAround,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide

			};

			// Generate code

			var chunks = [];

			if ( shaderID ) {

				chunks.push( shaderID );

			} else {

				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					chunks.push( name );
					chunks.push( material.defines[ name ] );

				}

			}

			for ( var name in parameters ) {

				chunks.push( name );
				chunks.push( parameters[ name ] );

			}

			var code = chunks.join();

			var program;

			// Check if code has been already compiled

			for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

				var programInfo = _programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					program.usedTimes ++;

					break;

				}

			}

			if ( program === undefined ) {

				program = new THREE.WebGLProgram( _this, code, material, parameters );
				_programs.push( program );

				_this.info.memory.programs = _programs.length;

			}

			material.program = program;

			var attributes = program.attributes;

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				var id, base = 'morphTarget';

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					id = base + i;

					if ( attributes[ id ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				var id, base = 'morphNormal';

				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

					id = base + i;

					if ( attributes[ id ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			material.uniformsList = [];

			for ( var u in material.__webglShader.uniforms ) {

				var location = material.program.uniforms[ u ];

				if ( location ) {
					material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
				}

			}

		}

		function setProgram( camera, lights, fog, material, object ) {

			_usedTextureUnits = 0;

			if ( material.needsUpdate ) {

				if ( material.program ) deallocateMaterial( material );

				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;

			}

			if ( material.morphTargets ) {

				if ( ! object.__webglMorphTargetInfluences ) {

					object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

				}

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = material.program,
				p_uniforms = program.uniforms,
				m_uniforms = material.__webglShader.uniforms;

			if ( program.id !== _currentProgram ) {

				_gl.useProgram( program.program );
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				if ( _currentMaterialId === -1 ) refreshLights = true;
				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				if ( _logarithmicDepthBuffer ) {

					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}


				if ( camera !== _currentCamera ) _currentCamera = camera;

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {

					if ( p_uniforms.cameraPosition !== null ) {

						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

					}

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {

					if ( p_uniforms.viewMatrix !== null ) {

						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

					}

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

				}

				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

				}

				if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

					if ( p_uniforms.boneTexture !== null ) {

						var textureUnit = getTextureUnit();

						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );

					}

					if ( p_uniforms.boneTextureWidth !== null ) {

						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

					}

					if ( p_uniforms.boneTextureHeight !== null ) {

						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

					}

				} else if ( object.skeleton && object.skeleton.boneMatrices ) {

					if ( p_uniforms.boneGlobalMatrices !== null ) {

						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

					}

				}

			}

			if ( refreshMaterial ) {

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {

					if ( _lightsNeedUpdate ) {

						refreshLights = true;
						setupLights( lights );
						_lightsNeedUpdate = false;
					}

					if ( refreshLights ) {
						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );
					} else {
						markUniformsLightsNeedsUpdate( m_uniforms, false );
					}

				}

				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				}

				// refresh single material specific uniforms

				if ( material instanceof THREE.LineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

				} else if ( material instanceof THREE.LineDashedMaterial ) {

					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );

				} else if ( material instanceof THREE.PointCloudMaterial ) {

					refreshUniformsParticle( m_uniforms, material );

				} else if ( material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsPhong( m_uniforms, material );

				} else if ( material instanceof THREE.MeshLambertMaterial ) {

					refreshUniformsLambert( m_uniforms, material );

				} else if ( material instanceof THREE.MeshDepthMaterial ) {

					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;

				} else if ( material instanceof THREE.MeshNormalMaterial ) {

					m_uniforms.opacity.value = material.opacity;

				}

				if ( object.receiveShadow && ! material._shadowPass ) {

					refreshUniformsShadow( m_uniforms, lights );

				}

				// load common uniforms

				loadUniformsGeneric( material.uniformsList );

			}

			loadUniformsMatrices( p_uniforms, object );

			if ( p_uniforms.modelMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon ( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( _this.gammaInput ) {

				uniforms.diffuse.value.copyGammaToLinear( material.color );

			} else {

				uniforms.diffuse.value = material.color;

			}

			uniforms.map.value = material.map;
			uniforms.lightMap.value = material.lightMap;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			// uv repeat and offset setting priorities
			//  1. color map
			//  2. specular map
			//  3. normal map
			//  4. bump map
			//  5. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

			if ( _this.gammaInput ) {

				//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
				uniforms.reflectivity.value = material.reflectivity;

			} else {

				uniforms.reflectivity.value = material.reflectivity;

			}

			uniforms.refractionRatio.value = material.refractionRatio;
			uniforms.combine.value = material.combine;
			uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

		}

		function refreshUniformsLine ( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash ( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsParticle ( uniforms, material ) {

			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

			uniforms.map.value = material.map;

		}

		function refreshUniformsFog ( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog instanceof THREE.Fog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog instanceof THREE.FogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsPhong ( uniforms, material ) {

			uniforms.shininess.value = material.shininess;

			if ( _this.gammaInput ) {

				uniforms.ambient.value.copyGammaToLinear( material.ambient );
				uniforms.emissive.value.copyGammaToLinear( material.emissive );
				uniforms.specular.value.copyGammaToLinear( material.specular );

			} else {

				uniforms.ambient.value = material.ambient;
				uniforms.emissive.value = material.emissive;
				uniforms.specular.value = material.specular;

			}

			if ( material.wrapAround ) {

				uniforms.wrapRGB.value.copy( material.wrapRGB );

			}

		}

		function refreshUniformsLambert ( uniforms, material ) {

			if ( _this.gammaInput ) {

				uniforms.ambient.value.copyGammaToLinear( material.ambient );
				uniforms.emissive.value.copyGammaToLinear( material.emissive );

			} else {

				uniforms.ambient.value = material.ambient;
				uniforms.emissive.value = material.emissive;

			}

			if ( material.wrapAround ) {

				uniforms.wrapRGB.value.copy( material.wrapRGB );

			}

		}

		function refreshUniformsLights ( uniforms, lights ) {

			uniforms.ambientLightColor.value = lights.ambient;

			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;

			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;

			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;

			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

			uniforms.ambientLightColor.needsUpdate = boolean;

			uniforms.directionalLightColor.needsUpdate = boolean;
			uniforms.directionalLightDirection.needsUpdate = boolean;

			uniforms.pointLightColor.needsUpdate = boolean;
			uniforms.pointLightPosition.needsUpdate = boolean;
			uniforms.pointLightDistance.needsUpdate = boolean;

			uniforms.spotLightColor.needsUpdate = boolean;
			uniforms.spotLightPosition.needsUpdate = boolean;
			uniforms.spotLightDistance.needsUpdate = boolean;
			uniforms.spotLightDirection.needsUpdate = boolean;
			uniforms.spotLightAngleCos.needsUpdate = boolean;
			uniforms.spotLightExponent.needsUpdate = boolean;

			uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
			uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
			uniforms.hemisphereLightDirection.needsUpdate = boolean;

		}

		function refreshUniformsShadow ( uniforms, lights ) {

			if ( uniforms.shadowMatrix ) {

				var j = 0;

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];

					if ( ! light.castShadow ) continue;

					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;

						j ++;

					}

				}

			}

		}

		// Uniforms (load to GPU)

		function loadUniformsMatrices ( uniforms, object ) {

			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

			if ( uniforms.normalMatrix ) {

				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

			}

		}

		function getTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= _maxTextures ) {

				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		function loadUniformsGeneric ( uniforms ) {

			var texture, textureUnit, offset;

			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

				var uniform = uniforms[ j ][ 0 ];

				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;

				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];

				switch ( type ) {

					case '1i':
						_gl.uniform1i( location, value );
						break;

					case '1f':
						_gl.uniform1f( location, value );
						break;

					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;

					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;

					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;

					case '1iv':
						_gl.uniform1iv( location, value );
						break;

					case '3iv':
						_gl.uniform3iv( location, value );
						break;

					case '1fv':
						_gl.uniform1fv( location, value );
						break;

					case '2fv':
						_gl.uniform2fv( location, value );
						break;

					case '3fv':
						_gl.uniform3fv( location, value );
						break;

					case '4fv':
						_gl.uniform4fv( location, value );
						break;

					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;

					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;

					//

					case 'i':

						// single integer
						_gl.uniform1i( location, value );

						break;

					case 'f':

						// single float
						_gl.uniform1f( location, value );

						break;

					case 'v2':

						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );

						break;

					case 'v3':

						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );

						break;

					case 'v4':

						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );

						break;

					case 'c':

						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );

						break;

					case 'iv1':

						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );

						break;

					case 'iv':

						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );

						break;

					case 'fv1':

						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );

						break;

					case 'fv':

						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );

						break;

					case 'v2v':

						// array of THREE.Vector2

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 2 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 2;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;

						}

						_gl.uniform2fv( location, uniform._array );

						break;

					case 'v3v':

						// array of THREE.Vector3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 3 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 3;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;

						}

						_gl.uniform3fv( location, uniform._array );

						break;

					case 'v4v':

						// array of THREE.Vector4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 4 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 4;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;
							uniform._array[ offset + 3 ] = value[ i ].w;

						}

						_gl.uniform4fv( location, uniform._array );

						break;

					case 'm3':

						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );

						break;

					case 'm3v':

						// array of THREE.Matrix3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 9 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

						}

						_gl.uniformMatrix3fv( location, false, uniform._array );

						break;

					case 'm4':

						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );

						break;

					case 'm4v':

						// array of THREE.Matrix4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 16 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

						}

						_gl.uniformMatrix4fv( location, false, uniform._array );

						break;

					case 't':

						// single THREE.Texture (2d or cube)

						texture = value;
						textureUnit = getTextureUnit();

						_gl.uniform1i( location, textureUnit );

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
						   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

						break;

					case 'tv':

						// array of THREE.Texture (2d)

						if ( uniform._array === undefined ) {

							uniform._array = [];

						}

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							uniform._array[ i ] = getTextureUnit();

						}

						_gl.uniform1iv( location, uniform._array );

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];

							if ( ! texture ) continue;

							_this.setTexture( texture, textureUnit );

						}

						break;

					default:

						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

				}

			}

		}

		function setupMatrices ( object, camera ) {

			object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

		}

		//

		function setColorGamma( array, offset, color, intensitySq ) {

			array[ offset ]     = color.r * color.r * intensitySq;
			array[ offset + 1 ] = color.g * color.g * intensitySq;
			array[ offset + 2 ] = color.b * color.b * intensitySq;

		}

		function setColorLinear( array, offset, color, intensity ) {

			array[ offset ]     = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;

		}

		function setupLights ( lights ) {

			var l, ll, light, n,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,  intensitySq,
			position,
			distance,

			zlights = _lights,

			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,

			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,

			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,

			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,

			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];

				if ( light.onlyShadow ) continue;

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				if ( light instanceof THREE.AmbientLight ) {

					if ( ! light.visible ) continue;

					if ( _this.gammaInput ) {

						r += color.r * color.r;
						g += color.g * color.g;
						b += color.b * color.b;

					} else {

						r += color.r;
						g += color.g;
						b += color.b;

					}

				} else if ( light instanceof THREE.DirectionalLight ) {

					dirCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();

					dirOffset = dirLength * 3;

					dirPositions[ dirOffset ]     = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;

					if ( _this.gammaInput ) {

						setColorGamma( dirColors, dirOffset, color, intensity * intensity );

					} else {

						setColorLinear( dirColors, dirOffset, color, intensity );

					}

					dirLength += 1;

				} else if ( light instanceof THREE.PointLight ) {

					pointCount += 1;

					if ( ! light.visible ) continue;

					pointOffset = pointLength * 3;

					if ( _this.gammaInput ) {

						setColorGamma( pointColors, pointOffset, color, intensity * intensity );

					} else {

						setColorLinear( pointColors, pointOffset, color, intensity );

					}

					_vector3.setFromMatrixPosition( light.matrixWorld );

					pointPositions[ pointOffset ]     = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;

					pointDistances[ pointLength ] = distance;

					pointLength += 1;

				} else if ( light instanceof THREE.SpotLight ) {

					spotCount += 1;

					if ( ! light.visible ) continue;

					spotOffset = spotLength * 3;

					if ( _this.gammaInput ) {

						setColorGamma( spotColors, spotOffset, color, intensity * intensity );

					} else {

						setColorLinear( spotColors, spotOffset, color, intensity );

					}

					_direction.setFromMatrixPosition( light.matrixWorld );

					spotPositions[ spotOffset ]     = _direction.x;
					spotPositions[ spotOffset + 1 ] = _direction.y;
					spotPositions[ spotOffset + 2 ] = _direction.z;

					spotDistances[ spotLength ] = distance;

					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();

					spotDirections[ spotOffset ]     = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;

					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;

					spotLength += 1;

				} else if ( light instanceof THREE.HemisphereLight ) {

					hemiCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.normalize();

					hemiOffset = hemiLength * 3;

					hemiPositions[ hemiOffset ]     = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;

					skyColor = light.color;
					groundColor = light.groundColor;

					if ( _this.gammaInput ) {

						intensitySq = intensity * intensity;

						setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
						setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

					} else {

						setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
						setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

					}

					hemiLength += 1;

				}

			}

			// null eventual remains from removed lights
			// (this is to avoid if in shader)

			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;

			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			if ( cullFace === THREE.CullFaceNone ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				if ( cullFace === THREE.CullFaceBack ) {

					_gl.cullFace( _gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					_gl.cullFace( _gl.FRONT );

				} else {

					_gl.cullFace( _gl.FRONT_AND_BACK );

				}

				_gl.enable( _gl.CULL_FACE );

			}

		};

		this.setMaterialFaces = function ( material ) {

			var doubleSided = material.side === THREE.DoubleSide;
			var flipSided = material.side === THREE.BackSide;

			if ( _oldDoubleSided !== doubleSided ) {

				if ( doubleSided ) {

					_gl.disable( _gl.CULL_FACE );

				} else {

					_gl.enable( _gl.CULL_FACE );

				}

				_oldDoubleSided = doubleSided;

			}

			if ( _oldFlipSided !== flipSided ) {

				if ( flipSided ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				_oldFlipSided = flipSided;

			}

		};

		this.setDepthTest = function ( depthTest ) {

			if ( _oldDepthTest !== depthTest ) {

				if ( depthTest ) {

					_gl.enable( _gl.DEPTH_TEST );

				} else {

					_gl.disable( _gl.DEPTH_TEST );

				}

				_oldDepthTest = depthTest;

			}

		};

		this.setDepthWrite = function ( depthWrite ) {

			if ( _oldDepthWrite !== depthWrite ) {

				_gl.depthMask( depthWrite );
				_oldDepthWrite = depthWrite;

			}

		};

		function setLineWidth ( width ) {

			if ( width !== _oldLineWidth ) {

				_gl.lineWidth( width );

				_oldLineWidth = width;

			}

		}

		function setPolygonOffset ( polygonoffset, factor, units ) {

			if ( _oldPolygonOffset !== polygonoffset ) {

				if ( polygonoffset ) {

					_gl.enable( _gl.POLYGON_OFFSET_FILL );

				} else {

					_gl.disable( _gl.POLYGON_OFFSET_FILL );

				}

				_oldPolygonOffset = polygonoffset;

			}

			if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

				_gl.polygonOffset( factor, units );

				_oldPolygonOffsetFactor = factor;
				_oldPolygonOffsetUnits = units;

			}

		}

		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

			if ( blending !== _oldBlending ) {

				if ( blending === THREE.NoBlending ) {

					_gl.disable( _gl.BLEND );

				} else if ( blending === THREE.AdditiveBlending ) {

					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

				} else if ( blending === THREE.SubtractiveBlending ) {

					// TODO: Find blendFuncSeparate() combination
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

				} else if ( blending === THREE.MultiplyBlending ) {

					// TODO: Find blendFuncSeparate() combination
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

				} else if ( blending === THREE.CustomBlending ) {

					_gl.enable( _gl.BLEND );

				} else {

					_gl.enable( _gl.BLEND );
					_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
					_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

				}

				_oldBlending = blending;

			}

			if ( blending === THREE.CustomBlending ) {

				if ( blendEquation !== _oldBlendEquation ) {

					_gl.blendEquation( paramThreeToGL( blendEquation ) );

					_oldBlendEquation = blendEquation;

				}

				if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

					_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

					_oldBlendSrc = blendSrc;
					_oldBlendDst = blendDst;

				}

			} else {

				_oldBlendEquation = null;
				_oldBlendSrc = null;
				_oldBlendDst = null;

			}

		};

		// Textures

		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

			var extension;

			if ( isImagePowerOfTwo ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension && texture.type !== THREE.FloatType ) {

				if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					texture.__oldAnisotropy = texture.anisotropy;

				}

			}

		}

		this.uploadTexture = function ( texture ) {

			if ( texture.__webglInit === undefined ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			texture.image = clampToMaxSize( texture.image, _maxTextureSize );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

						if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

							_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( "Attempt to load unsupported compressed texture format" );

						}

					} else {

						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		};

		this.setTexture = function ( texture, slot ) {

			_gl.activeTexture( _gl.TEXTURE0 + slot );

			if ( texture.needsUpdate ) {

				_this.uploadTexture( texture );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			}

		};

		function clampToMaxSize ( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );

				return canvas;

			}

			return image;

		}

		function setCubeTexture ( texture, slot ) {

			if ( texture.image.length === 6 ) {

				if ( texture.needsUpdate ) {

					if ( ! texture.image.__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						texture.image.__webglTextureCube = _gl.createTexture();

						_this.info.memory.textures ++;

					}

					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

									if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

										_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( "Attempt to load unsupported compressed texture format" );

									}

								} else {

									_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( texture.generateMipmaps && isImagePowerOfTwo ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					texture.needsUpdate = false;

					if ( texture.onUpdate ) texture.onUpdate();

				} else {

					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				}

			}

		}

		function setCubeTextureDynamic ( texture, slot ) {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

		}

		// Render targets

		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

		}

		function setupRenderBuffer ( renderbuffer, renderTarget  ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

		}

		this.setRenderTarget = function ( renderTarget ) {

			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

			if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				renderTarget.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

				// Setup texture, create render and frame buffers

				var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );

				if ( isCube ) {

					renderTarget.__webglFramebuffer = [];
					renderTarget.__webglRenderbuffer = [];

					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

						setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

					}

					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				} else {

					renderTarget.__webglFramebuffer = _gl.createFramebuffer();

					if ( renderTarget.shareDepthFrom ) {

						renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

					} else {

						renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

					}

					_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

					if ( renderTarget.shareDepthFrom ) {

						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

						}

					} else {

						setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

					}

					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

				}

				// Release everything

				if ( isCube ) {

					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					_gl.bindTexture( _gl.TEXTURE_2D, null );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			var framebuffer, width, height, vx, vy;

			if ( renderTarget ) {

				if ( isCube ) {

					framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

				} else {

					framebuffer = renderTarget.__webglFramebuffer;

				}

				width = renderTarget.width;
				height = renderTarget.height;

				vx = 0;
				vy = 0;

			} else {

				framebuffer = null;

				width = _viewportWidth;
				height = _viewportHeight;

				vx = _viewportX;
				vy = _viewportY;

			}

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );

				_currentFramebuffer = framebuffer;

			}

			_currentWidth = width;
			_currentHeight = height;

		};

		function updateRenderTargetMipmap ( renderTarget ) {

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback ( f ) {

			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		// Map three.js constants to WebGL constants

		function paramThreeToGL ( p ) {

			var extension;

			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;

			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

			}

			return 0;

		}

		// Allocations

		function allocateBones ( object ) {

			if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader
				//   to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = nVertexMatrices;

				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

					maxBones = Math.min( object.skeleton.bones.length, maxBones );

					if ( maxBones < object.skeleton.bones.length ) {

						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function allocateLights( lights ) {

			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( light.onlyShadow || light.visible === false ) continue;

				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

			}

			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

		}

		function allocateShadows( lights ) {

			var maxShadows = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

			}

			return maxShadows;

		}

		// DEPRECATED
		
		this.initMaterial = function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		};

		this.addPrePlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		};

		this.addPostPlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		};

		this.updateShadowMap = function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		};

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.WebGLRenderTarget = function ( width, height, options ) {

		this.width = width;
		this.height = height;

		options = options || {};

		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

		this.generateMipmaps = true;

		this.shareDepthFrom = null;

	};

	THREE.WebGLRenderTarget.prototype = {

		constructor: THREE.WebGLRenderTarget,

		setSize: function ( width, height ) {

			this.width = width;
			this.height = height;

		},

		clone: function () {

			var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

			tmp.wrapS = this.wrapS;
			tmp.wrapT = this.wrapT;

			tmp.magFilter = this.magFilter;
			tmp.minFilter = this.minFilter;

			tmp.anisotropy = this.anisotropy;

			tmp.offset.copy( this.offset );
			tmp.repeat.copy( this.repeat );

			tmp.format = this.format;
			tmp.type = this.type;

			tmp.depthBuffer = this.depthBuffer;
			tmp.stencilBuffer = this.stencilBuffer;

			tmp.generateMipmaps = this.generateMipmaps;

			tmp.shareDepthFrom = this.shareDepthFrom;

			return tmp;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function ( width, height, options ) {

		THREE.WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/webgl/WebGLExtensions.js

	THREE.WebGLExtensions = function ( gl ) {

		var extensions = {};

		this.get = function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {
			
				case 'OES_texture_float':
					extension = gl.getExtension( 'OES_texture_float' );
					break;

				case 'OES_texture_float_linear':
					extension = gl.getExtension( 'OES_texture_float_linear' );
					break;

				case 'OES_standard_derivatives':
					extension = gl.getExtension( 'OES_standard_derivatives' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				case 'OES_element_index_uint':
					extension = gl.getExtension( 'OES_element_index_uint' );
					break;

				case 'EXT_blend_minmax':
					extension = gl.getExtension( 'EXT_blend_minmax' );
					break;

				case 'EXT_frag_depth':
					extension = gl.getExtension( 'EXT_frag_depth' );
					break;

			}

			if ( extension === null ) {

				console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = ( function () {

		var programIdCount = 0;

		var generateDefines = function ( defines ) {

			var value, chunk, chunks = [];

			for ( var d in defines ) {

				value = defines[ d ];
				if ( value === false ) continue;

				chunk = "#define " + d + " " + value;
				chunks.push( chunk );

			}

			return chunks.join( "\n" );

		};

		var cacheUniformLocations = function ( gl, program, identifiers ) {

			var uniforms = {};

			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

				var id = identifiers[ i ];
				uniforms[ id ] = gl.getUniformLocation( program, id );

			}

			return uniforms;

		};

		var cacheAttributeLocations = function ( gl, program, identifiers ) {

			var attributes = {};

			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

				var id = identifiers[ i ];
				attributes[ id ] = gl.getAttribLocation( program, id );

			}

			return attributes;

		};

		return function ( renderer, code, material, parameters ) {

			var _this = renderer;
			var _gl = _this.context;

			var defines = material.defines;
			var uniforms = material.__webglShader.uniforms;
			var attributes = material.attributes;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var index0AttributeName = material.index0AttributeName;

			if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0

				index0AttributeName = 'position';

			}

			var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

				shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

				shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

			}

			// console.log( "building new program " );

			//

			var customDefines = generateDefines( defines );

			//

			var program = _gl.createProgram();

			var prefix_vertex, prefix_fragment;

			if ( material instanceof THREE.RawShaderMaterial ) {

				prefix_vertex = '';
				prefix_fragment = '';

			} else {

				prefix_vertex = [

					"precision " + parameters.precision + " float;",
					"precision " + parameters.precision + " int;",

					customDefines,

					parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

					_this.gammaInput ? "#define GAMMA_INPUT" : "",
					_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

					"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
					"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
					"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
					"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

					"#define MAX_SHADOWS " + parameters.maxShadows,

					"#define MAX_BONES " + parameters.maxBones,

					parameters.map ? "#define USE_MAP" : "",
					parameters.envMap ? "#define USE_ENVMAP" : "",
					parameters.lightMap ? "#define USE_LIGHTMAP" : "",
					parameters.bumpMap ? "#define USE_BUMPMAP" : "",
					parameters.normalMap ? "#define USE_NORMALMAP" : "",
					parameters.specularMap ? "#define USE_SPECULARMAP" : "",
					parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
					parameters.vertexColors ? "#define USE_COLOR" : "",

					parameters.skinning ? "#define USE_SKINNING" : "",
					parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

					parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
					parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
					parameters.wrapAround ? "#define WRAP_AROUND" : "",
					parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
					parameters.flipSided ? "#define FLIP_SIDED" : "",

					parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
					parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
					parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
					parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

					parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

					parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
					//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",


					"uniform mat4 modelMatrix;",
					"uniform mat4 modelViewMatrix;",
					"uniform mat4 projectionMatrix;",
					"uniform mat4 viewMatrix;",
					"uniform mat3 normalMatrix;",
					"uniform vec3 cameraPosition;",

					"attribute vec3 position;",
					"attribute vec3 normal;",
					"attribute vec2 uv;",
					"attribute vec2 uv2;",

					"#ifdef USE_COLOR",

					"	attribute vec3 color;",

					"#endif",

					"#ifdef USE_MORPHTARGETS",

					"	attribute vec3 morphTarget0;",
					"	attribute vec3 morphTarget1;",
					"	attribute vec3 morphTarget2;",
					"	attribute vec3 morphTarget3;",

					"	#ifdef USE_MORPHNORMALS",

					"		attribute vec3 morphNormal0;",
					"		attribute vec3 morphNormal1;",
					"		attribute vec3 morphNormal2;",
					"		attribute vec3 morphNormal3;",

					"	#else",

					"		attribute vec3 morphTarget4;",
					"		attribute vec3 morphTarget5;",
					"		attribute vec3 morphTarget6;",
					"		attribute vec3 morphTarget7;",

					"	#endif",

					"#endif",

					"#ifdef USE_SKINNING",

					"	attribute vec4 skinIndex;",
					"	attribute vec4 skinWeight;",

					"#endif",

					""

				].join( '\n' );

				prefix_fragment = [

					"precision " + parameters.precision + " float;",
					"precision " + parameters.precision + " int;",

					( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

					customDefines,

					"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
					"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
					"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
					"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

					"#define MAX_SHADOWS " + parameters.maxShadows,

					parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

					_this.gammaInput ? "#define GAMMA_INPUT" : "",
					_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

					( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
					( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

					parameters.map ? "#define USE_MAP" : "",
					parameters.envMap ? "#define USE_ENVMAP" : "",
					parameters.lightMap ? "#define USE_LIGHTMAP" : "",
					parameters.bumpMap ? "#define USE_BUMPMAP" : "",
					parameters.normalMap ? "#define USE_NORMALMAP" : "",
					parameters.specularMap ? "#define USE_SPECULARMAP" : "",
					parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
					parameters.vertexColors ? "#define USE_COLOR" : "",

					parameters.metal ? "#define METAL" : "",
					parameters.wrapAround ? "#define WRAP_AROUND" : "",
					parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
					parameters.flipSided ? "#define FLIP_SIDED" : "",

					parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
					parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
					parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
					parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

					parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
					//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",

					"uniform mat4 viewMatrix;",
					"uniform vec3 cameraPosition;",
					""

				].join( '\n' );

			}

			var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
			var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

			_gl.attachShader( program, glVertexShader );
			_gl.attachShader( program, glFragmentShader );

			if ( index0AttributeName !== undefined ) {

				// Force a particular attribute to index 0.
				// because potentially expensive emulation is done by browser if attribute 0 is disabled.
				// And, color, for example is often automatically bound to index 0 so disabling it

				_gl.bindAttribLocation( program, 0, index0AttributeName );

			}

			_gl.linkProgram( program );

			if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

				console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
				console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
				console.error( 'gl.getError()', _gl.getError() );

			}

			if ( _gl.getProgramInfoLog( program ) !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

			}

			// clean up

			_gl.deleteShader( glVertexShader );
			_gl.deleteShader( glFragmentShader );

			// cache uniform locations

			var identifiers = [

				'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'

			];

			if ( parameters.useVertexTexture ) {

				identifiers.push( 'boneTexture' );
				identifiers.push( 'boneTextureWidth' );
				identifiers.push( 'boneTextureHeight' );

			} else {

				identifiers.push( 'boneGlobalMatrices' );

			}

			if ( parameters.logarithmicDepthBuffer ) {

				identifiers.push('logDepthBufFC');

			}


			for ( var u in uniforms ) {

				identifiers.push( u );

			}

			this.uniforms = cacheUniformLocations( _gl, program, identifiers );

			// cache attributes locations

			identifiers = [

				"position", "normal", "uv", "uv2", "tangent", "color",
				"skinIndex", "skinWeight", "lineDistance"

			];

			for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

				identifiers.push( "morphTarget" + i );

			}

			for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

				identifiers.push( "morphNormal" + i );

			}

			for ( var a in attributes ) {

				identifiers.push( a );

			}

			this.attributes = cacheAttributeLocations( _gl, program, identifiers );
			this.attributesKeys = Object.keys( this.attributes );

			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	} )();

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = ( function () {

		var addLineNumbers = function ( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		};

		return function ( gl, type, string ) {

			var shader = gl.createShader( type ); 

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );
				console.warn( addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	} )();

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function ( renderer, flares ) {

		var gl = renderer.context;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;

		var tempTexture, occlusionTexture;

		var init = function () {

			var vertices = new Float32Array( [
				-1, -1,  0, 0,
				 1, -1,  1, 0,
				 1,  1,  1, 1,
				-1,  1,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();

			gl.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

			var shader;

			if ( hasVertexTexture ) {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			} else {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"precision mediump float;",

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			}

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			}

			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};

		};

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;

			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );

			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			gl.enableVertexAttribArray( attributes.vertex );
			gl.enableVertexAttribArray( attributes.uv );

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/unforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.disable( gl.CULL_FACE );
			gl.depthMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];
				
				tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition )

				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

				// screen cull

				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {

					// save current RGB to temp texture

					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					gl.disable( gl.BLEND );
					gl.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					gl.activeTexture( gl.TEXTURE0 );
					gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					gl.disable( gl.DEPTH_TEST );

					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition )

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					gl.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewportHeight;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			gl.enable( gl.CULL_FACE );
			gl.enable( gl.DEPTH_TEST );
			gl.depthMask( true );

			renderer.resetGLState();

		};

		function createProgram ( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

		var _gl = _renderer.context;

		var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),

		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),

		_matrixPosition = new THREE.Vector3(),
		
		_renderList = [];

		// init

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader
		 } );

		_depthMaterialMorph = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true
		} );

		_depthMaterialSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			skinning: true
		} );

		_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true,
			skinning: true
		} );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

		this.render = function ( scene, camera ) {

			if ( _renderer.shadowMapEnabled === false ) return;

			var i, il, j, jl, n,

			shadowMap, shadowMatrix, shadowCamera,
			program, buffer, material,
			webglObject, object, light,

			lights = [],
			k = 0,

			fog = null;

			// set GL state for depth map

			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );

			_gl.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );

			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.setDepthTest( true );

			// preprocess lights
			// 	- skip lights that are not casting shadows
			//	- create virtual lights for cascaded shadow maps

			for ( i = 0, il = _lights.length; i < il; i ++ ) {

				light = _lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

					for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

						var virtualLight;

						if ( ! light.shadowCascadeArray[ n ] ) {

							virtualLight = createVirtualLight( light, n );
							virtualLight.originalCamera = camera;

							var gyro = new THREE.Gyroscope();
							gyro.position.copy( light.shadowCascadeOffset );

							gyro.add( virtualLight );
							gyro.add( virtualLight.target );

							camera.add( gyro );

							light.shadowCascadeArray[ n ] = virtualLight;

							console.log( "Created virtualLight", virtualLight );

						} else {

							virtualLight = light.shadowCascadeArray[ n ];

						}

						updateVirtualLight( light, n );

						lights[ k ] = virtualLight;
						k ++;

					}

				} else {

					lights[ k ] = light;
					k ++;

				}

			}

			// render depth map

			for ( i = 0, il = lights.length; i < il; i ++ ) {

				light = lights[ i ];

				if ( ! light.shadowMap ) {

					var shadowFilter = THREE.LinearFilter;

					if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

					light.shadowMatrix = new THREE.Matrix4();

				}

				if ( ! light.shadowCamera ) {

					if ( light instanceof THREE.SpotLight ) {

						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

					} else if ( light instanceof THREE.DirectionalLight ) {

						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

					} else {

						console.error( "Unsupported light type for shadow" );
						continue;

					}

					scene.add( light.shadowCamera );

					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				}

				if ( light.shadowCameraVisible && ! light.cameraHelper ) {

					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					scene.add( light.cameraHelper );

				}

				if ( light.isVirtual && virtualLight.originalCamera == camera ) {

					updateShadowCamera( camera, light );

				}

				shadowMap = light.shadowMap;
				shadowMatrix = light.shadowMatrix;
				shadowCamera = light.shadowCamera;

				//

				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();

				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				//

				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// render shadow map

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, scene, shadowCamera );


				// render regular objects

				var objectMaterial, useMorphing, useSkinning;

				for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

					webglObject = _renderList[ j ];

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					_renderer.setMaterialFaces( objectMaterial );

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

					}

				}

				// set matrices and render immediate objects

				for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

					webglObject = _webglObjectsImmediate[ j ];
					object = webglObject.object;

					if ( object.visible && object.castShadow ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

					}

				}

			}

			// restore GL state

			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();

			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );

			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.resetGLState();

		};

		function projectObject( scene, object, shadowCamera ){

			if ( object.visible ) {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[ i ];

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( webglObject );

					}

				}

				for ( var i = 0, l = object.children.length; i < l; i ++ ) {

					projectObject( scene, object.children[ i ], shadowCamera );

				}

			}

		}

		function createVirtualLight( light, cascade ) {

			var virtualLight = new THREE.DirectionalLight();

			virtualLight.isVirtual = true;

			virtualLight.onlyShadow = true;
			virtualLight.castShadow = true;

			virtualLight.shadowCameraNear = light.shadowCameraNear;
			virtualLight.shadowCameraFar = light.shadowCameraFar;

			virtualLight.shadowCameraLeft = light.shadowCameraLeft;
			virtualLight.shadowCameraRight = light.shadowCameraRight;
			virtualLight.shadowCameraBottom = light.shadowCameraBottom;
			virtualLight.shadowCameraTop = light.shadowCameraTop;

			virtualLight.shadowCameraVisible = light.shadowCameraVisible;

			virtualLight.shadowDarkness = light.shadowDarkness;

			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
			virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
			virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

			virtualLight.pointsWorld = [];
			virtualLight.pointsFrustum = [];

			var pointsWorld = virtualLight.pointsWorld,
				pointsFrustum = virtualLight.pointsFrustum;

			for ( var i = 0; i < 8; i ++ ) {

				pointsWorld[ i ] = new THREE.Vector3();
				pointsFrustum[ i ] = new THREE.Vector3();

			}

			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];

			pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
			pointsFrustum[ 1 ].set(  1, - 1, nearZ );
			pointsFrustum[ 2 ].set( - 1,  1, nearZ );
			pointsFrustum[ 3 ].set(  1,  1, nearZ );

			pointsFrustum[ 4 ].set( - 1, - 1, farZ );
			pointsFrustum[ 5 ].set(  1, - 1, farZ );
			pointsFrustum[ 6 ].set( - 1,  1, farZ );
			pointsFrustum[ 7 ].set(  1,  1, farZ );

			return virtualLight;

		}

		// Synchronize virtual light with the original light

		function updateVirtualLight( light, cascade ) {

			var virtualLight = light.shadowCascadeArray[ cascade ];

			virtualLight.position.copy( light.position );
			virtualLight.target.position.copy( light.target.position );
			virtualLight.lookAt( virtualLight.target );

			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
			virtualLight.shadowDarkness = light.shadowDarkness;

			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];

			var pointsFrustum = virtualLight.pointsFrustum;

			pointsFrustum[ 0 ].z = nearZ;
			pointsFrustum[ 1 ].z = nearZ;
			pointsFrustum[ 2 ].z = nearZ;
			pointsFrustum[ 3 ].z = nearZ;

			pointsFrustum[ 4 ].z = farZ;
			pointsFrustum[ 5 ].z = farZ;
			pointsFrustum[ 6 ].z = farZ;
			pointsFrustum[ 7 ].z = farZ;

		}

		// Fit shadow camera's ortho frustum to camera frustum

		function updateShadowCamera( camera, light ) {

			var shadowCamera = light.shadowCamera,
				pointsFrustum = light.pointsFrustum,
				pointsWorld = light.pointsWorld;

			_min.set( Infinity, Infinity, Infinity );
			_max.set( - Infinity, - Infinity, - Infinity );

			for ( var i = 0; i < 8; i ++ ) {

				var p = pointsWorld[ i ];

				p.copy( pointsFrustum[ i ] );
				p.unproject( camera );

				p.applyMatrix4( shadowCamera.matrixWorldInverse );

				if ( p.x < _min.x ) _min.x = p.x;
				if ( p.x > _max.x ) _max.x = p.x;

				if ( p.y < _min.y ) _min.y = p.y;
				if ( p.y > _max.y ) _max.y = p.y;

				if ( p.z < _min.z ) _min.z = p.z;
				if ( p.z > _max.z ) _max.z = p.z;

			}

			shadowCamera.left = _min.x;
			shadowCamera.right = _max.x;
			shadowCamera.top = _max.y;
			shadowCamera.bottom = _min.y;

			// can't really fit near/far
			//shadowCamera.near = _min.z;
			//shadowCamera.far = _max.z;

			shadowCamera.updateProjectionMatrix();

		}

		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use for shadow maps

		function getObjectMaterial( object ) {

			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;

		};

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function ( renderer, sprites ) {

		var gl = renderer.context;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;
		
		var init = function () {

			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};

			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),

				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),

				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),

				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;

		};

		this.render = function ( scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			gl.enableVertexAttribArray( attributes.position );
			gl.enableVertexAttribArray( attributes.uv );

			gl.disable( gl.CULL_FACE );
			gl.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			gl.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog instanceof THREE.Fog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog instanceof THREE.FogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );

				if ( sprite.renderDepth === null ) {

					sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

				} else {

					sprite.z = sprite.renderDepth;

				}

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

				scale[ 0 ] = sprite.scale.x;
				scale[ 1 ] = sprite.scale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				renderer.setDepthTest( material.depthTest );
				renderer.setDepthWrite( material.depthWrite );

				if ( material.map && material.map.image && material.map.image.width ) {

					renderer.setTexture( material.map, 0 );

				} else {

					renderer.setTexture( texture, 0 );

				}

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			}

			// restore gl

			gl.enable( gl.CULL_FACE );
			
			renderer.resetGLState();

		};

		function createProgram () {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

					'vUV = uvOffset + uv * uvScale;',

					'vec2 alignedPosition = position * scale;',

					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

					'vec4 finalPosition;',

					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',

					'gl_Position = finalPosition;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

					'vec4 texture = texture2D( map, vUV );',

					'if ( texture.a < alphaTest ) discard;',

					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

					'if ( fogType > 0 ) {',

						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',

						'if ( fogType == 1 ) {',

							'fogFactor = smoothstep( fogNear, fogFar, depth );',

						'} else {',

							'const float LOG2 = 1.442695;',
							'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

						'}',

						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

					'}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		};

		function painterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		};

	};

	// File:src/extras/GeometryUtils.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if ( geometry2 instanceof THREE.Mesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	// File:src/extras/ImageUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.Texture( undefined, mapping );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, undefined, function ( event ) {

				if ( onError ) onError( event );

			} );

			texture.sourceFile = url;

			return texture;

		},

		loadTextureCube: function ( array, mapping, onLoad, onError ) {

			var images = [];

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.CubeTexture( images, mapping );

			// no flipping needed for cube textures

			texture.flipY = false;

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( array[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded += 1;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				} );

			}

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

		},

		getNormalMap: function ( image, depth ) {

			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

			var cross = function ( a, b ) {

				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

			}

			var subtract = function ( a, b ) {

				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

			}

			var normalize = function ( a ) {

				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

			}

			depth = depth | 1;

			var width = image.width;
			var height = image.height;

			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );

			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;

			for ( var x = 0; x < width; x ++ ) {

				for ( var y = 0; y < height; y ++ ) {

					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;

					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

					var normals = [];
					var num_points = points.length;

					for ( var i = 0; i < num_points; i ++ ) {

						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );

					}

					var normal = [ 0, 0, 0 ];

					for ( var i = 0; i < normals.length; i ++ ) {

						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];

					}

					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;

					var idx = ( y * width + x ) * 4;

					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;

				}

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		},

		generateDataTexture: function ( width, height, color ) {

			var size = width * height;
			var data = new Uint8Array( 3 * size );

			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );

			for ( var i = 0; i < size; i ++ ) {

				data[ i * 3 ] 	   = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;

			}

			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;

			return texture;

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new THREE.Object3D();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new THREE.Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );

			scene.remove( child );
			parent.add( child );

		}

	};

	// File:src/extras/FontUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 * 	typeface.js and canvastext
	 * 		For converting fonts and rendering with javascript
	 *		http://typeface.neocracy.org
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */

	THREE.FontUtils = {

		faces: {},

		// Just for now. face[weight][style]

		face: 'helvetiker',
		weight: 'normal',
		style: 'normal',
		size: 150,
		divisions: 10,

		getFace: function () {

			try {

				return this.faces[ this.face ][ this.weight ][ this.style ];

			} catch (e) {

				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

			};

		},

		loadFace: function ( data ) {

			var family = data.familyName.toLowerCase();

			var ThreeFont = this;

			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			return data;

		},

		drawText: function ( text ) {

			var characterPts = [], allPts = [];

			// RenderText

			var i, p,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;

			var fontPaths = [];

			for ( i = 0; i < length; i ++ ) {

				var path = new THREE.Path();

				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;

				fontPaths.push( ret.path );

			}

			// get the width

			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }

			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;

			//extract.paths = fontPaths;
			//extract.offset = width;

			return { paths: fontPaths, offset: width };

		},




		extractGlyphPoints: function ( c, face, scale, offset, path ) {

			var pts = [];

			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

			if ( ! glyph ) return;

			if ( glyph.o ) {

				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;

				scaleX = scale;
				scaleY = scale;

				for ( i = 0; i < length; ) {

					action = outline[ i ++ ];

					//console.log( action );

					switch ( action ) {

					case 'm':

						// Move To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;

						path.moveTo( x, y );
						break;

					case 'l':

						// Line To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
						path.lineTo( x,y );
						break;

					case 'q':

						// QuadraticCurveTo

						cpx  = outline[ i ++ ] * scaleX + offset;
						cpy  = outline[ i ++ ] * scaleY;
						cpx1 = outline[ i ++ ] * scaleX + offset;
						cpy1 = outline[ i ++ ] * scaleY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
						  }

					  }

					  break;

					case 'b':

						// Cubic Bezier Curve

						cpx  = outline[ i ++ ] *  scaleX + offset;
						cpy  = outline[ i ++ ] *  scaleY;
						cpx1 = outline[ i ++ ] *  scaleX + offset;
						cpy1 = outline[ i ++ ] *  scaleY;
						cpx2 = outline[ i ++ ] *  scaleX + offset;
						cpy2 = outline[ i ++ ] *  scaleY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

							}

						}

						break;

					}

				}
			}



			return { offset: glyph.ha * scale, path:path };
		}

	};


	THREE.FontUtils.generateShapes = function ( text, parameters ) {

		// Parameters 

		parameters = parameters || {};

		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

		var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
		var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
		var style = parameters.style !== undefined ? parameters.style : 'normal';

		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;

		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;

		// Get a Font data json object

		var data = THREE.FontUtils.drawText( text );

		var paths = data.paths;
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	};


	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */


	( function ( namespace ) {

		var EPSILON = 0.0000000001;

		// takes in an contour array and returns

		var process = function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.log( 'Warning, unable to triangulate polygon!' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s++, t++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		};

		// calculate area of the contour polygon

		var area = function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		};

		var snip = function ( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

			}

			return true;

		};


		namespace.Triangulate = process;
		namespace.Triangulate.area = area;

		return namespace;

	} )( THREE.FontUtils );

	// To use the typeface.js face files, hook up the API
	self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	THREE.typeface_js = self._typeface_js;

	// File:src/extras/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Audio = function ( listener ) {

		THREE.Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	};

	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Audio.prototype.load = function ( file ) {

		var scope = this;

		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {

			scope.context.decodeAudioData( this.response, function ( buffer ) {

				scope.source.buffer = buffer;
				scope.source.connect( scope.panner );
				scope.source.start( 0 );

			} );

		};
		request.send();

		return this;

	};

	THREE.Audio.prototype.setLoop = function ( value ) {

		this.source.loop = value;

	};

	THREE.Audio.prototype.setRefDistance = function ( value ) {

		this.panner.refDistance = value;

	};

	THREE.Audio.prototype.setRolloffFactor = function ( value ) {

		this.panner.rolloffFactor = value;

	};

	THREE.Audio.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();

		return function ( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )();

	// File:src/extras/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call( this );

		this.type = 'AudioListener';

		this.context = new ( window.AudioContext || window.webkitAudioContext )();

	};

	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );

	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();
		var velocity = new THREE.Vector3();

		var positionPrev = new THREE.Vector3();

		return function ( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
			velocity.subVectors( position, positionPrev );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );
			listener.setVelocity( velocity.x, velocity.y, velocity.z );

			positionPrev.copy( position );

		};

	} )();

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	THREE.Curve.prototype.getPoint = function ( t ) {

		console.log( "Warning, getPoint() not implemented!" );
		return null;

	};

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	THREE.Curve.prototype.getPointAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	};

	// Get sequence of points using getPoint( t )

	THREE.Curve.prototype.getPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	};

	// Get sequence of points using getPointAt( u )

	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	};

	// Get total curve arc length

	THREE.Curve.prototype.getLength = function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	};

	// Get list of cumulative segment lengths

	THREE.Curve.prototype.getLengths = function ( divisions ) {

		if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length == divisions + 1 )
			&& ! this.needsUpdate) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	};


	THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = true;
		this.getLengths();
	};

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;
				continue;

			} else if ( comparison > 0 ) {

				high = i - 1;
				continue;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] == targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolatation between two points

		var lengthBefore = arcLengths[ i ];
	    var lengthAfter = arcLengths[ i + 1 ];

	    var segmentLength = lengthAfter - lengthBefore;

	    // determine where we are between the 'before' and 'after' points

	    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

	    // add that fractional amount to t

	    var t = ( i + segmentFraction ) / ( il -1 );

		return t;

	};

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	THREE.Curve.prototype.getTangent = function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub(pt1);
		return vec.normalize();

	};


	THREE.Curve.prototype.getTangentAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	};





	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Curve.Utils = {

		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

			return - 3 * p0 * (1 - t) * (1 - t)  +
				3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
				6 * t *  p2 * (1-t) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function ( t, p0, p1, p2, p3 ) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3  t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};


	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function ( constructor, getPointFunc ) {

		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];
		this.bends = [];
		
		this.autoClose = false; // Automatically closes the path
	};

	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

	THREE.CurvePath.prototype.add = function ( curve ) {

		this.curves.push( curve );

	};

	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};

	THREE.CurvePath.prototype.closePath = function() {
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[0].getPoint(0);
		var endPoint = this.curves[this.curves.length-1].getPoint(1);
		
		if (! startPoint.equals(endPoint)) {
			this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
		}
		
	};

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	THREE.CurvePath.prototype.getPoint = function( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

				break;
			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	};

	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/


	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	THREE.CurvePath.prototype.getLength = function() {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	};

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	THREE.CurvePath.prototype.getCurveLengths = function() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

			return this.cacheLengths;

		};

		// Get length of subsurve
		// Push sums into cached array

		var lengths = [], sums = 0;
		var i, il = this.curves.length;

		for ( i = 0; i < il; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	};



	// Returns min and max coordinates

	THREE.CurvePath.prototype.getBoundingBox = function () {

		var points = this.getPoints();

		var maxX, maxY, maxZ;
		var minX, minY, minZ;

		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;

		var p, i, il, sum;

		var v3 = points[0] instanceof THREE.Vector3;

		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

		for ( i = 0, il = points.length; i < il; i ++ ) {

			p = points[ i ];

			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;

			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;

			if ( v3 ) {

				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;

			}

			sum.add( p );

		}

		var ret = {

			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY

		};

		if ( v3 ) {

			ret.maxZ = maxZ;
			ret.minZ = minZ;

		}

		return ret;

	};

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );

	};

	// Generate geometry from equidistance sampling along the path

	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );

	};

	THREE.CurvePath.prototype.createGeometry = function( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < points.length; i ++ ) {

			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

		}

		return geometry;

	};


	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/

	// Wrap path / Bend modifiers?

	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

		this.bends.push( bendpath );

	};

	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

		var oldPts = this.getSpacedPoints( segments );

		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

		var bounds = this.getBoundingBox();

		var i, il, p, oldX, oldY, xNorm;

		for ( i = 0, il = oldPts.length; i < il; i ++ ) {

			p = oldPts[ i ];

			oldX = p.x;
			oldY = p.y;

			xNorm = oldX / bounds.maxX;

			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

			xNorm = path.getUtoTmapping( xNorm, oldX );

			// check for out of bounds?

			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;

		}

		return oldPts;

	};


	// File:src/extras/core/Gyroscope.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Gyroscope = function () {

		THREE.Object3D.call( this );

	};

	THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

	THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

		var translationObject = new THREE.Vector3();
		var quaternionObject = new THREE.Quaternion();
		var scaleObject = new THREE.Vector3();

		var translationWorld = new THREE.Vector3();
		var quaternionWorld = new THREE.Quaternion();
		var scaleWorld = new THREE.Vector3();

		return function ( force ) {

			this.matrixAutoUpdate && this.updateMatrix();

			// update matrixWorld

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent ) {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
					this.matrix.decompose( translationObject, quaternionObject, scaleObject );

					this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


				} else {

					this.matrixWorld.copy( this.matrix );

				}


				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		};
		
	}() );

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function ( points ) {

		THREE.CurvePath.call(this);

		this.actions = [];

		if ( points ) {

			this.fromPoints( points );

		}

	};

	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

	THREE.PathActions = {

		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	THREE.Path.prototype.fromPoints = function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

			this.lineTo( vectors[ v ].x, vectors[ v ].y );

		};

	};

	// startPath() endPath()?

	THREE.Path.prototype.moveTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

	};

	THREE.Path.prototype.lineTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

	};

	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

	};

	// FUTURE: Change the API or follow canvas API?

	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc(aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };

	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	 };

	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };


	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var args = Array.prototype.slice.call( arguments );
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise );
		this.curves.push( curve );

		var lastPoint = curve.getPoint(1);
		args.push(lastPoint.x);
		args.push(lastPoint.y);

		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

	 };

	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }

		return points;

	};

	/* Return an array of vectors based on contour of the path */

	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

		if (this.useSpacedPoints) {
			console.log('tata');
			return this.getSpacedPoints( divisions, closedPath );
		}

		divisions = divisions || 12;

		var points = [];

		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;

		for ( i = 0, il = this.actions.length; i < il; i ++ ) {

			item = this.actions[ i ];

			action = item.action;
			args = item.args;

			switch( action ) {

			case THREE.PathActions.MOVE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.LINE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.QUADRATIC_CURVE_TO:

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.BEZIER_CURVE_TO:

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.CSPLINE_THRU:

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) ) ;

				}

				break;

			case THREE.PathActions.ARC:

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

			  break;
			  
			case THREE.PathActions.ELLIPSE:

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

			  break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1];
		var EPSILON = 0.0000000001;
		if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
				 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
			points.splice( points.length - 1, 1);
		if ( closedPath ) {

			points.push( points[ 0 ] );

		}

		return points;

	};

	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//

	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var i, il, item, action, args;

			var subPaths = [], lastPath = new THREE.Path();

			for ( i = 0, il = inActions.length; i < il; i ++ ) {

				item = inActions[ i ];

				args = item.args;
				action = item.action;

				if ( action == THREE.PathActions.MOVE_TO ) {

					if ( lastPath.actions.length != 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;
		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
			}

			//console.log("shape", shapes);

			return shapes;
		};

		function isPointInsidePolygon( inPt, inPolygon ) {
			var EPSILON = 0.0000000001;

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
					if ( edgeDy < 0 ) {
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y == edgeLowPt.y ) {
						if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
					} else {
						var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
						if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
					}
				} else {		// parallel or colinear
					if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
					// egde lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
				}
			}

			return	inside;
		}


		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length == 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length == 1) {

			tmpPath = subPaths[0];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);
		
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[mainIdx] = undefined;
		newShapeHoles[mainIdx] = [];

		var i, il;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = THREE.Shape.Utils.isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

				newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[mainIdx].s.actions = tmpPath.actions;
				newShapes[mainIdx].s.curves = tmpPath.curves;
				
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[mainIdx] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {
			var ambigious = false;
			var toChange = [];

			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				betterShapeHoles[sIdx] = [];
			}
			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				var sh = newShapes[sIdx];
				var sho = newShapeHoles[sIdx];
				for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
					var ho = sho[hIdx];
					var hole_unassigned = true;
					for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
						if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
							if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
								hole_unassigned = false;
								betterShapeHoles[s2Idx].push( ho );
							} else {
								ambigious = true;
							}
						}
					}
					if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
				}
			}
			// console.log("ambigious: ", ambigious);
			if ( toChange.length > 0 ) {
				// console.log("to change: ", toChange);
				if (! ambigious)	newShapeHoles = betterShapeHoles;
			}
		}

		var tmpHoles, j, jl;
		for ( i = 0, il = newShapes.length; i < il; i ++ ) {
			tmpShape = newShapes[i].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[i];
			for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
				tmpShape.holes.push( tmpHoles[j].h );
			}
		}

		//console.log("shape", shapes);

		return shapes;

	};

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply( this, arguments );
		this.holes = [];

	};

	THREE.Shape.prototype = Object.create( THREE.Path.prototype );

	// Convenience method to return ExtrudeGeometry

	THREE.Shape.prototype.extrude = function ( options ) {

		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;

	};

	// Convenience method to return ShapeGeometry

	THREE.Shape.prototype.makeGeometry = function ( options ) {

		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;

	};

	// Get points of holes

	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

		}

		return holesPts;

	};

	// Get points of holes (spaced by regular distance)

	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

		}

		return holesPts;

	};


	// Get points of shape and holes (keypoints based on segments parameter)

	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

		return {

			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	};

	THREE.Shape.prototype.extractPoints = function ( divisions ) {

		if (this.useSpacedPoints) {
			return this.extractAllSpacedPoints(divisions);
		}

		return this.extractAllPoints(divisions);

	};

	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };

	// Get points of shape and holes (spaced by regular distance)

	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

		return {

			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )

		};

	};

	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Shape.Utils = {

		triangulateShape: function ( contour, holes ) {

			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
				// inOtherPt needs to be colinear to the inSegment
				if ( inSegPt1.x != inSegPt2.x ) {
					if ( inSegPt1.x < inSegPt2.x ) {
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
					} else {
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
					}
				} else {
					if ( inSegPt1.y < inSegPt2.y ) {
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
					} else {
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
					}
				}
			}

			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
				var EPSILON = 0.0000000001;

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if ( Math.abs(limit) > EPSILON ) {			// not parallel

					var perpSeg2;
					if ( limit > 0 ) {
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
					} else {
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 == 0 ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return  [ inSeg1Pt1 ];
					}
					if ( perpSeg2 == limit ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return  [ inSeg1Pt2 ];
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
					if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

				} else {		// parallel or colinear
					if ( ( perpSeg1 != 0 ) ||
						 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

					// they are collinear or degenerate
					var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
					var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
						if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
							 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
						return  [ inSeg1Pt1 ];                 					// they are the same point
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
						if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return  [ inSeg1Pt1 ];
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
						if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return  [ inSeg2Pt1 ];
					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if (seg1dx != 0) {		// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
						}
					} else {				// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
						}
					}
					if ( seg1minVal <= seg2minVal ) {
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal == seg2minVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
					} else {
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal == seg2maxVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
					}
				}
			}

			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
				// The order of legs is important

				var EPSILON = 0.0000000001;

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

				if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if ( from2toAngle > 0 ) {				// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
					} else {								// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
					}
				} else {										// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
				}
			}


			function removeHoles( contour, holes ) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

					insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
					}

					return	true;
				}

				function intersectsShapeEdge( inShapePt, inHolePt ) {
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
						nextIdx = sIdx+1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}

					return	false;
				}

				var indepHoles = [];

				function intersectsHoleEdge( inShapePt, inHolePt ) {
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
						chkHole = holes[indepHoles[ihIdx]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
							nextIdx = hIdx+1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
							if ( intersection.length > 0 )		return	true;
						}
					}
					return	false;
				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					indepHoles.push( h );

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
					counter --;
					if ( counter < 0 ) {
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;

						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
							holeIdx = indepHoles[h];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[cutKey] !== undefined )			continue;

							hole = holes[holeIdx];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
								holePt = hole[ h2 ];
								if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

								holeIndex = h2;
								indepHoles.splice(h,1);

								tmpShape1 = shape.slice( 0, shapeIndex+1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex+1 );

								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

							failedCuts[cutKey] = true;			// remember failure
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
					}
				}

				return shape; 			/* shape with no holes */
			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				Array.prototype.push.apply( allpoints, holes[h] );

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for ( i = 0, il = allpoints.length; i < il; i ++ ) {

				key = allpoints[ i ].x + ":" + allpoints[ i ].y;

				if ( allPointsMap[ key ] !== undefined ) {

					console.log( "Duplicate point", key );

				}

				allPointsMap[ key ] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );

			var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for ( i = 0, il = triangles.length; i < il; i ++ ) {

				face = triangles[ i ];

				for ( f = 0; f < 3; f ++ ) {

					key = face[ f ].x + ":" + face[ f ].y;

					index = allPointsMap[ key ];

					if ( index !== undefined ) {

						face[ f ] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function ( pts ) {

			return THREE.FontUtils.Triangulate.area( pts ) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * p;

		},

		b2p1: function ( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		},

		b2p2: function ( t, p ) {

			return t * t * p;

		},

		b2: function ( t, p0, p1, p2 ) {

			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

		},

		// Cubic Bezier Functions

		b3p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		},

		b3p1: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		},

		b3p2: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		},

		b3p3: function ( t, p ) {

			return t * t * t * p;

		},

		b3: function ( t, p0, p1, p2, p3 ) {

			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

		}

	};


	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

	THREE.LineCurve.prototype.getPoint = function ( t ) {

		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar( t ).add( this.v1 );

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function ( u ) {

		return this.getPoint( u );

	};

	THREE.LineCurve.prototype.getTangent = function( t ) {

		var tangent = this.v2.clone().sub(this.v1);

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

		return vector;

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

		// returns unit vector

		return vector.normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

		var tx, ty;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		return new THREE.Vector2( tx, ty );

	};

	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

		var tx, ty;

		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();

		return tangent;

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

	THREE.SplineCurve.prototype.getPoint = function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
		var point1 = points[ intPoint ]
		var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]
		var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

		return vector;

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

	};

	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

	THREE.EllipseCurve.prototype.getPoint = function ( t ) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

		var angle;

		if ( this.aClockwise === true ) {

			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}
		
		var vector = new THREE.Vector2();

		vector.x = this.aX + this.xRadius * Math.cos( angle );
		vector.y = this.aY + this.yRadius * Math.sin( angle );

		return vector;

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	};

	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function ( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

			return vector;

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

			return vector;

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/animation/AnimationHandler.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 */

	THREE.AnimationHandler = {

		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,

		//

		add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
		get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
		remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

		//

		animations: [],

		init: function ( data ) {

			if ( data.initialized === true ) return;

			// loop through all keys

			for ( var h = 0; h < data.hierarchy.length; h ++ ) {

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					// remove minus times

					if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

						 data.hierarchy[ h ].keys[ k ].time = 0;

					}

					// create quaternions

					if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

					}

				}

				// prepare morph target keys

				if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

					// get all used

					var usedMorphTargets = {};

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = - 1;

						}

					}

					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


					// set all used on all frames

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						var influences = {};

						for ( var morphTargetName in usedMorphTargets ) {

							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;

								}

							}

							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

								influences[ morphTargetName ] = 0;

							}

						}

						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

					}

				}


				// remove all keys that are on the same time

				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;

					}

				}


				// set index

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					data.hierarchy[ h ].keys[ k ].index = k;

				}

			}

			data.initialized = true;

			return data;

		},

		parse: function ( root ) {

			var parseRecurseHierarchy = function ( root, hierarchy ) {

				hierarchy.push( root );

				for ( var c = 0; c < root.children.length; c ++ )
					parseRecurseHierarchy( root.children[ c ], hierarchy );

			};

			// setup hierarchy

			var hierarchy = [];

			if ( root instanceof THREE.SkinnedMesh ) {

				for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

					hierarchy.push( root.skeleton.bones[ b ] );

				}

			} else {

				parseRecurseHierarchy( root, hierarchy );

			}

			return hierarchy;

		},

		play: function ( animation ) {

			if ( this.animations.indexOf( animation ) === - 1 ) {

				this.animations.push( animation );

			}

		},

		stop: function ( animation ) {

			var index = this.animations.indexOf( animation );

			if ( index !== - 1 ) {

				this.animations.splice( index, 1 );

			}

		},

		update: function ( deltaTimeMS ) {

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].resetBlendWeights( );

			}

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].update( deltaTimeMS );

			}

		}

	};

	// File:src/extras/animation/Animation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Animation = function ( root, data ) {

		this.root = root;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );

		this.currentTime = 0;
		this.timeScale = 1;

		this.isPlaying = false;
		this.loop = true;
		this.weight = 0;

		this.interpolationType = THREE.AnimationHandler.LINEAR;

	};


	THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ];


	THREE.Animation.prototype.play = function ( startTime, weight ) {

		this.currentTime = startTime !== undefined ? startTime : 0;
		this.weight = weight !== undefined ? weight: 1;

		this.isPlaying = true;

		this.reset();

		THREE.AnimationHandler.play( this );

	};


	THREE.Animation.prototype.stop = function() {

		this.isPlaying = false;

		THREE.AnimationHandler.stop( this );

	};

	THREE.Animation.prototype.reset = function () {

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];

			object.matrixAutoUpdate = true;

			if ( object.animationCache === undefined ) {

				object.animationCache = {
					animations: {},
					blending: {
						positionWeight: 0.0,
						quaternionWeight: 0.0,
						scaleWeight: 0.0
					}
				};
			}

			if ( object.animationCache.animations[this.data.name] === undefined ) {

				object.animationCache.animations[this.data.name] = {};
				object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.animations[this.data.name].originalMatrix = object.matrix;

			}

			var animationCache = object.animationCache.animations[this.data.name];

			// Get keys to match our current time

			for ( var t = 0; t < 3; t ++ ) {

				var type = this.keyTypes[ t ];

				var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
				var nextKey = this.getNextKeyWith( type, h, 1 );

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

				}

				animationCache.prevKey[ type ] = prevKey;
				animationCache.nextKey[ type ] = nextKey;

			}

		}

	};

	THREE.Animation.prototype.resetBlendWeights = function () {

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];

			if ( object.animationCache !== undefined ) {

				object.animationCache.blending.positionWeight = 0.0;
				object.animationCache.blending.quaternionWeight = 0.0;
				object.animationCache.blending.scaleWeight = 0.0;

			}

		}

	};

	THREE.Animation.prototype.update = (function(){

		var points = [];
		var target = new THREE.Vector3();
		var newVector = new THREE.Vector3();
		var newQuat = new THREE.Quaternion();

		// Catmull-Rom spline

		var interpolateCatmullRom = function ( points, scale ) {

			var c = [], v3 = [],
			point, intPoint, weight, w2, w3,
			pa, pb, pc, pd;

			point = ( points.length - 1 ) * scale;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
			c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

			pa = points[ c[ 0 ] ];
			pb = points[ c[ 1 ] ];
			pc = points[ c[ 2 ] ];
			pd = points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
			v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
			v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

			return v3;

		};

		var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		};

		return function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta * this.timeScale;

			if ( this.weight === 0 )
				return;

			//

			var duration = this.data.length;

			if ( this.currentTime > duration || this.currentTime < 0 ) {

				if ( this.loop ) {

					this.currentTime %= duration;

					if ( this.currentTime < 0 )
						this.currentTime += duration;

					this.reset();

				} else {

					this.stop();
					return;

				}

			}

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var animationCache = object.animationCache.animations[this.data.name];
				var blending = object.animationCache.blending;

				// loop through pos/rot/scl

				for ( var t = 0; t < 3; t ++ ) {

					// get keys

					var type    = this.keyTypes[ t ];
					var prevKey = animationCache.prevKey[ type ];
					var nextKey = animationCache.nextKey[ type ];

					if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
						( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

						prevKey = this.data.hierarchy[ h ].keys[ 0 ];
						nextKey = this.getNextKeyWith( type, h, 1 );

						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

						}

						animationCache.prevKey[ type ] = prevKey;
						animationCache.nextKey[ type ] = nextKey;

					}

					object.matrixAutoUpdate = true;
					object.matrixWorldNeedsUpdate = true;

					var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

					var prevXYZ = prevKey[ type ];
					var nextXYZ = nextKey[ type ];

					if ( scale < 0 ) scale = 0;
					if ( scale > 1 ) scale = 1;

					// interpolate

					if ( type === "pos" ) {

						if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

							// blend
							var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
							object.position.lerp( newVector, proportionalWeight );
							blending.positionWeight += this.weight;

						} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
									this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

							points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
							points[ 1 ] = prevXYZ;
							points[ 2 ] = nextXYZ;
							points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

							scale = scale * 0.33 + 0.33;

							var currentPoint = interpolateCatmullRom( points, scale );
							var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
							blending.positionWeight += this.weight;

							// blend

							var vector = object.position;
							
							vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
							vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
							vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

							if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

								var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

								target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
								target.sub( vector );
								target.y = 0;
								target.normalize();

								var angle = Math.atan2( target.x, target.z );
								object.rotation.set( 0, angle, 0 );

							}

						}

					} else if ( type === "rot" ) {

						THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

						// Avoid paying the cost of an additional slerp if we don't have to
						if ( blending.quaternionWeight === 0 ) {

							object.quaternion.copy(newQuat);
							blending.quaternionWeight = this.weight;

						} else {

							var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
							THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
							blending.quaternionWeight += this.weight;

						}

					} else if ( type === "scl" ) {

						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

						var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
						object.scale.lerp( newVector, proportionalWeight );
						blending.scaleWeight += this.weight;

					}

				}

			}

			return true;

		};

	})();





	// Get next key with

	THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

		var keys = this.data.hierarchy[ h ].keys;

		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

			key = key < keys.length - 1 ? key : keys.length - 1;

		} else {

			key = key % keys.length;

		}

		for ( ; key < keys.length; key ++ ) {

			if ( keys[ key ][ type ] !== undefined ) {

				return keys[ key ];

			}

		}

		return this.data.hierarchy[ h ].keys[ 0 ];

	};

	// Get previous key with

	THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

		var keys = this.data.hierarchy[ h ].keys;

		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

			key = key > 0 ? key : 0;

		} else {

			key = key >= 0 ? key : key + keys.length;

		}


		for ( ; key >= 0; key -- ) {

			if ( keys[ key ][ type ] !== undefined ) {

				return keys[ key ];

			}

		}

		return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

	};

	// File:src/extras/animation/KeyFrameAnimation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */

	THREE.KeyFrameAnimation = function ( data ) {

		this.root = data.node;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( this.root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;

		// initialize to first keyframes

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				obj = this.hierarchy[h];

			if ( keys.length && sids ) {

				for ( var s = 0; s < sids.length; s ++ ) {

					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );

					if ( next ) {

						next.apply( sid );

					}

				}

				obj.matrixAutoUpdate = false;
				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

	};


	THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

		this.currentTime = startTime !== undefined ? startTime : 0;

		if ( this.isPlaying === false ) {

			this.isPlaying = true;

			// reset key cache

			var h, hl = this.hierarchy.length,
				object,
				node;

			for ( h = 0; h < hl; h ++ ) {

				object = this.hierarchy[ h ];
				node = this.data.hierarchy[ h ];

				if ( node.animationCache === undefined ) {

					node.animationCache = {};
					node.animationCache.prevKey = null;
					node.animationCache.nextKey = null;
					node.animationCache.originalMatrix = object.matrix;

				}

				var keys = this.data.hierarchy[h].keys;

				if (keys.length) {

					node.animationCache.prevKey = keys[ 0 ];
					node.animationCache.nextKey = keys[ 1 ];

					this.startTime = Math.min( keys[0].time, this.startTime );
					this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

				}

			}

			this.update( 0 );

		}

		this.isPaused = false;

		THREE.AnimationHandler.play( this );

	};


	THREE.KeyFrameAnimation.prototype.stop = function() {

		this.isPlaying = false;
		this.isPaused  = false;

		THREE.AnimationHandler.stop( this );

		// reset JIT matrix and remove cache

		for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
			
			var obj = this.hierarchy[ h ];
			var node = this.data.hierarchy[ h ];

			if ( node.animationCache !== undefined ) {

				var original = node.animationCache.originalMatrix;

				original.copy( obj.matrix );
				obj.matrix = original;

				delete node.animationCache;

			}

		}

	};


	// Update

	THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

		if ( this.isPlaying === false ) return;

		this.currentTime += delta * this.timeScale;

		//

		var duration = this.data.length;

		if ( this.loop === true && this.currentTime > duration ) {

			this.currentTime %= duration;

		}

		this.currentTime = Math.min( this.currentTime, duration );

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];
			var node = this.data.hierarchy[ h ];

			var keys = node.keys,
				animationCache = node.animationCache;


			if ( keys.length ) {

				var prevKey = animationCache.prevKey;
				var nextKey = animationCache.nextKey;

				if ( nextKey.time <= this.currentTime ) {

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = keys[ prevKey.index + 1 ];

					}

					animationCache.prevKey = prevKey;
					animationCache.nextKey = nextKey;

				}

				if ( nextKey.time >= this.currentTime ) {

					prevKey.interpolate( nextKey, this.currentTime );

				} else {

					prevKey.interpolate( nextKey, nextKey.time );

				}

				this.data.hierarchy[ h ].node.updateMatrix();
				object.matrixWorldNeedsUpdate = true;

			}

		}

	};

	// Get next key with

	THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

		var keys = this.data.hierarchy[ h ].keys;
		key = key % keys.length;

		for ( ; key < keys.length; key ++ ) {

			if ( keys[ key ].hasTarget( sid ) ) {

				return keys[ key ];

			}

		}

		return keys[ 0 ];

	};

	// Get previous key with

	THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

		var keys = this.data.hierarchy[ h ].keys;
		key = key >= 0 ? key : key + keys.length;

		for ( ; key >= 0; key -- ) {

			if ( keys[ key ].hasTarget( sid ) ) {

				return keys[ key ];

			}

		}

		return keys[ keys.length - 1 ];

	};

	// File:src/extras/animation/MorphAnimation.js

	/**
	 * @author mrdoob / http://mrdoob.com
	 */

	THREE.MorphAnimation = function ( mesh ) {

		this.mesh = mesh;
		this.frames = mesh.morphTargetInfluences.length;
		this.currentTime = 0;
		this.duration = 1000;
		this.loop = true;

		this.isPlaying = false;

	};

	THREE.MorphAnimation.prototype = {

		play: function () {

			this.isPlaying = true;

		},

		pause: function () {

			this.isPlaying = false;

		},

		update: ( function () {

			var lastFrame = 0;
			var currentFrame = 0;

			return function ( delta ) {

				if ( this.isPlaying === false ) return;

				this.currentTime += delta;

				if ( this.loop === true && this.currentTime > this.duration ) {

					this.currentTime %= this.duration;

				}

				this.currentTime = Math.min( this.currentTime, this.duration );

				var interpolation = this.duration / this.frames;
				var frame = Math.floor( this.currentTime / interpolation );

				if ( frame != currentFrame ) {

					this.mesh.morphTargetInfluences[ lastFrame ] = 0;
					this.mesh.morphTargetInfluences[ currentFrame ] = 1;
					this.mesh.morphTargetInfluences[ frame ] = 0;

					lastFrame = currentFrame;
					currentFrame = frame;

				}

				this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
				this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

			}

		} )()

	};

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;

		var scope = this;

		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;

		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;

			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

				w = 'z';

			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

				w = 'y';
				gridY = scope.depthSegments;

			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

				w = 'x';
				gridX = scope.depthSegments;

			}

			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();

			normal[ w ] = depth > 0 ? 1 : - 1;

			for ( iy = 0; iy < gridY1; iy ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;

					scope.vertices.push( vector );

				}

			}

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

				}

			}

		}

		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

		this.vertices.push(center);
		uvs.push( centerUV );

		for ( i = 0; i <= segments; i ++ ) {

			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 1; i <= segments; i ++ ) {

			this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/CubeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
		return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

	 };

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

		THREE.Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;

		openEnded = openEnded !== undefined ? openEnded : false;

		var heightHalf = height / 2;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * Math.PI * 2 );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * Math.PI * 2 );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;

		for ( x = 0; x < radialSegments; x ++ ) {

			if ( radiusTop !== 0 ) {

				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

			} else {

				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

			}

			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

			for ( y = 0; y < heightSegments; y ++ ) {

				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];

				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();

				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

		// top cap

		if ( openEnded === false && radiusTop > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );

				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		// bottom cap

		if ( openEnded === false && radiusBottom > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );

				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		this.computeFaceNormals();

	}

	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  material: <int> // material index for front and back faces
	 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function ( shapes, options ) {

		if ( typeof( shapes ) === "undefined" ) {
			shapes = [];
			return;
		}

		THREE.Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		shapes = shapes instanceof Array ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
		var sl = shapes.length;

		for ( var s = 0; s < sl; s ++ ) {
			var shape = shapes[ s ];
			this.addShape( shape, options );
		}
	};

	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		var material = options.material;
		var extrudeMaterial = options.extrudeMaterial;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initalization

		var ahole, h, hl; // looping of holes
		var scope = this;
		var bevelPoints = [];

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2 ( pt, vec, size ) {

			if ( ! vec ) console.log( "die" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length,
			cont, clen = contour.length;


		// Find directions for point movement

		var RAD_TO_DEGREES = 180 / Math.PI;


		function getBevelVec( inPt, inPrev, inNext ) {

			var EPSILON = 0.0000000001;
			
			// computes for inPt the corresponding point inPt' on a new contour
			//   shiftet by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
			
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
			
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
			
			// check for colinear edges
			var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
			
			if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
				
				// length of vectors for normalizing
		
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
				
				// shift adjacent points by unit vectors to the left
		
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
				
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
		
				// scaling factor for v_prev to intersection point
		
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
				// vector from inPt to intersection point
		
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
		
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
				if ( v_trans_lensq <= 2 ) {
					return	new THREE.Vector2( v_trans_x, v_trans_y );
				} else {
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
				}
				
			} else {		// handle special case of colinear edges

				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > EPSILON ) {
					if ( v_next_x > EPSILON ) { direction_eq = true; }
				} else {
					if ( v_prev_x < - EPSILON ) {
						if ( v_next_x < - EPSILON ) { direction_eq = true; }
					} else {
						if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
					}
				}

				if ( direction_eq ) {
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
				} else {
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
				}

			}

			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			var pt_i = contour[ i ];
			var pt_j = contour[ j ];
			var pt_k = contour[ k ];

			contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {
		//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );

			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
			//bs = bevelSize * t ; // linear

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
				binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

				position2.copy( extrudePts[0] ).add(normal).add(binormal);

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[s] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y,  amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if ( bevelEnabled ) {

				var layer = 0 ; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}
			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( --i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps  + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d, contour, s, sl, j, k );

				}
			}

		}


		function v( x, y, z ) {

			scope.vertices.push( new THREE.Vector3( x, y, z ) );

		}

		function f3( a, b, c ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			// normal, color, material
			scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

			var uvs = uvgen.generateTopUV( scope, a, b, c );

	 		scope.faceVertexUvs[ 0 ].push( uvs );

		}

		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

	 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
	 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

	 		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

	 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
	 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, indexA, indexB, indexC ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];

			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];

		},

		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];

			if ( Math.abs( a.y - b.y ) < 0.01 ) {
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
			} else {
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
			}
		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function ( shapes, options ) {

		THREE.Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( shapes instanceof Array === false ) shapes = [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			this.addShape( shapes[ i ], options );

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole, s;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];

				if ( THREE.Shape.Utils.isClockWise( hole ) ) {

					holes[ i ] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

		// Vertices

		var contour = vertices;

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];
			vertices = vertices.concat( hole );

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;
		var cont, clen = contour.length;

		for ( i = 0; i < vlen; i ++ ) {

			vert = vertices[ i ];

			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

		}

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];

			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;

			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

		}

	};

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */

	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

		THREE.Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;

		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;

		for ( var i = 0, il = segments; i <= il; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var c = Math.cos( phi ),
				s = Math.sin( phi );

			for ( var j = 0, jl = points.length; j < jl; j ++ ) {

				var pt = points[ j ];

				var vertex = new THREE.Vector3();

				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;

				this.vertices.push( vertex );

			}

		}

		var np = points.length;

		for ( var i = 0, il = segments; i < il; i ++ ) {

			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;

				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;

				this.faces.push( new THREE.Face3( a, b, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )

				] );

				this.faces.push( new THREE.Face3( b, c, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )

				] );


			}

		}

		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

		console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

		THREE.Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

	};

	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = widthSegments || 1;
		var gridY = heightSegments || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );

		var offset = 0;
		var offset2 = 0;

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices[ offset     ] = x;
				vertices[ offset + 1 ] = - y;

				normals[ offset + 2 ] = 1;

				uvs[ offset2     ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

		for ( var iy = 0; iy < gridY; iy ++ ) {

			for ( var ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				indices[ offset     ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;

				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;

				offset += 6;

			}

		}

		this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	};

	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

		for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

			for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
			}

			radius += radiusStep;

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

			var thetaSegment = i * (thetaSegments + 1);

			for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

				var segment = o + thetaSegment;

				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			}
		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );


	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength 
		};

		radius = radius || 50;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			for ( x = 0; x <= widthSegments; x ++ ) {

				var u = x / widthSegments;
				var v = y / heightSegments;

				var vertex = new THREE.Vector3();
				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		for ( y = 0; y < heightSegments; y ++ ) {

			for ( x = 0; x < widthSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];

				var n1 = this.vertices[ v1 ].clone().normalize();
				var n2 = this.vertices[ v2 ].clone().normalize();
				var n3 = this.vertices[ v3 ].clone().normalize();
				var n4 = this.vertices[ v4 ].clone().normalize();

				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x ].clone();
				var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

				if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

					uv1.x = ( uv1.x + uv2.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

				} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

					uv3.x = ( uv3.x + uv4.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

				} else {

					this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

					this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

				}

			}

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/TextGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */

	/*	Usage Examples

		// TextGeometry wrapper

		var text3d = new TextGeometry( text, options );

		// Complete manner

		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );

	*/


	THREE.TextGeometry = function ( text, parameters ) {

		parameters = parameters || {};

		var textShapes = THREE.FontUtils.generateShapes( text, parameters );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		THREE.ExtrudeGeometry.call( this, textShapes, parameters );

		this.type = 'TextGeometry';

	};

	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

		THREE.Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;

		var center = new THREE.Vector3(), uvs = [], normals = [];

		for ( var j = 0; j <= radialSegments; j ++ ) {

			for ( var i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );

				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				this.vertices.push( vertex );

				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );

			}

		}

		for ( var j = 1; j <= radialSegments; j ++ ) {

			for ( var i = 1; i <= tubularSegments; i ++ ) {

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */

	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

		THREE.Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
		
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();

		for ( var i = 0; i < radialSegments; ++ i ) {

			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );

				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;

				grid[ i ][ j ] = this.vertices.push( pos ) - 1;

			}

		}

		for ( var i = 0; i < radialSegments; ++ i ) {

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;

				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];

				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}
		}

		this.computeFaceNormals();
		this.computeVertexNormals();

		function getPos( u, in_q, in_p, radius, heightScale ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );

			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

			return new THREE.Vector3( tx, ty, tz );

		}

	};

	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed ) {

		THREE.Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			x, y, z,
			tx, ty, tz,
			u, v,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert( x, y, z ) {

			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

		}

		// consruct the grid

		for ( i = 0; i < numpoints; i ++ ) {

			grid[ i ] = [];

			u = i / ( numpoints - 1 );

			pos = path.getPointAt( u );

			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];

			for ( j = 0; j < radialSegments; j ++ ) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = radius * Math.sin( v );

				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

			}
		}


		// construct the mesh

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < radialSegments; j ++ ) {

				ip = ( closed ) ? (i + 1) % segments : i + 1;
				jp = (j + 1) % radialSegments;

				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];

				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}
		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

		var	tangent = new THREE.Vector3(),
			normal = new THREE.Vector3(),
			binormal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,

			tx, ty, tz,
			i, u, v;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for ( i = 0; i < numpoints; i ++ ) {

			u = i / ( numpoints - 1 );

			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}

		function initialNormal2() {

			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );

			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

		}
		*/

		function initialNormal3() {
			// select an initial normal vector perpenicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= smallest ) {
				smallest = tx;
				normal.set( 1, 0, 0 );
			}

			if ( ty <= smallest ) {
				smallest = ty;
				normal.set( 0, 1, 0 );
			}

			if ( tz <= smallest ) {
				normal.set( 0, 0, 1 );
			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for ( i = 1; i < numpoints; i ++ ) {

			normals[ i ] = normals[ i-1 ].clone();

			binormals[ i ] = binormals[ i-1 ].clone();

			vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

			if ( vec.length() > epsilon ) {

				vec.normalize();

				theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed ) {

			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i < numpoints; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}
	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

		THREE.Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

		}

		var midpoints = [], p = this.vertices;

		var faces = [];

		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

			var v1 = p[ indices[ i     ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];

			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

		}

		var centroid = new THREE.Vector3();

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			subdivide( faces[ i ], detail );

		}


		// Handle case when face straddles the seam

		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			var uvs = this.faceVertexUvs[ 0 ][ i ];

			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;

			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );

			if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

			}

		}


		// Apply radius

		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

			this.vertices[ i ].multiplyScalar( radius );

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


		// Project vector onto sphere's surface

		function prepare( vector ) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make( v1, v2, v3 ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			that.faces.push( face );

			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

			var azi = azimuth( centroid );

			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide( face, detail ) {

			var cols = Math.pow(2, detail);
			var cells = Math.pow(4, detail);
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];

			// Construct all of the vertices for this subdivision.

			for ( var i = 0 ; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;

				for ( var j = 0; j <= rows; j ++) {

					if ( j == 0 && i == cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

					}

				}

			}

			// Construct all of the faces.

			for ( var i = 0; i < cols ; i ++ ) {

				for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 == 0 ) {

						make(
							v[ i ][ k + 1],
							v[ i + 1 ][ k ],
							v[ i ][ k ]
						);

					} else {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1][ k + 1],
							v[ i + 1 ][ k ]
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV( uv, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function ( radius, detail ) {

		this.parameters = {
			radius: radius,
			detail: detail
		};

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			-1, -1, -1,    -1, -1,  1,
			-1,  1, -1,    -1,  1,  1,
			 1, -1, -1,     1, -1,  1,
			 1,  1, -1,     1,  1,  1,

			// (0, 1/, )
			 0, -r, -t,     0, -r,  t,
			 0,  r, -t,     0,  r,  t,

			// (1/, , 0)
			-r, -t,  0,    -r,  t,  0,
			 r, -t,  0,     r,  t,  0,

			// (, 0, 1/)
			-t,  0, -r,     t,  0, -r,
			-t,  0,  r,     t,  0,  r
		];

		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	};

	THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];

		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};
	};

	THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function ( radius, detail ) {

		this.parameters = {
			radius: radius,
			detail: detail
		};

		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
		];

		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};
	};

	THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function ( radius, detail ) {

		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];

		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function ( func, slices, stacks ) {

		THREE.Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];

		var i, il, j, p;
		var u, v;

		var stackCount = stacks + 1;
		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				u = j / slices;

				p = func( u, v );
				verts.push( p );

			}
		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j + 1;
				d = (i + 1) * sliceCount + j;

				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );

				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function ( size ) {

		size = size || 1;

		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );

		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

	};

	THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = ( function () {

		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

		return function ( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			THREE.Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );

			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

	}() );

	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

	THREE.ArrowHelper.prototype.setDirection = ( function () {

		var axis = new THREE.Vector3();
		var radians;

		return function ( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, length, 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function ( object ) {

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

		if ( object !== undefined ) {

			this.update( object );

		}

	};

	THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.BoxHelper.prototype.update = function ( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		var min = geometry.boundingBox.min;
		var max = geometry.boundingBox.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var vertices = this.geometry.attributes.position.array;

		vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
		vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

		vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
		vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

		vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
		vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

		vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
		vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

		//

		vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
		vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

		vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
		vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

		vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
		vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

		vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
		vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

		//

		vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
		vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

		vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
		vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

		vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
		vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

		vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
		vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

		this.geometry.attributes.position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

	};

	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject( this.object );

		this.box.size( this.scale );

		this.box.center( this.position );

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function ( camera ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );

		// far

		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );

		// sides

		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );

		// cone

		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );

		// up

		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );

		// target

		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );

		// cross

		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );

		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );

		function addLine( a, b, hex ) {

			addPoint( a, hex );
			addPoint( b, hex );

		}

		function addPoint( id, hex ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( geometry.vertices.length - 1 );

		}

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

		this.camera = camera;
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;
		
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		var setPoint = function ( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		};

		return function () {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );

			// near

			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );

			// far

			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );

			// up

			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );

			// cross

			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );

			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function ( light, size ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		size = size || 1;

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);

		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);

		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function () {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.EdgesHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };

		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();

		var geometry2 = object.geometry.clone();

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
		var numEdges = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
					numEdges ++;

				} else {

					hash[ key ].face2 = i;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		var index = 0;

		for ( var key in hash ) {

			var h = hash[ key ];

			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

				var vertex = vertices[ h.vert1 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;

				vertex = vertices[ h.vert2 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = this.object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.normalMatrix = new THREE.Matrix3();

		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.FaceNormalsHelper.prototype.update = function () {

		var vertices = this.geometry.vertices;

		var object = this.object;
		var objectVertices = object.geometry.vertices;
		var objectFaces = object.geometry.faces;
		var objectWorldMatrix = object.matrixWorld;

		object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( objectWorldMatrix );

		for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

			var face = objectFaces[ i ];

			vertices[ i2 ].copy( objectVertices[ face.a ] )
				.add( objectVertices[ face.b ] )
				.add( objectVertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( objectWorldMatrix );

			vertices[ i2 + 1 ].copy( face.normal )
				.applyMatrix3( this.normalMatrix )
				.normalize()
				.multiplyScalar( this.size )
				.add( vertices[ i2 ] );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	};


	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function ( size, step ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );

		for ( var i = - size; i <= size; i += step ) {

			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);

			var color = i === 0 ? this.color1 : this.color2;

			geometry.colors.push( color, color, color, color );

		}

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

	};

	THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );

		this.geometry.colorsNeedUpdate = true;

	}

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [ new THREE.Color(), new THREE.Color() ];

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

		for ( var i = 0, il = 8; i < il; i ++ ) {

			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

		}

		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

	THREE.HemisphereLightHelper.prototype.dispose = function () {
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function () {

			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;

		}

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function ( light, sphereSize ) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		THREE.Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();
	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function ( object ) {

		this.bones = this.getBoneList( object );

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

			}

		}

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

		var boneList = [];

		if ( object instanceof THREE.Bone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function ( light ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

	THREE.SpotLightHelper.prototype.dispose = function () {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function () {

			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var vertices = object.geometry.vertices;

		var faces = object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.normalMatrix = new THREE.Matrix3();

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

		var v1 = new THREE.Vector3();

		return function( object ) {

			var keys = [ 'a', 'b', 'c', 'd' ];

			this.object.updateMatrixWorld( true );

			this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var vertices = this.geometry.vertices;

			var verts = this.object.geometry.vertices;

			var faces = this.object.geometry.faces;

			var worldMatrix = this.object.matrixWorld;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];

					var normal = face.vertexNormals[ j ];

					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

					v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

					v1.add( vertices[ idx ] );
					idx = idx + 1;

					vertices[ idx ].copy( v1 );
					idx = idx + 1;

				}

			}

			this.geometry.verticesNeedUpdate = true;

			return this;

		}

	}());

	// File:src/extras/helpers/VertexTangentsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0x0000ff;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var vertices = object.geometry.vertices;

		var faces = object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

	THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

		var v1 = new THREE.Vector3();

		return function( object ) {

			var keys = [ 'a', 'b', 'c', 'd' ];

			this.object.updateMatrixWorld( true );

			var vertices = this.geometry.vertices;

			var verts = this.object.geometry.vertices;

			var faces = this.object.geometry.faces;

			var worldMatrix = this.object.matrixWorld;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];

					var tangent = face.vertexTangents[ j ];

					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

					v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

					v1.add( vertices[ idx ] );
					idx = idx + 1;

					vertices[ idx ].copy( v1 );
					idx = idx + 1;

				}

			}

			this.geometry.verticesNeedUpdate = true;

			return this;

		}

	}());

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };

		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();

		if ( object.geometry instanceof THREE.Geometry ) {

			var vertices = object.geometry.vertices;
			var faces = object.geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var vertex = vertices[ edges [ 2 * i + j] ];

					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else if ( object.geometry instanceof THREE.BufferGeometry ) {

			if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

				var vertices = object.geometry.attributes.position.array;
				var indices = object.geometry.attributes.index.array;
				var drawcalls = object.geometry.drawcalls;
				var numEdges = 0;

				if ( drawcalls.length === 0 ) {

					drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

				}

				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );

				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

					var start = drawcalls[ o ].start;
					var count = drawcalls[ o ].count;
					var index = drawcalls[ o ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						for ( var j = 0; j < 3; j ++ ) {

							edge[ 0 ] = index + indices[ i + j ];
							edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );

							var key = edge.toString();

							if ( hash[ key ] === undefined ) {

								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;

							}

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var index = 6 * i + 3 * j;
						var index2 = 3 * edges[ 2 * i + j];
						coords[ index + 0 ] = vertices[ index2 ];
						coords[ index + 1 ] = vertices[ index2 + 1 ];
						coords[ index + 2 ] = vertices[ index2 + 2 ];

					}

				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			} else { // non-indexed BufferGeometry

				var vertices = object.geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numTris; i < l; i ++ ) {

					for ( var j = 0; j < 3; j ++ ) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];

						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];

					}

				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function () {

		THREE.Object3D.call( this );

		this.render = function ( renderCallback ) {};

	};

	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );

	};

	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

		var animation = {

			startFrame: start,
			endFrame: end,

			length: end - start + 1,

			fps: fps,
			duration: ( end - start ) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

		var pattern = /([a-z]+)_?(\d+)/;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );

			if ( chunks && chunks.length > 1 ) {

				var name = chunks[ 1 ];
				var num = chunks[ 2 ];

				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

				var range = frameRanges[ name ];

				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;

				if ( ! firstAnimation ) firstAnimation = name;

			}

		}

		for ( var name in frameRanges ) {

			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

		var time = 0;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

		var duration = - 1;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = 0;
			animation.active = true;

		} else {

			console.warn( "animation[" + name + "] undefined" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function ( delta ) {

		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

			var animation = this.animationsList[ i ];

			if ( ! animation.active ) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if ( animation.mirroredLoop ) {

				if ( animation.time > animation.duration || animation.time < 0 ) {

					animation.direction *= - 1;

					if ( animation.time > animation.duration ) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if ( animation.time < 0 ) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if ( animation.time < 0 ) animation.time += animation.duration;

			}

			var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;

			if ( keyframe !== animation.currentFrame ) {

				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

				this.morphTargetInfluences[ keyframe ] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = ( animation.time % frameTime ) / frameTime;

			if ( animation.directionBackwards ) mix = 1 - mix;

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		}

	};



/***/ }),

/***/ 15:
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var THREE = __webpack_require__(4);
	var jQuery = __webpack_require__(2);
	(function(l, sa) {
	    true ? sa(exports) : "function" === typeof define && define.amd ? define(["exports"], sa) : sa(l.THREE = l.THREE || {})
	})(this, function(l) {
	   function sa() {}
	   function D(a, b) {
	      this.x = a || 0;
	      this.y = b || 0
	   }
	   function X(a, b, c, d, e, f, g, h, k, m) {
	      Object.defineProperty(this, "id", {
	         value: jf++
	      });
	      this.uuid = Y.generateUUID();
	      this.name = "";
	      this.image = void 0 !== a ? a : X.DEFAULT_IMAGE;
	      this.mipmaps = [];
	      this.mapping = void 0 !== b ? b : X.DEFAULT_MAPPING;
	      this.wrapS = void 0 !== c ? c : 1001;
	      this.wrapT = void 0 !== d ? d : 1001;
	      this.magFilter = void 0 !== e ? e : 1006;
	      this.minFilter = void 0 !== f ? f : 1008;
	      this.anisotropy = void 0 !== k ? k : 1;
	      this.format = void 0 !== g ? g : 1023;
	      this.type = void 0 !== h ? h : 1009;
	      this.offset = new D(0, 0);
	      this.repeat = new D(1, 1);
	      this.generateMipmaps = !0;
	      this.premultiplyAlpha = !1;
	      this.flipY = !0;
	      this.unpackAlignment = 4;
	      this.encoding = void 0 !== m ? m : 3e3;
	      this.version = 0;
	      this.onUpdate = null
	   }
	   function ga(a, b, c, d) {
	      this.x = a || 0;
	      this.y = b || 0;
	      this.z = c || 0;
	      this.w = void 0 !== d ? d : 1
	   }
	   function Db(a, b, c) {
	      this.uuid = Y.generateUUID();
	      this.width = a;
	      this.height = b;
	      this.scissor = new ga(0, 0, a, b);
	      this.scissorTest = !1;
	      this.viewport = new ga(0, 0, a, b);
	      c = c || {};
	      void 0 === c.minFilter && (c.minFilter = 1006);
	      this.texture = new X(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
	      this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
	      this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
	      this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
	   }
	   function Eb(a, b, c) {
	      Db.call(this, a, b, c);
	      this.activeMipMapLevel = this.activeCubeFace = 0
	   }
	   function qa(a, b, c, d) {
	      this._x = a || 0;
	      this._y = b || 0;
	      this._z = c || 0;
	      this._w = void 0 !== d ? d : 1
	   }
	   function p(a, b, c) {
	      this.x = a || 0;
	      this.y = b || 0;
	      this.z = c || 0
	   }
	   function J() {
	      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	      0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
	   }
	   function eb(a, b, c, d, e, f, g, h, k, m, u, q) {
	      X.call(this, null, f, g, h, k, m, d, e, u, q);
	      this.image = {
	         data: a,
	         width: b,
	         height: c
	      };
	      this.magFilter = void 0 !== k ? k : 1003;
	      this.minFilter = void 0 !== m ? m : 1003;
	      this.flipY = this.generateMipmaps = !1;
	      this.unpackAlignment = 1
	   }
	   function Za(a, b, c, d, e, f, g, h, k, m) {
	      a = void 0 !== a ? a : [];
	      X.call(this, a, void 0 !== b ? b : 301, c, d, e, f, g, h, k, m);
	      this.flipY = !1
	   }
	   function Fb(a, b, c) {
	      var d = a[0];
	      if (0 >= d || 0 < d) return a;
	      var e = b * c,
	         f = ye[e];
	      void 0 === f && (f = new Float32Array(e), ye[e] = f);
	      if (0 !== b) for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
	      return f
	   }
	   function ze(a, b) {
	      var c = Ae[b];
	      void 0 === c && (c = new Int32Array(b), Ae[b] = c);
	      for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
	      return c
	   }
	   function kf(a, b) {
	      a.uniform1f(this.addr, b)
	   }
	   function lf(a, b) {
	      a.uniform1i(this.addr, b)
	   }
	   function mf(a, b) {
	      void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y)
	   }
	   function nf(a, b) {
	      void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
	   }
	   function of(a, b) {
	      void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
	   }
	   function pf(a, b) {
	      a.uniformMatrix2fv(this.addr, !1, b.elements || b)
	   }
	   function qf(a, b) {
	      void 0 === b.elements ? a.uniformMatrix3fv(this.addr, !1, b) : (Be.set(b.elements), a.uniformMatrix3fv(this.addr, !1, Be))
	   }
	   function rf(a, b) {
	      void 0 === b.elements ? a.uniformMatrix4fv(this.addr, !1, b) : (Ce.set(b.elements), a.uniformMatrix4fv(this.addr, !1, Ce))
	   }
	   function sf(a, b, c) {
	      var d = c.allocTextureUnit();
	      a.uniform1i(this.addr, d);
	      c.setTexture2D(b || De, d)
	   }
	   function tf(a, b, c) {
	      var d = c.allocTextureUnit();
	      a.uniform1i(this.addr, d);
	      c.setTextureCube(b || Ee, d)
	   }
	   function Fe(a, b) {
	      a.uniform2iv(this.addr, b)
	   }
	   function Ge(a, b) {
	      a.uniform3iv(this.addr, b)
	   }
	   function He(a, b) {
	      a.uniform4iv(this.addr, b)
	   }
	   function uf(a) {
	      switch (a) {
	      case 5126:
	         return kf;
	      case 35664:
	         return mf;
	      case 35665:
	         return nf;
	      case 35666:
	         return of;
	      case 35674:
	         return pf;
	      case 35675:
	         return qf;
	      case 35676:
	         return rf;
	      case 35678:
	         return sf;
	      case 35680:
	         return tf;
	      case 5124:
	      case 35670:
	         return lf;
	      case 35667:
	      case 35671:
	         return Fe;
	      case 35668:
	      case 35672:
	         return Ge;
	      case 35669:
	      case 35673:
	         return He
	      }
	   }
	   function vf(a, b) {
	      a.uniform1fv(this.addr, b)
	   }
	   function wf(a, b) {
	      a.uniform1iv(this.addr, b)
	   }
	   function xf(a, b) {
	      a.uniform2fv(this.addr, Fb(b, this.size, 2))
	   }
	   function yf(a, b) {
	      a.uniform3fv(this.addr, Fb(b, this.size, 3))
	   }
	   function zf(a, b) {
	      a.uniform4fv(this.addr, Fb(b, this.size, 4))
	   }
	   function Af(a, b) {
	      a.uniformMatrix2fv(this.addr, !1, Fb(b, this.size, 4))
	   }
	   function Bf(a, b) {
	      a.uniformMatrix3fv(this.addr, !1, Fb(b, this.size, 9))
	   }
	   function Cf(a, b) {
	      a.uniformMatrix4fv(this.addr, !1, Fb(b, this.size, 16))
	   }
	   function Df(a, b, c) {
	      var d = b.length,
	         e = ze(c, d);
	      a.uniform1iv(this.addr, e);
	      for (a = 0; a !== d; ++a) c.setTexture2D(b[a] || De, e[a])
	   }
	   function Ef(a, b, c) {
	      var d = b.length,
	         e = ze(c, d);
	      a.uniform1iv(this.addr, e);
	      for (a = 0; a !== d; ++a) c.setTextureCube(b[a] || Ee, e[a])
	   }
	   function Ff(a) {
	      switch (a) {
	      case 5126:
	         return vf;
	      case 35664:
	         return xf;
	      case 35665:
	         return yf;
	      case 35666:
	         return zf;
	      case 35674:
	         return Af;
	      case 35675:
	         return Bf;
	      case 35676:
	         return Cf;
	      case 35678:
	         return Df;
	      case 35680:
	         return Ef;
	      case 5124:
	      case 35670:
	         return wf;
	      case 35667:
	      case 35671:
	         return Fe;
	      case 35668:
	      case 35672:
	         return Ge;
	      case 35669:
	      case 35673:
	         return He
	      }
	   }
	   function Gf(a, b, c) {
	      this.id = a;
	      this.addr = c;
	      this.setValue = uf(b.type)
	   }
	   function Hf(a, b, c) {
	      this.id = a;
	      this.addr = c;
	      this.size = b.size;
	      this.setValue = Ff(b.type)
	   }
	   function Ie(a) {
	      this.id = a;
	      this.seq = [];
	      this.map = {}
	   }
	   function fb(a, b, c) {
	      this.seq = [];
	      this.map = {};
	      this.renderer = c;
	      c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
	      for (var d = 0; d < c; ++d) {
	         var e = a.getActiveUniform(b, d),
	            f = a.getUniformLocation(b, e.name),
	            g = this,
	            h = e.name,
	            k = h.length;
	         for (Qd.lastIndex = 0;;) {
	            var m = Qd.exec(h),
	               u = Qd.lastIndex,
	               q = m[1],
	               n = m[3];
	            "]" === m[2] && (q |= 0);
	            if (void 0 === n || "[" === n && u + 2 === k) {
	               h = g;
	               e = void 0 === n ? new Gf(q, e, f) : new Hf(q, e, f);
	               h.seq.push(e);
	               h.map[e.id] = e;
	               break
	            } else n = g.map[q], void 0 === n && (n = new Ie(q), q = g, g = n, q.seq.push(g), q.map[g.id] = g), g = n
	         }
	      }
	   }
	   function H(a, b, c) {
	      return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
	   }
	   function id(a, b) {
	      this.min = void 0 !== a ? a : new D(Infinity, Infinity);
	      this.max = void 0 !== b ? b : new D(-Infinity, -Infinity)
	   }
	   function If(a, b) {
	      var c, d, e, f, g, h, k, m, u, q, n = a.context,
	         r = a.state,
	         l, t, y, x, v, G;
	      this.render = function(w, O, S) {
	         if (0 !== b.length) {
	            w = new p;
	            var E = S.w / S.z,
	               F = .5 * S.z,
	               aa = .5 * S.w,
	               R = 16 / S.w,
	               ca = new D(R * E, R),
	               la = new p(1, 1, 0),
	               gb = new D(1, 1),
	               Gb = new id;
	            Gb.min.set(S.x, S.y);
	            Gb.max.set(S.x + (S.z - 16), S.y + (S.w - 16));
	            if (void 0 === x) {
	               var R = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
	                  ja = new Uint16Array([0, 1, 2, 0, 2, 3]);
	               l = n.createBuffer();
	               t = n.createBuffer();
	               n.bindBuffer(n.ARRAY_BUFFER, l);
	               n.bufferData(n.ARRAY_BUFFER, R, n.STATIC_DRAW);
	               n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t);
	               n.bufferData(n.ELEMENT_ARRAY_BUFFER, ja, n.STATIC_DRAW);
	               v = n.createTexture();
	               G = n.createTexture();
	               r.bindTexture(n.TEXTURE_2D, v);
	               n.texImage2D(n.TEXTURE_2D, 0, n.RGB, 16, 16, 0, n.RGB, n.UNSIGNED_BYTE, null);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
	               r.bindTexture(n.TEXTURE_2D, G);
	               n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, 16, 16, 0, n.RGBA, n.UNSIGNED_BYTE, null);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);
	               n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);
	               var R = y = {
	                  vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
	                  fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
	               },
	                  ja = n.createProgram(),
	                  P = n.createShader(n.FRAGMENT_SHADER),
	                  K = n.createShader(n.VERTEX_SHADER),
	                  W = "precision " + a.getPrecision() + " float;\n";
	               n.shaderSource(P, W + R.fragmentShader);
	               n.shaderSource(K, W + R.vertexShader);
	               n.compileShader(P);
	               n.compileShader(K);
	               n.attachShader(ja, P);
	               n.attachShader(ja, K);
	               n.linkProgram(ja);
	               x = ja;
	               u = n.getAttribLocation(x, "position");
	               q = n.getAttribLocation(x, "uv");
	               c = n.getUniformLocation(x, "renderType");
	               d = n.getUniformLocation(x, "map");
	               e = n.getUniformLocation(x, "occlusionMap");
	               f = n.getUniformLocation(x, "opacity");
	               g = n.getUniformLocation(x, "color");
	               h = n.getUniformLocation(x, "scale");
	               k = n.getUniformLocation(x, "rotation");
	               m = n.getUniformLocation(x, "screenPosition")
	            }
	            n.useProgram(x);
	            r.initAttributes();
	            r.enableAttribute(u);
	            r.enableAttribute(q);
	            r.disableUnusedAttributes();
	            n.uniform1i(e, 0);
	            n.uniform1i(d, 1);
	            n.bindBuffer(n.ARRAY_BUFFER, l);
	            n.vertexAttribPointer(u, 2, n.FLOAT, !1, 16, 0);
	            n.vertexAttribPointer(q, 2, n.FLOAT, !1, 16, 8);
	            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t);
	            r.disable(n.CULL_FACE);
	            r.buffers.depth.setMask(!1);
	            ja = 0;
	            for (P = b.length; ja < P; ja++) if (R = 16 / S.w, ca.set(R * E, R), K = b[ja], w.set(K.matrixWorld.elements[12], K.matrixWorld.elements[13], K.matrixWorld.elements[14]), w.applyMatrix4(O.matrixWorldInverse), w.applyMatrix4(O.projectionMatrix), la.copy(w), gb.x = S.x + la.x * F + F - 8, gb.y = S.y + la.y * aa + aa - 8, !0 === Gb.containsPoint(gb)) {
	               r.activeTexture(n.TEXTURE0);
	               r.bindTexture(n.TEXTURE_2D, null);
	               r.activeTexture(n.TEXTURE1);
	               r.bindTexture(n.TEXTURE_2D, v);
	               n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGB, gb.x, gb.y, 16, 16, 0);
	               n.uniform1i(c, 0);
	               n.uniform2f(h, ca.x, ca.y);
	               n.uniform3f(m, la.x, la.y, la.z);
	               r.disable(n.BLEND);
	               r.enable(n.DEPTH_TEST);
	               n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
	               r.activeTexture(n.TEXTURE0);
	               r.bindTexture(n.TEXTURE_2D, G);
	               n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, gb.x, gb.y, 16, 16, 0);
	               n.uniform1i(c, 1);
	               r.disable(n.DEPTH_TEST);
	               r.activeTexture(n.TEXTURE1);
	               r.bindTexture(n.TEXTURE_2D, v);
	               n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
	               K.positionScreen.copy(la);
	               K.customUpdateCallback ? K.customUpdateCallback(K) : K.updateLensFlares();
	               n.uniform1i(c, 2);
	               r.enable(n.BLEND);
	               for (var W = 0, ba = K.lensFlares.length; W < ba; W++) {
	                  var T = K.lensFlares[W];.001 < T.opacity && .001 < T.scale && (la.x = T.x, la.y = T.y, la.z = T.z, R = T.size * T.scale / S.w, ca.x = R * E, ca.y = R, n.uniform3f(m, la.x, la.y, la.z), n.uniform2f(h, ca.x, ca.y), n.uniform1f(k, T.rotation), n.uniform1f(f, T.opacity), n.uniform3f(g, T.color.r, T.color.g, T.color.b), r.setBlending(T.blending, T.blendEquation, T.blendSrc, T.blendDst), a.setTexture2D(T.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0))
	               }
	            }
	            r.enable(n.CULL_FACE);
	            r.enable(n.DEPTH_TEST);
	            r.buffers.depth.setMask(!0);
	            a.resetGLState()
	         }
	      }
	   }
	   function Jf(a, b) {
	      var c, d, e, f, g, h, k, m, u, q, n, r, l, t, y, x, v;

	      function G(a, b) {
	         return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
	      }
	      var w = a.context,
	         O = a.state,
	         S, E, F, aa, R = new p,
	         ca = new qa,
	         la = new p;
	      this.render = function(p, Gb) {
	         if (0 !== b.length) {
	            if (void 0 === F) {
	               var ja = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
	                  P = new Uint16Array([0, 1, 2, 0, 2, 3]);
	               S = w.createBuffer();
	               E = w.createBuffer();
	               w.bindBuffer(w.ARRAY_BUFFER, S);
	               w.bufferData(w.ARRAY_BUFFER, ja, w.STATIC_DRAW);
	               w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, E);
	               w.bufferData(w.ELEMENT_ARRAY_BUFFER, P, w.STATIC_DRAW);
	               var ja = w.createProgram(),
	                  P = w.createShader(w.VERTEX_SHADER),
	                  K = w.createShader(w.FRAGMENT_SHADER);
	               w.shaderSource(P, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
	               w.shaderSource(K, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
	               w.compileShader(P);
	               w.compileShader(K);
	               w.attachShader(ja, P);
	               w.attachShader(ja, K);
	               w.linkProgram(ja);
	               F = ja;
	               x = w.getAttribLocation(F, "position");
	               v = w.getAttribLocation(F, "uv");
	               c = w.getUniformLocation(F, "uvOffset");
	               d = w.getUniformLocation(F, "uvScale");
	               e = w.getUniformLocation(F, "rotation");
	               f = w.getUniformLocation(F, "scale");
	               g = w.getUniformLocation(F, "color");
	               h = w.getUniformLocation(F, "map");
	               k = w.getUniformLocation(F, "opacity");
	               m = w.getUniformLocation(F, "modelViewMatrix");
	               u = w.getUniformLocation(F, "projectionMatrix");
	               q = w.getUniformLocation(F, "fogType");
	               n = w.getUniformLocation(F, "fogDensity");
	               r = w.getUniformLocation(F, "fogNear");
	               l = w.getUniformLocation(F, "fogFar");
	               t = w.getUniformLocation(F, "fogColor");
	               y = w.getUniformLocation(F, "alphaTest");
	               ja = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	               ja.width = 8;
	               ja.height = 8;
	               P = ja.getContext("2d");
	               P.fillStyle = "white";
	               P.fillRect(0, 0, 8, 8);
	               aa = new X(ja);
	               aa.needsUpdate = !0
	            }
	            w.useProgram(F);
	            O.initAttributes();
	            O.enableAttribute(x);
	            O.enableAttribute(v);
	            O.disableUnusedAttributes();
	            O.disable(w.CULL_FACE);
	            O.enable(w.BLEND);
	            w.bindBuffer(w.ARRAY_BUFFER, S);
	            w.vertexAttribPointer(x, 2, w.FLOAT, !1, 16, 0);
	            w.vertexAttribPointer(v, 2, w.FLOAT, !1, 16, 8);
	            w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, E);
	            w.uniformMatrix4fv(u, !1, Gb.projectionMatrix.elements);
	            O.activeTexture(w.TEXTURE0);
	            w.uniform1i(h, 0);
	            P = ja = 0;
	            (K = p.fog) ? (w.uniform3f(t, K.color.r, K.color.g, K.color.b), K.isFog ? (w.uniform1f(r, K.near), w.uniform1f(l, K.far), w.uniform1i(q, 1), P = ja = 1) : K.isFogExp2 && (w.uniform1f(n, K.density), w.uniform1i(q, 2), P = ja = 2)) : (w.uniform1i(q, 0), P = ja = 0);
	            for (var K = 0, W = b.length; K < W; K++) {
	               var ba = b[K];
	               ba.modelViewMatrix.multiplyMatrices(Gb.matrixWorldInverse, ba.matrixWorld);
	               ba.z = -ba.modelViewMatrix.elements[14]
	            }
	            b.sort(G);
	            for (var T = [], K = 0, W = b.length; K < W; K++) {
	               var ba = b[K],
	                  Q = ba.material;
	               !1 !== Q.visible && (w.uniform1f(y, Q.alphaTest), w.uniformMatrix4fv(m, !1, ba.modelViewMatrix.elements), ba.matrixWorld.decompose(R, ca, la), T[0] = la.x, T[1] = la.y, ba = 0, p.fog && Q.fog && (ba = P), ja !== ba && (w.uniform1i(q, ba), ja = ba), null !== Q.map ? (w.uniform2f(c, Q.map.offset.x, Q.map.offset.y), w.uniform2f(d, Q.map.repeat.x, Q.map.repeat.y)) : (w.uniform2f(c, 0, 0), w.uniform2f(d, 1, 1)), w.uniform1f(k, Q.opacity), w.uniform3f(g, Q.color.r, Q.color.g, Q.color.b), w.uniform1f(e, Q.rotation), w.uniform2fv(f, T), O.setBlending(Q.blending, Q.blendEquation, Q.blendSrc, Q.blendDst), O.buffers.depth.setTest(Q.depthTest), O.buffers.depth.setMask(Q.depthWrite), Q.map ? a.setTexture2D(Q.map, 0) : a.setTexture2D(aa, 0), w.drawElements(w.TRIANGLES, 6, w.UNSIGNED_SHORT, 0))
	            }
	            O.enable(w.CULL_FACE);
	            a.resetGLState()
	         }
	      }
	   }
	   function Z() {
	      Object.defineProperty(this, "id", {
	         value: Kf++
	      });
	      this.uuid = Y.generateUUID();
	      this.name = "";
	      this.type = "Material";
	      this.lights = this.fog = !0;
	      this.blending = 1;
	      this.side = 0;
	      this.shading = 2;
	      this.vertexColors = 0;
	      this.opacity = 1;
	      this.transparent = !1;
	      this.blendSrc = 204;
	      this.blendDst = 205;
	      this.blendEquation = 100;
	      this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
	      this.depthFunc = 3;
	      this.depthWrite = this.depthTest = !0;
	      this.clippingPlanes = null;
	      this.clipShadows = this.clipIntersection = !1;
	      this.colorWrite = !0;
	      this.precision = null;
	      this.polygonOffset = !1;
	      this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
	      this.dithering = !1;
	      this.alphaTest = 0;
	      this.premultipliedAlpha = !1;
	      this.overdraw = 0;
	      this.needsUpdate = this.visible = !0
	   }
	   function Ea(a) {
	      Z.call(this);
	      this.type = "ShaderMaterial";
	      this.defines = {};
	      this.uniforms = {};
	      this.vertexShader = "void main() {\n   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
	      this.fragmentShader = "void main() {\n gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
	      this.linewidth = 1;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
	      this.extensions = {
	         derivatives: !1,
	         fragDepth: !1,
	         drawBuffers: !1,
	         shaderTextureLOD: !1
	      };
	      this.defaultAttributeValues = {
	         color: [1, 1, 1],
	         uv: [0, 0],
	         uv2: [0, 0]
	      };
	      this.index0AttributeName = void 0;
	      void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
	   }
	   function $a(a) {
	      Z.call(this);
	      this.type = "MeshDepthMaterial";
	      this.depthPacking = 3200;
	      this.morphTargets = this.skinning = !1;
	      this.displacementMap = this.alphaMap = this.map = null;
	      this.displacementScale = 1;
	      this.displacementBias = 0;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.lights = this.fog = !1;
	      this.setValues(a)
	   }
	   function Ta(a, b) {
	      this.min = void 0 !== a ? a : new p(Infinity, Infinity, Infinity);
	      this.max = void 0 !== b ? b : new p(-Infinity, -Infinity, -Infinity)
	   }
	   function Ga(a, b) {
	      this.center = void 0 !== a ? a : new p;
	      this.radius = void 0 !== b ? b : 0
	   }
	   function Ka() {
	      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	      0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
	   }
	   function wa(a, b) {
	      this.normal = void 0 !== a ? a : new p(1, 0, 0);
	      this.constant = void 0 !== b ? b : 0
	   }
	   function jd(a, b, c, d, e, f) {
	      this.planes = [void 0 !== a ? a : new wa, void 0 !== b ? b : new wa, void 0 !== c ? c : new wa, void 0 !== d ? d : new wa, void 0 !== e ? e : new wa, void 0 !== f ? f : new wa]
	   }
	   function Je(a, b, c, d) {
	      function e(b, c, d, e) {
	         var f = b.geometry,
	            g;
	         g = t;
	         var h = b.customDepthMaterial;
	         d && (g = y, h = b.customDistanceMaterial);
	         h ? g = h : (h = !1, c.morphTargets && (f && f.isBufferGeometry ? h = f.morphAttributes && f.morphAttributes.position && 0 < f.morphAttributes.position.length : f && f.isGeometry && (h = f.morphTargets && 0 < f.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, f = 0, h && (f |= 1), b && (f |= 2), g = g[f]);
	         a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (f = g.uuid, h = c.uuid, b = x[f], void 0 === b && (b = {}, x[f] = b), f = b[h], void 0 === f && (f = g.clone(), b[h] = f), g = f);
	         g.visible = c.visible;
	         g.wireframe = c.wireframe;
	         h = c.side;
	         R.renderSingleSided && 2 == h && (h = 0);
	         R.renderReverseSided && (0 === h ? h = 1 : 1 === h && (h = 0));
	         g.side = h;
	         g.clipShadows = c.clipShadows;
	         g.clippingPlanes = c.clippingPlanes;
	         g.wireframeLinewidth = c.wireframeLinewidth;
	         g.linewidth = c.linewidth;
	         d && void 0 !== g.uniforms.lightPos && g.uniforms.lightPos.value.copy(e);
	         return g
	      }
	      function f(b, d, g, h) {
	         if (!1 !== b.visible) {
	            if (b.layers.test(d.layers) && (b.isMesh || b.isLine || b.isPoints) && b.castShadow && (!b.frustumCulled || k.intersectsObject(b))) {
	               b.modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, b.matrixWorld);
	               var m = c.update(b),
	                  n = b.material;
	               if (Array.isArray(n)) for (var u = m.groups, q = 0, r = u.length; q < r; q++) {
	                  var x = u[q],
	                     v = n[x.materialIndex];
	                  v && v.visible && (v = e(b, v, h, l), a.renderBufferDirect(g, null, m, v, b, x))
	               } else n.visible && (v = e(b, n, h, l), a.renderBufferDirect(g, null, m, v, b, null))
	            }
	            b = b.children;
	            m = 0;
	            for (n = b.length; m < n; m++) f(b[m], d, g, h)
	         }
	      }
	      var g = a.context,
	         h = a.state,
	         k = new jd,
	         m = new J,
	         u = b.shadows,
	         q = new D,
	         n = new D(d.maxTextureSize, d.maxTextureSize),
	         r = new p,
	         l = new p,
	         t = Array(4),
	         y = Array(4),
	         x = {},
	         v = [new p(1, 0, 0), new p(-1, 0, 0), new p(0, 0, 1), new p(0, 0, -1), new p(0, 1, 0), new p(0, -1, 0)],
	         G = [new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0), new p(0, 0, 1), new p(0, 0, -1)],
	         w = [new ga, new ga, new ga, new ga, new ga, new ga];
	      b = new $a;
	      b.depthPacking = 3201;
	      b.clipping = !0;
	      d = ab.distanceRGBA;
	      for (var O = Ha.clone(d.uniforms), S = 0; 4 !== S; ++S) {
	         var E = 0 !== (S & 1),
	            F = 0 !== (S & 2),
	            aa = b.clone();
	         aa.morphTargets = E;
	         aa.skinning = F;
	         t[S] = aa;
	         E = new Ea({
	            defines: {
	               USE_SHADOWMAP: ""
	            },
	            uniforms: O,
	            vertexShader: d.vertexShader,
	            fragmentShader: d.fragmentShader,
	            morphTargets: E,
	            skinning: F,
	            clipping: !0
	         });
	         y[S] = E
	      }
	      var R = this;
	      this.enabled = !1;
	      this.autoUpdate = !0;
	      this.needsUpdate = !1;
	      this.type = 1;
	      this.renderSingleSided = this.renderReverseSided = !0;
	      this.render = function(b, c) {
	         if (!1 !== R.enabled && (!1 !== R.autoUpdate || !1 !== R.needsUpdate) && 0 !== u.length) {
	            h.disable(g.BLEND);
	            h.buffers.color.setClear(1, 1, 1, 1);
	            h.buffers.depth.setTest(!0);
	            h.setScissorTest(!1);
	            for (var d, e, x = 0, t = u.length; x < t; x++) {
	               var p = u[x],
	                  y = p.shadow;
	               if (void 0 === y) console.warn("THREE.WebGLShadowMap:", p, "has no shadow.");
	               else {
	                  var O = y.camera,
	                     E = y.matrix;
	                  l.setFromMatrixPosition(p.matrixWorld);
	                  O.position.copy(l);
	                  q.copy(y.mapSize);
	                  q.min(n);
	                  if (p && p.isPointLight) {
	                     d = 6;
	                     e = !0;
	                     var S = q.x,
	                        F = q.y;
	                     w[0].set(2 * S, F, S, F);
	                     w[1].set(0, F, S, F);
	                     w[2].set(3 * S, F, S, F);
	                     w[3].set(S, F, S, F);
	                     w[4].set(3 * S, 0, S, F);
	                     w[5].set(S, 0, S, F);
	                     q.x *= 4;
	                     q.y *= 2;
	                     E.makeTranslation(-l.x, -l.y, -l.z)
	                  } else d = 1, e = !1, r.setFromMatrixPosition(p.target.matrixWorld), O.lookAt(r), O.updateMatrixWorld(), O.matrixWorldInverse.getInverse(O.matrixWorld), E.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), E.multiply(O.projectionMatrix), E.multiply(O.matrixWorldInverse);
	                  null === y.map && (y.map = new Db(q.x, q.y, {
	                     minFilter: 1003,
	                     magFilter: 1003,
	                     format: 1023
	                  }), y.map.texture.name = p.name + ".shadowMap", O.updateProjectionMatrix());
	                  y.isSpotLightShadow && y.update(p);
	                  a.setRenderTarget(y.map);
	                  a.clear();
	                  for (p = 0; p < d; p++) e && (r.copy(O.position), r.add(v[p]), O.up.copy(G[p]), O.lookAt(r), O.updateMatrixWorld(), O.matrixWorldInverse.getInverse(O.matrixWorld), h.viewport(w[p])), m.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), k.setFromMatrix(m), f(b, c, O, e)
	               }
	            }
	            d = a.getClearColor();
	            e = a.getClearAlpha();
	            a.setClearColor(d, e);
	            R.needsUpdate = !1
	         }
	      }
	   }
	   function hb(a, b) {
	      this.origin = void 0 !== a ? a : new p;
	      this.direction = void 0 !== b ? b : new p
	   }
	   function bb(a, b, c, d) {
	      this._x = a || 0;
	      this._y = b || 0;
	      this._z = c || 0;
	      this._order = d || bb.DefaultOrder
	   }
	   function Rd() {
	      this.mask = 1
	   }
	   function B() {
	      Object.defineProperty(this, "id", {
	         value: Lf++
	      });
	      this.uuid = Y.generateUUID();
	      this.name = "";
	      this.type = "Object3D";
	      this.parent = null;
	      this.children = [];
	      this.up = B.DefaultUp.clone();
	      var a = new p,
	         b = new bb,
	         c = new qa,
	         d = new p(1, 1, 1);
	      b.onChange(function() {
	         c.setFromEuler(b, !1)
	      });
	      c.onChange(function() {
	         b.setFromQuaternion(c, void 0, !1)
	      });
	      Object.defineProperties(this, {
	         position: {
	            enumerable: !0,
	            value: a
	         },
	         rotation: {
	            enumerable: !0,
	            value: b
	         },
	         quaternion: {
	            enumerable: !0,
	            value: c
	         },
	         scale: {
	            enumerable: !0,
	            value: d
	         },
	         modelViewMatrix: {
	            value: new J
	         },
	         normalMatrix: {
	            value: new Ka
	         }
	      });
	      this.matrix = new J;
	      this.matrixWorld = new J;
	      this.matrixAutoUpdate = B.DefaultMatrixAutoUpdate;
	      this.matrixWorldNeedsUpdate = !1;
	      this.layers = new Rd;
	      this.visible = !0;
	      this.receiveShadow = this.castShadow = !1;
	      this.frustumCulled = !0;
	      this.renderOrder = 0;
	      this.userData = {};
	      this.onBeforeRender = function() {};
	      this.onAfterRender = function() {}
	   }
	   function Hb(a, b) {
	      this.start = void 0 !== a ? a : new p;
	      this.end = void 0 !== b ? b : new p
	   }
	   function Ua(a, b, c) {
	      this.a = void 0 !== a ? a : new p;
	      this.b = void 0 !== b ? b : new p;
	      this.c = void 0 !== c ? c : new p
	   }
	   function Va(a, b, c, d, e, f) {
	      this.a = a;
	      this.b = b;
	      this.c = c;
	      this.normal = d && d.isVector3 ? d : new p;
	      this.vertexNormals = Array.isArray(d) ? d : [];
	      this.color = e && e.isColor ? e : new H;
	      this.vertexColors = Array.isArray(e) ? e : [];
	      this.materialIndex = void 0 !== f ? f : 0
	   }
	   function Na(a) {
	      Z.call(this);
	      this.type = "MeshBasicMaterial";
	      this.color = new H(16777215);
	      this.lightMap = this.map = null;
	      this.lightMapIntensity = 1;
	      this.aoMap = null;
	      this.aoMapIntensity = 1;
	      this.envMap = this.alphaMap = this.specularMap = null;
	      this.combine = 0;
	      this.reflectivity = 1;
	      this.refractionRatio = .98;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.wireframeLinejoin = this.wireframeLinecap = "round";
	      this.lights = this.morphTargets = this.skinning = !1;
	      this.setValues(a)
	   }
	   function L(a, b, c) {
	      if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
	      this.uuid = Y.generateUUID();
	      this.array = a;
	      this.itemSize = b;
	      this.count = void 0 !== a ? a.length / b : 0;
	      this.normalized = !0 === c;
	      this.dynamic = !1;
	      this.updateRange = {
	         offset: 0,
	         count: -1
	      };
	      this.onUploadCallback = function() {};
	      this.version = 0
	   }
	   function rc(a, b) {
	      L.call(this, new Int8Array(a), b)
	   }
	   function sc(a, b) {
	      L.call(this, new Uint8Array(a), b)
	   }
	   function tc(a, b) {
	      L.call(this, new Uint8ClampedArray(a), b)
	   }
	   function uc(a, b) {
	      L.call(this, new Int16Array(a), b)
	   }
	   function ib(a, b) {
	      L.call(this, new Uint16Array(a), b)
	   }
	   function vc(a, b) {
	      L.call(this, new Int32Array(a), b)
	   }
	   function jb(a, b) {
	      L.call(this, new Uint32Array(a), b)
	   }
	   function C(a, b) {
	      L.call(this, new Float32Array(a), b)
	   }
	   function wc(a, b) {
	      L.call(this, new Float64Array(a), b)
	   }
	   function Ke() {
	      this.indices = [];
	      this.vertices = [];
	      this.normals = [];
	      this.colors = [];
	      this.uvs = [];
	      this.uvs2 = [];
	      this.groups = [];
	      this.morphTargets = {};
	      this.skinWeights = [];
	      this.skinIndices = [];
	      this.boundingSphere = this.boundingBox = null;
	      this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
	   }
	   function Sd(a) {
	      if (0 === a.length) return -Infinity;
	      for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
	      return b
	   }
	   function M() {
	      Object.defineProperty(this, "id", {
	         value: Td++
	      });
	      this.uuid = Y.generateUUID();
	      this.name = "";
	      this.type = "Geometry";
	      this.vertices = [];
	      this.colors = [];
	      this.faces = [];
	      this.faceVertexUvs = [
	         []
	      ];
	      this.morphTargets = [];
	      this.morphNormals = [];
	      this.skinWeights = [];
	      this.skinIndices = [];
	      this.lineDistances = [];
	      this.boundingSphere = this.boundingBox = null;
	      this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
	   }
	   function I() {
	      Object.defineProperty(this, "id", {
	         value: Td++
	      });
	      this.uuid = Y.generateUUID();
	      this.name = "";
	      this.type = "BufferGeometry";
	      this.index = null;
	      this.attributes = {};
	      this.morphAttributes = {};
	      this.groups = [];
	      this.boundingSphere = this.boundingBox = null;
	      this.drawRange = {
	         start: 0,
	         count: Infinity
	      }
	   }
	   function Ca(a, b) {
	      B.call(this);
	      this.type = "Mesh";
	      this.geometry = void 0 !== a ? a : new I;
	      this.material = void 0 !== b ? b : new Na({
	         color: 16777215 * Math.random()
	      });
	      this.drawMode = 0;
	      this.updateMorphTargets()
	   }
	   function Ib(a, b, c, d, e, f) {
	      M.call(this);
	      this.type = "BoxGeometry";
	      this.parameters = {
	         width: a,
	         height: b,
	         depth: c,
	         widthSegments: d,
	         heightSegments: e,
	         depthSegments: f
	      };
	      this.fromBufferGeometry(new kb(a, b, c, d, e, f));
	      this.mergeVertices()
	   }
	   function kb(a, b, c, d, e, f) {
	      function g(a, b, c, d, e, f, g, l, S, E, F) {
	         var aa = f / S,
	            R = g / E,
	            ca = f / 2,
	            la = g / 2,
	            D = l / 2;
	         g = S + 1;
	         var C = E + 1,
	            B = f = 0,
	            P, K, W = new p;
	         for (K = 0; K < C; K++) {
	            var ba = K * R - la;
	            for (P = 0; P < g; P++) W[a] = (P * aa - ca) * d, W[b] = ba * e, W[c] = D, m.push(W.x, W.y, W.z), W[a] = 0, W[b] = 0, W[c] = 0 < l ? 1 : -1, u.push(W.x, W.y, W.z), q.push(P / S), q.push(1 - K / E), f += 1
	         }
	         for (K = 0; K < E; K++) for (P = 0; P < S; P++) a = n + P + g * (K + 1), b = n + (P + 1) + g * (K + 1), c = n + (P + 1) + g * K, k.push(n + P + g * K, a, c), k.push(a, b, c), B += 6;
	         h.addGroup(r, B, F);
	         r += B;
	         n += f
	      }
	      I.call(this);
	      this.type = "BoxBufferGeometry";
	      this.parameters = {
	         width: a,
	         height: b,
	         depth: c,
	         widthSegments: d,
	         heightSegments: e,
	         depthSegments: f
	      };
	      var h = this;
	      d = Math.floor(d) || 1;
	      e = Math.floor(e) || 1;
	      f = Math.floor(f) || 1;
	      var k = [],
	         m = [],
	         u = [],
	         q = [],
	         n = 0,
	         r = 0;
	      g("z", "y", "x", -1, -1, c, b, a, f, e, 0);
	      g("z", "y", "x", 1, -1, c, b, -a, f, e, 1);
	      g("x", "z", "y", 1, 1, a, c, b, d, f, 2);
	      g("x", "z", "y", 1, -1, a, c, -b, d, f, 3);
	      g("x", "y", "z", 1, -1, a, b, c, d, e, 4);
	      g("x", "y", "z", -1, -1, a, b, -c, d, e, 5);
	      this.setIndex(k);
	      this.addAttribute("position", new C(m, 3));
	      this.addAttribute("normal", new C(u, 3));
	      this.addAttribute("uv", new C(q, 2))
	   }
	   function xc(a, b, c, d) {
	      M.call(this);
	      this.type = "PlaneGeometry";
	      this.parameters = {
	         width: a,
	         height: b,
	         widthSegments: c,
	         heightSegments: d
	      };
	      this.fromBufferGeometry(new lb(a, b, c, d));
	      this.mergeVertices()
	   }
	   function lb(a, b, c, d) {
	      I.call(this);
	      this.type = "PlaneBufferGeometry";
	      this.parameters = {
	         width: a,
	         height: b,
	         widthSegments: c,
	         heightSegments: d
	      };
	      var e = a / 2,
	         f = b / 2;
	      c = Math.floor(c) || 1;
	      d = Math.floor(d) || 1;
	      var g = c + 1,
	         h = d + 1,
	         k = a / c,
	         m = b / d,
	         u = [],
	         q = [],
	         n = [],
	         r = [];
	      for (a = 0; a < h; a++) {
	         var l = a * m - f;
	         for (b = 0; b < g; b++) q.push(b * k - e, -l, 0), n.push(0, 0, 1), r.push(b / c), r.push(1 - a / d)
	      }
	      for (a = 0; a < d; a++) for (b = 0; b < c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, u.push(b + g * a, e, h), u.push(e, f, h);
	      this.setIndex(u);
	      this.addAttribute("position", new C(q, 3));
	      this.addAttribute("normal", new C(n, 3));
	      this.addAttribute("uv", new C(r, 2))
	   }
	   function Oa() {
	      B.call(this);
	      this.type = "Camera";
	      this.matrixWorldInverse = new J;
	      this.projectionMatrix = new J
	   }
	   function xa(a, b, c, d) {
	      Oa.call(this);
	      this.type = "PerspectiveCamera";
	      this.fov = void 0 !== a ? a : 50;
	      this.zoom = 1;
	      this.near = void 0 !== c ? c : .1;
	      this.far = void 0 !== d ? d : 2e3;
	      this.focus = 10;
	      this.aspect = void 0 !== b ? b : 1;
	      this.view = null;
	      this.filmGauge = 35;
	      this.filmOffset = 0;
	      this.updateProjectionMatrix()
	   }
	   function Jb(a, b, c, d, e, f) {
	      Oa.call(this);
	      this.type = "OrthographicCamera";
	      this.zoom = 1;
	      this.view = null;
	      this.left = a;
	      this.right = b;
	      this.top = c;
	      this.bottom = d;
	      this.near = void 0 !== e ? e : .1;
	      this.far = void 0 !== f ? f : 2e3;
	      this.updateProjectionMatrix()
	   }
	   function Mf(a) {
	      var b = {};
	      return {
	         get: function(a) {
	            a.isInterleavedBufferAttribute && (a = a.data);
	            return b[a.uuid]
	         },
	         remove: function(c) {
	            var d = b[c.uuid];
	            d && (a.deleteBuffer(d.buffer), delete b[c.uuid])
	         },
	         update: function(c, d) {
	            c.isInterleavedBufferAttribute && (c = c.data);
	            var e = b[c.uuid];
	            if (void 0 === e) {
	               var e = c.uuid,
	                  f = c,
	                  g = f.array,
	                  h = f.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW,
	                  k = a.createBuffer();
	               a.bindBuffer(d, k);
	               a.bufferData(d, g, h);
	               f.onUploadCallback();
	               h = a.FLOAT;
	               g instanceof Float32Array ? h = a.FLOAT : g instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : g instanceof Uint16Array ? h = a.UNSIGNED_SHORT : g instanceof Int16Array ? h = a.SHORT : g instanceof Uint32Array ? h = a.UNSIGNED_INT : g instanceof Int32Array ? h = a.INT : g instanceof Int8Array ? h = a.BYTE : g instanceof Uint8Array && (h = a.UNSIGNED_BYTE);
	               b[e] = {
	                  buffer: k,
	                  type: h,
	                  bytesPerElement: g.BYTES_PER_ELEMENT,
	                  version: f.version
	               }
	            } else e.version < c.version && (f = c, g = f.array, k = f.updateRange, a.bindBuffer(d, e.buffer), !1 === f.dynamic ? a.bufferData(d, g, a.STATIC_DRAW) : -1 === k.count ? a.bufferSubData(d, 0, g) : 0 === k.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, k.offset * g.BYTES_PER_ELEMENT, g.subarray(k.offset, k.offset + k.count)), k.count = 0), e.version = c.version)
	         }
	      }
	   }
	   function Nf(a, b) {
	      return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
	   }
	   function Of(a, b) {
	      return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
	   }
	   function Pf() {
	      var a = [],
	         b = -1,
	         c = [],
	         d = -1;
	      return {
	         opaque: a,
	         transparent: c,
	         init: function() {
	            d = b = -1
	         },
	         push: function(e, f, g, h, k) {
	            var m, u;
	            g.transparent ? (m = c, u = ++d) : (m = a, u = ++b);
	            (u = m[u]) ? (u.id = e.id, u.object = e, u.geometry = f, u.material = g, u.program = g.program, u.renderOrder = e.renderOrder, u.z = h, u.group = k) : (u = {
	               id: e.id,
	               object: e,
	               geometry: f,
	               material: g,
	               program: g.program,
	               renderOrder: e.renderOrder,
	               z: h,
	               group: k
	            }, m.push(u))
	         },
	         finish: function() {
	            a.length = b + 1;
	            c.length = d + 1
	         },
	         sort: function() {
	            a.sort(Nf);
	            c.sort(Of)
	         }
	      }
	   }
	   function Qf() {
	      var a = {};
	      return {
	         get: function(b, c) {
	            var d = b.id + "," + c.id,
	               e = a[d];
	            void 0 === e && (e = new Pf, a[d] = e);
	            return e
	         },
	         dispose: function() {
	            a = {}
	         }
	      }
	   }
	   function Rf(a, b, c) {
	      var d, e, f;
	      this.setMode = function(a) {
	         d = a
	      };
	      this.setIndex = function(c) {
	         c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (e = a.UNSIGNED_INT, f = 4) : c.array instanceof Uint16Array ? (e = a.UNSIGNED_SHORT, f = 2) : (e = a.UNSIGNED_BYTE, f = 1)
	      };
	      this.render = function(b, h) {
	         a.drawElements(d, h, e, b * f);
	         c.calls++;
	         c.vertices += h;
	         d === a.TRIANGLES && (c.faces += h / 3)
	      };
	      this.renderInstances = function(g, h, k) {
	         var m = b.get("ANGLE_instanced_arrays");
	         null === m ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (m.drawElementsInstancedANGLE(d, k, e, h * f, g.maxInstancedCount), c.calls++, c.vertices += k * g.maxInstancedCount, d === a.TRIANGLES && (c.faces += g.maxInstancedCount * k / 3))
	      }
	   }
	   function Sf(a, b, c) {
	      var d;
	      this.setMode = function(a) {
	         d = a
	      };
	      this.render = function(b, f) {
	         a.drawArrays(d, b, f);
	         c.calls++;
	         c.vertices += f;
	         d === a.TRIANGLES && (c.faces += f / 3)
	      };
	      this.renderInstances = function(e, f, g) {
	         var h = b.get("ANGLE_instanced_arrays");
	         if (null === h) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
	         else {
	            var k = e.attributes.position;
	            k.isInterleavedBufferAttribute ? (g = k.data.count, h.drawArraysInstancedANGLE(d, 0, g, e.maxInstancedCount)) : h.drawArraysInstancedANGLE(d, f, g, e.maxInstancedCount);
	            c.calls++;
	            c.vertices += g * e.maxInstancedCount;
	            d === a.TRIANGLES && (c.faces += e.maxInstancedCount * g / 3)
	         }
	      }
	   }
	   function Tf(a, b, c) {
	      function d(a) {
	         a = a.target;
	         var h = e[a.id];
	         null !== h.index && b.remove(h.index);
	         for (var k in h.attributes) b.remove(h.attributes[k]);
	         a.removeEventListener("dispose", d);
	         delete e[a.id];
	         if (k = f[a.id]) b.remove(k), delete f[a.id];
	         if (k = f[h.id]) b.remove(k), delete f[h.id];
	         c.geometries--
	      }
	      var e = {},
	         f = {};
	      return {
	         get: function(a, b) {
	            var f = e[b.id];
	            if (f) return f;
	            b.addEventListener("dispose", d);
	            b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new I).setFromObject(a)), f = b._bufferGeometry);
	            e[b.id] = f;
	            c.geometries++;
	            return f
	         },
	         update: function(c) {
	            var d = c.index,
	               e = c.attributes;
	            null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER);
	            for (var f in e) b.update(e[f], a.ARRAY_BUFFER);
	            c = c.morphAttributes;
	            for (f in c) for (var d = c[f], e = 0, u = d.length; e < u; e++) b.update(d[e], a.ARRAY_BUFFER)
	         },
	         getWireframeAttribute: function(c) {
	            var d = f[c.id];
	            if (d) return d;
	            var d = [],
	               e = c.index,
	               m = c.attributes;
	            if (null !== e) for (var e = e.array, m = 0, u = e.length; m < u; m += 3) {
	               var q = e[m + 0],
	                  n = e[m + 1],
	                  r = e[m + 2];
	               d.push(q, n, n, r, r, q)
	            } else for (e = m.position.array, m = 0, u = e.length / 3 - 1; m < u; m += 3) q = m + 0, n = m + 1, r = m + 2, d.push(q, n, n, r, r, q);
	            d = new(65535 < Sd(d) ? jb : ib)(d, 1);
	            b.update(d, a.ELEMENT_ARRAY_BUFFER);
	            return f[c.id] = d
	         }
	      }
	   }
	   function Uf() {
	      var a = {};
	      return {
	         get: function(b) {
	            if (void 0 !== a[b.id]) return a[b.id];
	            var c;
	            switch (b.type) {
	            case "DirectionalLight":
	               c = {
	                  direction: new p,
	                  color: new H,
	                  shadow: !1,
	                  shadowBias: 0,
	                  shadowRadius: 1,
	                  shadowMapSize: new D
	               };
	               break;
	            case "SpotLight":
	               c = {
	                  position: new p,
	                  direction: new p,
	                  color: new H,
	                  distance: 0,
	                  coneCos: 0,
	                  penumbraCos: 0,
	                  decay: 0,
	                  shadow: !1,
	                  shadowBias: 0,
	                  shadowRadius: 1,
	                  shadowMapSize: new D
	               };
	               break;
	            case "PointLight":
	               c = {
	                  position: new p,
	                  color: new H,
	                  distance: 0,
	                  decay: 0,
	                  shadow: !1,
	                  shadowBias: 0,
	                  shadowRadius: 1,
	                  shadowMapSize: new D
	               };
	               break;
	            case "HemisphereLight":
	               c = {
	                  direction: new p,
	                  skyColor: new H,
	                  groundColor: new H
	               };
	               break;
	            case "RectAreaLight":
	               c = {
	                  color: new H,
	                  position: new p,
	                  halfWidth: new p,
	                  halfHeight: new p
	               }
	            }
	            return a[b.id] = c
	         }
	      }
	   }
	   function Vf(a, b, c) {
	      var d = {};
	      return {
	         update: function(a) {
	            var f = c.frame,
	               g = a.geometry,
	               h = b.get(a, g);
	            d[h.id] !== f && (g.isGeometry && h.updateFromObject(a), b.update(h), d[h.id] = f);
	            return h
	         },
	         clear: function() {
	            d = {}
	         }
	      }
	   }
	   function Wf(a) {
	      a = a.split("\n");
	      for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
	      return a.join("\n")
	   }
	   function Le(a, b, c) {
	      var d = a.createShader(b);
	      a.shaderSource(d, c);
	      a.compileShader(d);
	      !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
	      "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), Wf(c));
	      return d
	   }
	   function Me(a) {
	      switch (a) {
	      case 3e3:
	         return ["Linear", "( value )"];
	      case 3001:
	         return ["sRGB", "( value )"];
	      case 3002:
	         return ["RGBE", "( value )"];
	      case 3004:
	         return ["RGBM", "( value, 7.0 )"];
	      case 3005:
	         return ["RGBM", "( value, 16.0 )"];
	      case 3006:
	         return ["RGBD", "( value, 256.0 )"];
	      case 3007:
	         return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
	      default:
	         throw Error("unsupported encoding: " + a)
	      }
	   }
	   function Ud(a, b) {
	      var c = Me(b);
	      return "vec4 " + a + "( vec4 value ) { return " + c[0] + "ToLinear" + c[1] + "; }"
	   }
	   function Xf(a, b) {
	      var c = Me(b);
	      return "vec4 " + a + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"
	   }
	   function Yf(a, b) {
	      var c;
	      switch (b) {
	      case 1:
	         c = "Linear";
	         break;
	      case 2:
	         c = "Reinhard";
	         break;
	      case 3:
	         c = "Uncharted2";
	         break;
	      case 4:
	         c = "OptimizedCineon";
	         break;
	      default:
	         throw Error("unsupported toneMapping: " + b)
	      }
	      return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }"
	   }
	   function Zf(a, b, c) {
	      a = a || {};
	      return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(yc).join("\n")
	   }
	   function $f(a) {
	      var b = [],
	         c;
	      for (c in a) {
	         var d = a[c];
	         !1 !== d && b.push("#define " + c + " " + d)
	      }
	      return b.join("\n")
	   }
	   function yc(a) {
	      return "" !== a
	   }
	   function Ne(a, b) {
	      return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
	   }
	   function Vd(a) {
	      return a.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(a, c) {
	         var d = U[c];
	         if (void 0 === d) throw Error("Can not resolve #include <" + c + ">");
	         return Vd(d)
	      })
	   }
	   function Oe(a) {
	      return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, c, d, e) {
	         a = "";
	         for (c = parseInt(c); c < parseInt(d); c++) a += e.replace(/\[ i \]/g, "[ " + c + " ]");
	         return a
	      })
	   }
	   function ag(a, b, c, d) {
	      var e = a.context,
	         f = c.extensions,
	         g = c.defines,
	         h = c.__webglShader.vertexShader,
	         k = c.__webglShader.fragmentShader,
	         m = "SHADOWMAP_TYPE_BASIC";
	      1 === d.shadowMapType ? m = "SHADOWMAP_TYPE_PCF" : 2 === d.shadowMapType && (m = "SHADOWMAP_TYPE_PCF_SOFT");
	      var u = "ENVMAP_TYPE_CUBE",
	         q = "ENVMAP_MODE_REFLECTION",
	         n = "ENVMAP_BLENDING_MULTIPLY";
	      if (d.envMap) {
	         switch (c.envMap.mapping) {
	         case 301:
	         case 302:
	            u = "ENVMAP_TYPE_CUBE";
	            break;
	         case 306:
	         case 307:
	            u = "ENVMAP_TYPE_CUBE_UV";
	            break;
	         case 303:
	         case 304:
	            u = "ENVMAP_TYPE_EQUIREC";
	            break;
	         case 305:
	            u = "ENVMAP_TYPE_SPHERE"
	         }
	         switch (c.envMap.mapping) {
	         case 302:
	         case 304:
	            q = "ENVMAP_MODE_REFRACTION"
	         }
	         switch (c.combine) {
	         case 0:
	            n = "ENVMAP_BLENDING_MULTIPLY";
	            break;
	         case 1:
	            n = "ENVMAP_BLENDING_MIX";
	            break;
	         case 2:
	            n = "ENVMAP_BLENDING_ADD"
	         }
	      }
	      var r = 0 < a.gammaFactor ? a.gammaFactor : 1,
	         f = Zf(f, d, a.extensions),
	         l = $f(g),
	         t = e.createProgram();
	      c.isRawShaderMaterial ? (g = [l, "\n"].filter(yc).join("\n"), m = [f, l, "\n"].filter(yc).join("\n")) : (g = ["precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, l, d.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + r, "#define MAX_BONES " + d.maxBones, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + q : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.displacementMap && d.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals && !1 === d.flatShading ? "#define USE_MORPHNORMALS" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + m : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "  attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", " attribute vec3 morphTarget0;", " attribute vec3 morphTarget1;", " attribute vec3 morphTarget2;", " attribute vec3 morphTarget3;", " #ifdef USE_MORPHNORMALS", "      attribute vec3 morphNormal0;", "    attribute vec3 morphNormal1;", "    attribute vec3 morphNormal2;", "    attribute vec3 morphNormal3;", " #else", "      attribute vec3 morphTarget4;", "    attribute vec3 morphTarget5;", "    attribute vec3 morphTarget6;", "    attribute vec3 morphTarget7;", " #endif", "#endif", "#ifdef USE_SKINNING", "  attribute vec4 skinIndex;", " attribute vec4 skinWeight;", "#endif", "\n"].filter(yc).join("\n"), m = [f, "precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, l, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", "#define GAMMA_FACTOR " + r, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + u : "", d.envMap ? "#define " + q : "", d.envMap ? "#define " + n : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.gradientMap ? "#define USE_GRADIENTMAP" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (d.numClippingPlanes - d.numClipIntersection), d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + m : "", d.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", d.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", d.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== d.toneMapping ? "#define TONE_MAPPING" : "", 0 !== d.toneMapping ? U.tonemapping_pars_fragment : "", 0 !== d.toneMapping ? Yf("toneMapping", d.toneMapping) : "", d.dithering ? "#define DITHERING" : "", d.outputEncoding || d.mapEncoding || d.envMapEncoding || d.emissiveMapEncoding ? U.encodings_pars_fragment : "", d.mapEncoding ? Ud("mapTexelToLinear", d.mapEncoding) : "", d.envMapEncoding ? Ud("envMapTexelToLinear", d.envMapEncoding) : "", d.emissiveMapEncoding ? Ud("emissiveMapTexelToLinear", d.emissiveMapEncoding) : "", d.outputEncoding ? Xf("linearToOutputTexel", d.outputEncoding) : "", d.depthPacking ? "#define DEPTH_PACKING " + c.depthPacking : "", "\n"].filter(yc).join("\n"));
	      h = Vd(h, d);
	      h = Ne(h, d);
	      k = Vd(k, d);
	      k = Ne(k, d);
	      c.isShaderMaterial || (h = Oe(h), k = Oe(k));
	      k = m + k;
	      h = Le(e, e.VERTEX_SHADER, g + h);
	      k = Le(e, e.FRAGMENT_SHADER, k);
	      e.attachShader(t, h);
	      e.attachShader(t, k);
	      void 0 !== c.index0AttributeName ? e.bindAttribLocation(t, 0, c.index0AttributeName) : !0 === d.morphTargets && e.bindAttribLocation(t, 0, "position");
	      e.linkProgram(t);
	      d = e.getProgramInfoLog(t);
	      u = e.getShaderInfoLog(h);
	      q = e.getShaderInfoLog(k);
	      r = n = !0;
	      if (!1 === e.getProgramParameter(t, e.LINK_STATUS)) n = !1, console.error("THREE.WebGLProgram: shader error: ", e.getError(), "gl.VALIDATE_STATUS", e.getProgramParameter(t, e.VALIDATE_STATUS), "gl.getProgramInfoLog", d, u, q);
	      else if ("" !== d) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", d);
	      else if ("" === u || "" === q) r = !1;
	      r && (this.diagnostics = {
	         runnable: n,
	         material: c,
	         programLog: d,
	         vertexShader: {
	            log: u,
	            prefix: g
	         },
	         fragmentShader: {
	            log: q,
	            prefix: m
	         }
	      });
	      e.deleteShader(h);
	      e.deleteShader(k);
	      var p;
	      this.getUniforms = function() {
	         void 0 === p && (p = new fb(e, t, a));
	         return p
	      };
	      var x;
	      this.getAttributes = function() {
	         if (void 0 === x) {
	            for (var a = {}, b = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
	               var d = e.getActiveAttrib(t, c).name;
	               a[d] = e.getAttribLocation(t, d)
	            }
	            x = a
	         }
	         return x
	      };
	      this.destroy = function() {
	         e.deleteProgram(t);
	         this.program = void 0
	      };
	      Object.defineProperties(this, {
	         uniforms: {
	            get: function() {
	               console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
	               return this.getUniforms()
	            }
	         },
	         attributes: {
	            get: function() {
	               console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
	               return this.getAttributes()
	            }
	         }
	      });
	      this.id = bg++;
	      this.code = b;
	      this.usedTimes = 1;
	      this.program = t;
	      this.vertexShader = h;
	      this.fragmentShader = k;
	      return this
	   }
	   function cg(a, b) {
	      function c(a, b) {
	         var c;
	         a ? a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding) : c = 3e3;
	         3e3 === c && b && (c = 3007);
	         return c
	      }
	      var d = [],
	         e = {
	            MeshDepthMaterial: "depth",
	            MeshNormalMaterial: "normal",
	            MeshBasicMaterial: "basic",
	            MeshLambertMaterial: "lambert",
	            MeshPhongMaterial: "phong",
	            MeshToonMaterial: "phong",
	            MeshStandardMaterial: "physical",
	            MeshPhysicalMaterial: "physical",
	            LineBasicMaterial: "basic",
	            LineDashedMaterial: "dashed",
	            PointsMaterial: "points"
	         },
	         f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
	      this.getParameters = function(d, f, k, m, u, q) {
	         var n = e[d.type],
	            r;
	         if (q.isSkinnedMesh) if (r = q.skeleton.bones, b.floatVertexTextures) r = 1024;
	         else {
	            var l = Math.min(Math.floor((b.maxVertexUniforms - 20) / 4), r.length);
	            l < r.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + r.length + " bones. This GPU supports " + l + "."), r = 0) : r = l
	         } else r = 0;
	         l = a.getPrecision();
	         null !== d.precision && (l = b.getMaxPrecision(d.precision), l !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", l, "instead."));
	         var t = a.getRenderTarget();
	         return {
	            shaderID: n,
	            precision: l,
	            supportsVertexTextures: b.vertexTextures,
	            outputEncoding: c(t ? t.texture : null, a.gammaOutput),
	            map: !! d.map,
	            mapEncoding: c(d.map, a.gammaInput),
	            envMap: !! d.envMap,
	            envMapMode: d.envMap && d.envMap.mapping,
	            envMapEncoding: c(d.envMap, a.gammaInput),
	            envMapCubeUV: !! d.envMap && (306 === d.envMap.mapping || 307 === d.envMap.mapping),
	            lightMap: !! d.lightMap,
	            aoMap: !! d.aoMap,
	            emissiveMap: !! d.emissiveMap,
	            emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
	            bumpMap: !! d.bumpMap,
	            normalMap: !! d.normalMap,
	            displacementMap: !! d.displacementMap,
	            roughnessMap: !! d.roughnessMap,
	            metalnessMap: !! d.metalnessMap,
	            specularMap: !! d.specularMap,
	            alphaMap: !! d.alphaMap,
	            gradientMap: !! d.gradientMap,
	            combine: d.combine,
	            vertexColors: d.vertexColors,
	            fog: !! k,
	            useFog: d.fog,
	            fogExp: k && k.isFogExp2,
	            flatShading: 1 === d.shading,
	            sizeAttenuation: d.sizeAttenuation,
	            logarithmicDepthBuffer: b.logarithmicDepthBuffer,
	            skinning: d.skinning && 0 < r,
	            maxBones: r,
	            useVertexTexture: b.floatVertexTextures,
	            morphTargets: d.morphTargets,
	            morphNormals: d.morphNormals,
	            maxMorphTargets: a.maxMorphTargets,
	            maxMorphNormals: a.maxMorphNormals,
	            numDirLights: f.directional.length,
	            numPointLights: f.point.length,
	            numSpotLights: f.spot.length,
	            numRectAreaLights: f.rectArea.length,
	            numHemiLights: f.hemi.length,
	            numClippingPlanes: m,
	            numClipIntersection: u,
	            dithering: d.dithering,
	            shadowMapEnabled: a.shadowMap.enabled && q.receiveShadow && 0 < f.shadows.length,
	            shadowMapType: a.shadowMap.type,
	            toneMapping: a.toneMapping,
	            physicallyCorrectLights: a.physicallyCorrectLights,
	            premultipliedAlpha: d.premultipliedAlpha,
	            alphaTest: d.alphaTest,
	            doubleSided: 2 === d.side,
	            flipSided: 1 === d.side,
	            depthPacking: void 0 !== d.depthPacking ? d.depthPacking : !1
	         }
	      };
	      this.getProgramCode = function(a, b) {
	         var c = [];
	         b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader));
	         if (void 0 !== a.defines) for (var d in a.defines) c.push(d), c.push(a.defines[d]);
	         for (d = 0; d < f.length; d++) c.push(b[f[d]]);
	         return c.join()
	      };
	      this.acquireProgram = function(b, c, e) {
	         for (var f, u = 0, q = d.length; u < q; u++) {
	            var n = d[u];
	            if (n.code === e) {
	               f = n;
	               ++f.usedTimes;
	               break
	            }
	         }
	         void 0 === f && (f = new ag(a, e, b, c), d.push(f));
	         return f
	      };
	      this.releaseProgram = function(a) {
	         if (0 === --a.usedTimes) {
	            var b = d.indexOf(a);
	            d[b] = d[d.length - 1];
	            d.pop();
	            a.destroy()
	         }
	      };
	      this.programs = d
	   }
	   function dg(a, b, c, d, e, f, g) {
	      function h(a, b) {
	         if (a.width > b || a.height > b) {
	            var c = b / Math.max(a.width, a.height),
	               d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	            d.width = Math.floor(a.width * c);
	            d.height = Math.floor(a.height * c);
	            d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height);
	            console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a);
	            return d
	         }
	         return a
	      }
	      function k(a) {
	         return Y.isPowerOfTwo(a.width) && Y.isPowerOfTwo(a.height)
	      }
	      function m(b) {
	         return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR
	      }
	      function u(b) {
	         b = b.target;
	         b.removeEventListener("dispose", u);
	         a: {
	            var c = d.get(b);
	            if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);
	            else {
	               if (void 0 === c.__webglInit) break a;
	               a.deleteTexture(c.__webglTexture)
	            }
	            d.remove(b)
	         }
	         g.textures--
	      }
	      function q(b) {
	         b = b.target;
	         b.removeEventListener("dispose", q);
	         var c = d.get(b),
	            e = d.get(b.texture);
	         if (b) {
	            void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture);
	            b.depthTexture && b.depthTexture.dispose();
	            if (b.isWebGLRenderTargetCube) for (e = 0; 6 > e; e++) a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]);
	            else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer);
	            d.remove(b.texture);
	            d.remove(b)
	         }
	         g.textures--
	      }
	      function n(b, m) {
	         var n = d.get(b);
	         if (0 < b.version && n.__version !== b.version) {
	            var q = b.image;
	            if (void 0 === q) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", b);
	            else if (!1 === q.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b);
	            else {
	               void 0 === n.__webglInit && (n.__webglInit = !0, b.addEventListener("dispose", u), n.__webglTexture = a.createTexture(), g.textures++);
	               c.activeTexture(a.TEXTURE0 + m);
	               c.bindTexture(a.TEXTURE_2D, n.__webglTexture);
	               a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
	               a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
	               a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment);
	               var l = h(b.image, e.maxTextureSize);
	               if ((1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === k(l)) if (q = l, q instanceof HTMLImageElement || q instanceof HTMLCanvasElement) {
	                  var t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	                  t.width = Y.nearestPowerOfTwo(q.width);
	                  t.height = Y.nearestPowerOfTwo(q.height);
	                  t.getContext("2d").drawImage(q, 0, 0, t.width, t.height);
	                  console.warn("THREE.WebGLRenderer: image is not power of two (" + q.width + "x" + q.height + "). Resized to " + t.width + "x" + t.height, q);
	                  l = t
	               } else l = q;
	               var q = k(l),
	                  t = f(b.format),
	                  z = f(b.type);
	               r(a.TEXTURE_2D, b, q);
	               var F = b.mipmaps;
	               if (b.isDepthTexture) {
	                  F = a.DEPTH_COMPONENT;
	                  if (1015 === b.type) {
	                     if (!p) throw Error("Float Depth Texture only supported in WebGL2.0");
	                     F = a.DEPTH_COMPONENT32F
	                  } else p && (F = a.DEPTH_COMPONENT16);
	                  1026 === b.format && F === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), b.type = 1012, z = f(b.type));
	                  1027 === b.format && (F = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, z = f(b.type)));
	                  c.texImage2D(a.TEXTURE_2D, 0, F, l.width, l.height, 0, t, z, null)
	               } else if (b.isDataTexture) if (0 < F.length && q) {
	                  for (var aa = 0, R = F.length; aa < R; aa++) l = F[aa], c.texImage2D(a.TEXTURE_2D, aa, t, l.width, l.height, 0, t, z, l.data);
	                  b.generateMipmaps = !1
	               } else c.texImage2D(a.TEXTURE_2D, 0, t, l.width, l.height, 0, t, z, l.data);
	               else if (b.isCompressedTexture) for (aa = 0, R = F.length; aa < R; aa++) l = F[aa], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(t) ? c.compressedTexImage2D(a.TEXTURE_2D, aa, t, l.width, l.height, 0, l.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(a.TEXTURE_2D, aa, t, l.width, l.height, 0, t, z, l.data);
	               else if (0 < F.length && q) {
	                  aa = 0;
	                  for (R = F.length; aa < R; aa++) l = F[aa], c.texImage2D(a.TEXTURE_2D, aa, t, t, z, l);
	                  b.generateMipmaps = !1
	               } else c.texImage2D(a.TEXTURE_2D, 0, t, t, z, l);
	               b.generateMipmaps && q && a.generateMipmap(a.TEXTURE_2D);
	               n.__version = b.version;
	               if (b.onUpdate) b.onUpdate(b);
	               return
	            }
	         }
	         c.activeTexture(a.TEXTURE0 + m);
	         c.bindTexture(a.TEXTURE_2D, n.__webglTexture)
	      }
	      function r(c, g, h) {
	         h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T, f(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, m(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, m(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", g));
	         !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === b.get("OES_texture_half_float_linear") || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
	      }
	      function l(b, e, g, h) {
	         var k = f(e.texture.format),
	            m = f(e.texture.type);
	         c.texImage2D(h, 0, k, e.width, e.height, 0, k, m, null);
	         a.bindFramebuffer(a.FRAMEBUFFER, b);
	         a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0);
	         a.bindFramebuffer(a.FRAMEBUFFER, null)
	      }
	      function t(b, c) {
	         a.bindRenderbuffer(a.RENDERBUFFER, b);
	         c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height);
	         a.bindRenderbuffer(a.RENDERBUFFER, null)
	      }
	      var p = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext;
	      this.setTexture2D = n;
	      this.setTextureCube = function(b, m) {
	         var n = d.get(b);
	         if (6 === b.image.length) if (0 < b.version && n.__version !== b.version) {
	            n.__image__webglTextureCube || (b.addEventListener("dispose", u), n.__image__webglTextureCube = a.createTexture(), g.textures++);
	            c.activeTexture(a.TEXTURE0 + m);
	            c.bindTexture(a.TEXTURE_CUBE_MAP, n.__image__webglTextureCube);
	            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY);
	            for (var q = b && b.isCompressedTexture, l = b.image[0] && b.image[0].isDataTexture, t = [], z = 0; 6 > z; z++) t[z] = q || l ? l ? b.image[z].image : b.image[z] : h(b.image[z], e.maxCubemapSize);
	            var p = k(t[0]),
	               y = f(b.format),
	               R = f(b.type);
	            r(a.TEXTURE_CUBE_MAP, b, p);
	            for (z = 0; 6 > z; z++) if (q) for (var ca, la = t[z].mipmaps, D = 0, B = la.length; D < B; D++) ca = la[D], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(y) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + z, D, y, ca.width, ca.height, 0, ca.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + z, D, y, ca.width, ca.height, 0, y, R, ca.data);
	            else l ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + z, 0, y, t[z].width, t[z].height, 0, y, R, t[z].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + z, 0, y, y, R, t[z]);
	            b.generateMipmaps && p && a.generateMipmap(a.TEXTURE_CUBE_MAP);
	            n.__version = b.version;
	            if (b.onUpdate) b.onUpdate(b)
	         } else c.activeTexture(a.TEXTURE0 + m), c.bindTexture(a.TEXTURE_CUBE_MAP, n.__image__webglTextureCube)
	      };
	      this.setTextureCubeDynamic = function(b, e) {
	         c.activeTexture(a.TEXTURE0 + e);
	         c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture)
	      };
	      this.setupRenderTarget = function(b) {
	         var e = d.get(b),
	            f = d.get(b.texture);
	         b.addEventListener("dispose", q);
	         f.__webglTexture = a.createTexture();
	         g.textures++;
	         var h = !0 === b.isWebGLRenderTargetCube,
	            m = k(b);
	         if (h) {
	            e.__webglFramebuffer = [];
	            for (var u = 0; 6 > u; u++) e.__webglFramebuffer[u] = a.createFramebuffer()
	         } else e.__webglFramebuffer = a.createFramebuffer();
	         if (h) {
	            c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture);
	            r(a.TEXTURE_CUBE_MAP, b.texture, m);
	            for (u = 0; 6 > u; u++) l(e.__webglFramebuffer[u], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + u);
	            b.texture.generateMipmaps && m && a.generateMipmap(a.TEXTURE_CUBE_MAP);
	            c.bindTexture(a.TEXTURE_CUBE_MAP, null)
	         } else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), r(a.TEXTURE_2D, b.texture, m), l(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), b.texture.generateMipmaps && m && a.generateMipmap(a.TEXTURE_2D), c.bindTexture(a.TEXTURE_2D, null);
	         if (b.depthBuffer) {
	            e = d.get(b);
	            f = !0 === b.isWebGLRenderTargetCube;
	            if (b.depthTexture) {
	               if (f) throw Error("target.depthTexture not supported in Cube render targets");
	               if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
	               a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer);
	               if (!b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
	               d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0);
	               n(b.depthTexture, 0);
	               e = d.get(b.depthTexture).__webglTexture;
	               if (1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0);
	               else if (1027 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0);
	               else throw Error("Unknown depthTexture format")
	            } else if (f) for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++) a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), t(e.__webglDepthbuffer[f], b);
	            else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), t(e.__webglDepthbuffer, b);
	            a.bindFramebuffer(a.FRAMEBUFFER, null)
	         }
	      };
	      this.updateRenderTargetMipmap = function(b) {
	         var e = b.texture;
	         e.generateMipmaps && k(b) && 1003 !== e.minFilter && 1006 !== e.minFilter && (b = b && b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D, e = d.get(e).__webglTexture, c.bindTexture(b, e), a.generateMipmap(b), c.bindTexture(b, null))
	      }
	   }
	   function eg() {
	      var a = {};
	      return {
	         get: function(b) {
	            b = b.uuid;
	            var c = a[b];
	            void 0 === c && (c = {}, a[b] = c);
	            return c
	         },
	         remove: function(b) {
	            delete a[b.uuid]
	         },
	         clear: function() {
	            a = {}
	         }
	      }
	   }
	   function fg(a, b, c) {
	      function d(b, c, d) {
	         var e = new Uint8Array(4),
	            f = a.createTexture();
	         a.bindTexture(b, f);
	         a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST);
	         a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST);
	         for (b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
	         return f
	      }
	      function e(b) {
	         !0 !== v[b] && (a.enable(b), v[b] = !0)
	      }
	      function f(b) {
	         !1 !== v[b] && (a.disable(b), v[b] = !1)
	      }
	      function g(b, d, g, h, k, m, n, u) {
	         0 !== b ? e(a.BLEND) : f(a.BLEND);
	         if (b !== w || u !== ca) 2 === b ? u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : 3 === b ? u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : 4 === b ? u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : u ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), w = b, ca = u;
	         if (5 === b) {
	            k = k || d;
	            m = m || g;
	            n = n || h;
	            if (d !== O || k !== F) a.blendEquationSeparate(c(d), c(k)), O = d, F = k;
	            if (g !== S || h !== E || m !== aa || n !== R) a.blendFuncSeparate(c(g), c(h), c(m), c(n)), S = g, E = h, aa = m, R = n
	         } else R = aa = F = E = S = O = null
	      }
	      function h(b) {
	         la !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), la = b)
	      }
	      function k(b) {
	         0 !== b ? (e(a.CULL_FACE), b !== D && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : f(a.CULL_FACE);
	         D = b
	      }
	      function m(b, c, d) {
	         if (b) {
	            if (e(a.POLYGON_OFFSET_FILL), C !== c || P !== d) a.polygonOffset(c, d), C = c, P = d
	         } else f(a.POLYGON_OFFSET_FILL)
	      }
	      function u(b) {
	         void 0 === b && (b = a.TEXTURE0 + W - 1);
	         T !== b && (a.activeTexture(b), T = b)
	      }
	      var q = new function() {
	            var b = !1,
	               c = new ga,
	               d = null,
	               e = new ga;
	            return {
	               setMask: function(c) {
	                  d === c || b || (a.colorMask(c, c, c, c), d = c)
	               },
	               setLocked: function(a) {
	                  b = a
	               },
	               setClear: function(b, d, f, g, h) {
	                  !0 === h && (b *= g, d *= g, f *= g);
	                  c.set(b, d, f, g);
	                  !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c))
	               },
	               reset: function() {
	                  b = !1;
	                  d = null;
	                  e.set(0, 0, 0, 1)
	               }
	            }
	         },
	         n = new function() {
	            var b = !1,
	               c = null,
	               d = null,
	               g = null;
	            return {
	               setTest: function(b) {
	                  b ? e(a.DEPTH_TEST) : f(a.DEPTH_TEST)
	               },
	               setMask: function(d) {
	                  c === d || b || (a.depthMask(d), c = d)
	               },
	               setFunc: function(b) {
	                  if (d !== b) {
	                     if (b) switch (b) {
	                     case 0:
	                        a.depthFunc(a.NEVER);
	                        break;
	                     case 1:
	                        a.depthFunc(a.ALWAYS);
	                        break;
	                     case 2:
	                        a.depthFunc(a.LESS);
	                        break;
	                     case 3:
	                        a.depthFunc(a.LEQUAL);
	                        break;
	                     case 4:
	                        a.depthFunc(a.EQUAL);
	                        break;
	                     case 5:
	                        a.depthFunc(a.GEQUAL);
	                        break;
	                     case 6:
	                        a.depthFunc(a.GREATER);
	                        break;
	                     case 7:
	                        a.depthFunc(a.NOTEQUAL);
	                        break;
	                     default:
	                        a.depthFunc(a.LEQUAL)
	                     } else a.depthFunc(a.LEQUAL);
	                     d = b
	                  }
	               },
	               setLocked: function(a) {
	                  b = a
	               },
	               setClear: function(b) {
	                  g !== b && (a.clearDepth(b), g = b)
	               },
	               reset: function() {
	                  b = !1;
	                  g = d = c = null
	               }
	            }
	         },
	         r = new function() {
	            var b = !1,
	               c = null,
	               d = null,
	               g = null,
	               h = null,
	               k = null,
	               m = null,
	               n = null,
	               u = null;
	            return {
	               setTest: function(b) {
	                  b ? e(a.STENCIL_TEST) : f(a.STENCIL_TEST)
	               },
	               setMask: function(d) {
	                  c === d || b || (a.stencilMask(d), c = d)
	               },
	               setFunc: function(b, c, e) {
	                  if (d !== b || g !== c || h !== e) a.stencilFunc(b, c, e), d = b, g = c, h = e
	               },
	               setOp: function(b, c, d) {
	                  if (k !== b || m !== c || n !== d) a.stencilOp(b, c, d), k = b, m = c, n = d
	               },
	               setLocked: function(a) {
	                  b = a
	               },
	               setClear: function(b) {
	                  u !== b && (a.clearStencil(b), u = b)
	               },
	               reset: function() {
	                  b = !1;
	                  u = n = m = k = h = g = d = c = null
	               }
	            }
	         },
	         l = a.getParameter(a.MAX_VERTEX_ATTRIBS),
	         t = new Uint8Array(l),
	         p = new Uint8Array(l),
	         x = new Uint8Array(l),
	         v = {},
	         G = null,
	         w = null,
	         O = null,
	         S = null,
	         E = null,
	         F = null,
	         aa = null,
	         R = null,
	         ca = !1,
	         la = null,
	         D = null,
	         B = null,
	         C = null,
	         P = null,
	         K = null,
	         W = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
	         l = parseFloat(/^WebGL\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]),
	         ba = 1 <= parseFloat(l),
	         T = null,
	         Q = {},
	         I = new ga,
	         H = new ga,
	         J = {};
	      J[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1);
	      J[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
	      return {
	         buffers: {
	            color: q,
	            depth: n,
	            stencil: r
	         },
	         init: function() {
	            q.setClear(0, 0, 0, 1);
	            n.setClear(1);
	            r.setClear(0);
	            e(a.DEPTH_TEST);
	            n.setFunc(3);
	            h(!1);
	            k(1);
	            e(a.CULL_FACE);
	            e(a.BLEND);
	            g(1)
	         },
	         initAttributes: function() {
	            for (var a = 0, b = t.length; a < b; a++) t[a] = 0
	         },
	         enableAttribute: function(c) {
	            t[c] = 1;
	            0 === p[c] && (a.enableVertexAttribArray(c), p[c] = 1);
	            0 !== x[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), x[c] = 0)
	         },
	         enableAttributeAndDivisor: function(c, d) {
	            t[c] = 1;
	            0 === p[c] && (a.enableVertexAttribArray(c), p[c] = 1);
	            x[c] !== d && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, d), x[c] = d)
	         },
	         disableUnusedAttributes: function() {
	            for (var b = 0, c = p.length; b !== c; ++b) p[b] !== t[b] && (a.disableVertexAttribArray(b), p[b] = 0)
	         },
	         enable: e,
	         disable: f,
	         getCompressedTextureFormats: function() {
	            if (null === G && (G = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1"))) for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) G.push(c[d]);
	            return G
	         },
	         setBlending: g,
	         setMaterial: function(b) {
	            2 === b.side ? f(a.CULL_FACE) : e(a.CULL_FACE);
	            h(1 === b.side);
	            !0 === b.transparent ? g(b.blending, b.blendEquation, b.blendSrc, b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha) : g(0);
	            n.setFunc(b.depthFunc);
	            n.setTest(b.depthTest);
	            n.setMask(b.depthWrite);
	            q.setMask(b.colorWrite);
	            m(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits)
	         },
	         setFlipSided: h,
	         setCullFace: k,
	         setLineWidth: function(b) {
	            b !== B && (ba && a.lineWidth(b), B = b)
	         },
	         setPolygonOffset: m,
	         getScissorTest: function() {
	            return K
	         },
	         setScissorTest: function(b) {
	            (K = b) ? e(a.SCISSOR_TEST) : f(a.SCISSOR_TEST)
	         },
	         activeTexture: u,
	         bindTexture: function(b, c) {
	            null === T && u();
	            var d = Q[T];
	            void 0 === d && (d = {
	               type: void 0,
	               texture: void 0
	            }, Q[T] = d);
	            if (d.type !== b || d.texture !== c) a.bindTexture(b, c || J[b]), d.type = b, d.texture = c
	         },
	         compressedTexImage2D: function() {
	            try {
	               a.compressedTexImage2D.apply(a, arguments)
	            } catch (b) {
	               console.error(b)
	            }
	         },
	         texImage2D: function() {
	            try {
	               a.texImage2D.apply(a, arguments)
	            } catch (b) {
	               console.error(b)
	            }
	         },
	         scissor: function(b) {
	            !1 === I.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), I.copy(b))
	         },
	         viewport: function(b) {
	            !1 === H.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), H.copy(b))
	         },
	         reset: function() {
	            for (var b = 0; b < p.length; b++) 1 === p[b] && (a.disableVertexAttribArray(b), p[b] = 0);
	            v = {};
	            T = G = null;
	            Q = {};
	            D = la = w = null;
	            q.reset();
	            n.reset();
	            r.reset()
	         }
	      }
	   }
	   function gg(a, b, c) {
	      function d(b) {
	         if ("highp" === b) {
	            if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
	            b = "mediump"
	         }
	         return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
	      }
	      var e, f = void 0 !== c.precision ? c.precision : "highp",
	         g = d(f);
	      g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g);
	      c = !0 === c.logarithmicDepthBuffer && !! b.get("EXT_frag_depth");
	      var g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
	         h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
	         k = a.getParameter(a.MAX_TEXTURE_SIZE),
	         m = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
	         u = a.getParameter(a.MAX_VERTEX_ATTRIBS),
	         q = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
	         n = a.getParameter(a.MAX_VARYING_VECTORS),
	         r = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
	         l = 0 < h,
	         t = !! b.get("OES_texture_float");
	      return {
	         getMaxAnisotropy: function() {
	            if (void 0 !== e) return e;
	            var c = b.get("EXT_texture_filter_anisotropic");
	            return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
	         },
	         getMaxPrecision: d,
	         precision: f,
	         logarithmicDepthBuffer: c,
	         maxTextures: g,
	         maxVertexTextures: h,
	         maxTextureSize: k,
	         maxCubemapSize: m,
	         maxAttributes: u,
	         maxVertexUniforms: q,
	         maxVaryings: n,
	         maxFragmentUniforms: r,
	         vertexTextures: l,
	         floatFragmentTextures: t,
	         floatVertexTextures: l && t
	      }
	   }
	   function hg(a) {
	      var b = {};
	      return {
	         get: function(c) {
	            if (void 0 !== b[c]) return b[c];
	            var d;
	            switch (c) {
	            case "WEBGL_depth_texture":
	               d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
	               break;
	            case "EXT_texture_filter_anisotropic":
	               d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
	               break;
	            case "WEBGL_compressed_texture_s3tc":
	               d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
	               break;
	            case "WEBGL_compressed_texture_pvrtc":
	               d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
	               break;
	            case "WEBGL_compressed_texture_etc1":
	               d = a.getExtension("WEBGL_compressed_texture_etc1");
	               break;
	            default:
	               d = a.getExtension(c)
	            }
	            null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
	            return b[c] = d
	         }
	      }
	   }
	   function ig() {
	      function a() {
	         m.value !== d && (m.value = d, m.needsUpdate = 0 < e);
	         c.numPlanes = e;
	         c.numIntersection = 0
	      }
	      function b(a, b, d, e) {
	         var f = null !== a ? a.length : 0,
	            g = null;
	         if (0 !== f) {
	            g = m.value;
	            if (!0 !== e || null === g) {
	               e = d + 4 * f;
	               b = b.matrixWorldInverse;
	               k.getNormalMatrix(b);
	               if (null === g || g.length < e) g = new Float32Array(e);
	               for (e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, k), h.normal.toArray(g, d), g[d + 3] = h.constant
	            }
	            m.value = g;
	            m.needsUpdate = !0
	         }
	         c.numPlanes = f;
	         return g
	      }
	      var c = this,
	         d = null,
	         e = 0,
	         f = !1,
	         g = !1,
	         h = new wa,
	         k = new Ka,
	         m = {
	            value: null,
	            needsUpdate: !1
	         };
	      this.uniform = m;
	      this.numIntersection = this.numPlanes = 0;
	      this.init = function(a, c, g) {
	         var h = 0 !== a.length || c || 0 !== e || f;
	         f = c;
	         d = b(a, g, 0);
	         e = a.length;
	         return h
	      };
	      this.beginShadows = function() {
	         g = !0;
	         b(null)
	      };
	      this.endShadows = function() {
	         g = !1;
	         a()
	      };
	      this.setState = function(c, h, k, r, l, t) {
	         if (!f || null === c || 0 === c.length || g && !k) g ? b(null) : a();
	         else {
	            k = g ? 0 : e;
	            var p = 4 * k,
	               x = l.clippingState || null;
	            m.value = x;
	            x = b(c, r, p, t);
	            for (c = 0; c !== p; ++c) x[c] = d[c];
	            l.clippingState = x;
	            this.numIntersection = h ? this.numPlanes : 0;
	            this.numPlanes += k
	         }
	      }
	   }
	   function Xd(a) {
	      function b() {
	         fa.init();
	         fa.scissor(Q.copy(ha).multiplyScalar(ka));
	         fa.viewport(Z.copy(zc).multiplyScalar(ka));
	         fa.buffers.color.setClear(Ia.r, Ia.g, Ia.b, X, E)
	      }
	      function c() {
	         T = M = null;
	         ba = "";
	         W = -1;
	         fa.reset()
	      }
	      function d(a) {
	         a.preventDefault();
	         c();
	         b();
	         ia.clear();
	         wa.clear()
	      }
	      function e(a) {
	         a = a.target;
	         a.removeEventListener("dispose", e);
	         f(a);
	         ia.remove(a)
	      }
	      function f(a) {
	         var b = ia.get(a).program;
	         a.program = void 0;
	         void 0 !== b && ya.releaseProgram(b)
	      }
	      function g(a, b, c) {
	         a.render(function(a) {
	            C.renderBufferImmediate(a, b, c)
	         })
	      }
	      function h(a, b) {
	         return Math.abs(b[0]) - Math.abs(a[0])
	      }
	      function k(a, b, c) {
	         if (a.visible) {
	            if (a.layers.test(b.layers)) if (a.isLight) aa.push(a);
	            else if (a.isSprite) a.frustumCulled && !ma.intersectsSprite(a) || D.push(a);
	            else if (a.isLensFlare) B.push(a);
	            else if (a.isImmediateRenderObject) c && Qa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ld), R.push(a, null, a.material, Qa.z, null);
	            else if (a.isMesh || a.isLine || a.isPoints) if (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || ma.intersectsObject(a)) {
	               c && Qa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(ld);
	               var d = wa.update(a),
	                  e = a.material;
	               if (Array.isArray(e)) for (var f = d.groups, g = 0, h = f.length; g < h; g++) {
	                  var m = f[g],
	                     n = e[m.materialIndex];
	                  n && n.visible && R.push(a, d, n, Qa.z, m)
	               } else e.visible && R.push(a, d, e, Qa.z, null)
	            }
	            a = a.children;
	            g = 0;
	            for (h = a.length; g < h; g++) k(a[g], b, c)
	         }
	      }
	      function m(a, b, c, d) {
	         for (var e = 0, f = a.length; e < f; e++) {
	            var g = a[e],
	               h = g.object,
	               k = g.geometry,
	               m = void 0 === d ? g.material : d,
	               g = g.group;
	            h.onBeforeRender(C, b, c, k, m, g);
	            if (c.isArrayCamera && c.enabled) for (var n = c.cameras, q = 0, r = n.length; q < r; q++) {
	               var l = n[q],
	                  t = l.bounds;
	               C.setViewport(t.x * N * ka, t.y * da * ka, t.z * N * ka, t.w * da * ka);
	               C.setScissor(t.x * N * ka, t.y * da * ka, t.z * N * ka, t.w * da * ka);
	               C.setScissorTest(!0);
	               u(h, b, l, k, m, g)
	            } else u(h, b, c, k, m, g);
	            h.onAfterRender(C, b, c, k, m, g)
	         }
	      }
	      function u(a, b, c, d, e, f) {
	         a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld);
	         a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
	         a.isImmediateRenderObject ? (fa.setMaterial(e), b = n(c, b.fog, e, a), ba = "", g(a, b, e)) : C.renderBufferDirect(c, b.fog, d, e, a, f)
	      }
	      function q(a, b, c) {
	         var d = ia.get(a);
	         c = ya.getParameters(a, ea, b, Pa.numPlanes, Pa.numIntersection, c);
	         var g = ya.getProgramCode(a, c),
	            h = d.program,
	            k = !0;
	         if (void 0 === h) a.addEventListener("dispose", e);
	         else if (h.code !== g) f(a);
	         else {
	            if (void 0 !== c.shaderID) return;
	            k = !1
	         }
	         k && (c.shaderID ? (h = ab[c.shaderID], d.__webglShader = {
	            name: a.type,
	            uniforms: Ha.clone(h.uniforms),
	            vertexShader: h.vertexShader,
	            fragmentShader: h.fragmentShader
	         }) : d.__webglShader = {
	            name: a.type,
	            uniforms: a.uniforms,
	            vertexShader: a.vertexShader,
	            fragmentShader: a.fragmentShader
	         }, a.__webglShader = d.__webglShader, h = ya.acquireProgram(a, c, g), d.program = h, a.program = h);
	         c = h.getAttributes();
	         if (a.morphTargets) for (g = a.numSupportedMorphTargets = 0; g < C.maxMorphTargets; g++) 0 <= c["morphTarget" + g] && a.numSupportedMorphTargets++;
	         if (a.morphNormals) for (g = a.numSupportedMorphNormals = 0; g < C.maxMorphNormals; g++) 0 <= c["morphNormal" + g] && a.numSupportedMorphNormals++;
	         c = d.__webglShader.uniforms;
	         if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = Pa.numPlanes, d.numIntersection = Pa.numIntersection, c.clippingPlanes = Pa.uniform;
	         d.fog = b;
	         d.lightsHash = ea.hash;
	         a.lights && (c.ambientLightColor.value = ea.ambient, c.directionalLights.value = ea.directional, c.spotLights.value = ea.spot, c.rectAreaLights.value = ea.rectArea, c.pointLights.value = ea.point, c.hemisphereLights.value = ea.hemi, c.directionalShadowMap.value = ea.directionalShadowMap, c.directionalShadowMatrix.value = ea.directionalShadowMatrix, c.spotShadowMap.value = ea.spotShadowMap, c.spotShadowMatrix.value = ea.spotShadowMatrix, c.pointShadowMap.value = ea.pointShadowMap, c.pointShadowMatrix.value = ea.pointShadowMatrix);
	         a = d.program.getUniforms();
	         a = fb.seqWithValue(a.seq, c);
	         d.uniformsList = a
	      }
	      function n(a, b, c, d) {
	         U = 0;
	         var e = ia.get(c);
	         kd && (Wd || a !== T) && Pa.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === T && c.id === W);
	         !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : c.lights && e.lightsHash !== ea.hash ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes === Pa.numPlanes && e.numIntersection === Pa.numIntersection || (c.needsUpdate = !0));
	         c.needsUpdate && (q(c, b, d), c.needsUpdate = !1);
	         var f = !1,
	            g = !1,
	            h = !1,
	            k = e.program,
	            m = k.getUniforms(),
	            n = e.__webglShader.uniforms;
	         k.id !== M && (A.useProgram(k.program), M = k.id, h = g = f = !0);
	         c.id !== W && (W = c.id, g = !0);
	         if (f || a !== T) {
	            m.setValue(A, "projectionMatrix", a.projectionMatrix);
	            na.logarithmicDepthBuffer && m.setValue(A, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
	            a !== T && (T = a, h = g = !0);
	            if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) f = m.map.cameraPosition, void 0 !== f && f.setValue(A, Qa.setFromMatrixPosition(a.matrixWorld));
	            (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && m.setValue(A, "viewMatrix", a.matrixWorldInverse);
	            m.setValue(A, "toneMappingExposure", C.toneMappingExposure);
	            m.setValue(A, "toneMappingWhitePoint", C.toneMappingWhitePoint)
	         }
	         if (c.skinning && (m.setOptional(A, d, "bindMatrix"), m.setOptional(A, d, "bindMatrixInverse"), a = d.skeleton)) if (f = a.bones, na.floatVertexTextures) {
	            if (void 0 === a.boneTexture) {
	               var f = Math.sqrt(4 * f.length),
	                  f = Y.nextPowerOfTwo(Math.ceil(f)),
	                  f = Math.max(f, 4),
	                  u = new Float32Array(f * f * 4);
	               u.set(a.boneMatrices);
	               var t = new eb(u, f, f, 1023, 1015);
	               a.boneMatrices = u;
	               a.boneTexture = t;
	               a.boneTextureSize = f
	            }
	            m.setValue(A, "boneTexture", a.boneTexture);
	            m.setValue(A, "boneTextureSize", a.boneTextureSize)
	         } else m.setOptional(A, a, "boneMatrices");
	         if (g) {
	            c.lights && (g = h, n.ambientLightColor.needsUpdate = g, n.directionalLights.needsUpdate = g, n.pointLights.needsUpdate = g, n.spotLights.needsUpdate = g, n.rectAreaLights.needsUpdate = g, n.hemisphereLights.needsUpdate = g);
	            b && c.fog && (n.fogColor.value = b.color, b.isFog ? (n.fogNear.value = b.near, n.fogFar.value = b.far) : b.isFogExp2 && (n.fogDensity.value = b.density));
	            if (c.isMeshBasicMaterial || c.isMeshLambertMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.isMeshNormalMaterial || c.isMeshDepthMaterial) {
	               n.opacity.value = c.opacity;
	               n.diffuse.value = c.color;
	               c.emissive && n.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity);
	               n.map.value = c.map;
	               n.specularMap.value = c.specularMap;
	               n.alphaMap.value = c.alphaMap;
	               c.lightMap && (n.lightMap.value = c.lightMap, n.lightMapIntensity.value = c.lightMapIntensity);
	               c.aoMap && (n.aoMap.value = c.aoMap, n.aoMapIntensity.value = c.aoMapIntensity);
	               var p;
	               c.map ? p = c.map : c.specularMap ? p = c.specularMap : c.displacementMap ? p = c.displacementMap : c.normalMap ? p = c.normalMap : c.bumpMap ? p = c.bumpMap : c.roughnessMap ? p = c.roughnessMap : c.metalnessMap ? p = c.metalnessMap : c.alphaMap ? p = c.alphaMap : c.emissiveMap && (p = c.emissiveMap);
	               void 0 !== p && (p.isWebGLRenderTarget && (p = p.texture), b = p.offset, p = p.repeat, n.offsetRepeat.value.set(b.x, b.y, p.x, p.y));
	               n.envMap.value = c.envMap;
	               n.flipEnvMap.value = c.envMap && c.envMap.isCubeTexture ? -1 : 1;
	               n.reflectivity.value = c.reflectivity;
	               n.refractionRatio.value = c.refractionRatio
	            }
	            c.isLineBasicMaterial ? (n.diffuse.value = c.color, n.opacity.value = c.opacity) : c.isLineDashedMaterial ? (n.diffuse.value = c.color, n.opacity.value = c.opacity, n.dashSize.value = c.dashSize, n.totalSize.value = c.dashSize + c.gapSize, n.scale.value = c.scale) : c.isPointsMaterial ? (n.diffuse.value = c.color, n.opacity.value = c.opacity, n.size.value = c.size * ka, n.scale.value = .5 * da, n.map.value = c.map, null !== c.map && (p = c.map.offset, c = c.map.repeat, n.offsetRepeat.value.set(p.x, p.y, c.x, c.y))) : c.isMeshLambertMaterial ? c.emissiveMap && (n.emissiveMap.value = c.emissiveMap) : c.isMeshToonMaterial ? (r(n, c), c.gradientMap && (n.gradientMap.value = c.gradientMap)) : c.isMeshPhongMaterial ? r(n, c) : c.isMeshPhysicalMaterial ? (n.clearCoat.value = c.clearCoat, n.clearCoatRoughness.value = c.clearCoatRoughness, l(n, c)) : c.isMeshStandardMaterial ? l(n, c) : c.isMeshDepthMaterial ? c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias) : c.isMeshNormalMaterial && (c.bumpMap && (n.bumpMap.value = c.bumpMap, n.bumpScale.value = c.bumpScale), c.normalMap && (n.normalMap.value = c.normalMap, n.normalScale.value.copy(c.normalScale)), c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias));
	            void 0 !== n.ltcMat && (n.ltcMat.value = V.LTC_MAT_TEXTURE);
	            void 0 !== n.ltcMag && (n.ltcMag.value = V.LTC_MAG_TEXTURE);
	            fb.upload(A, e.uniformsList, n, C)
	         }
	         m.setValue(A, "modelViewMatrix", d.modelViewMatrix);
	         m.setValue(A, "normalMatrix", d.normalMatrix);
	         m.setValue(A, "modelMatrix", d.matrixWorld);
	         return k
	      }
	      function r(a, b) {
	         a.specular.value = b.specular;
	         a.shininess.value = Math.max(b.shininess, 1e-4);
	         b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
	         b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale);
	         b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale));
	         b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias)
	      }
	      function l(a, b) {
	         a.roughness.value = b.roughness;
	         a.metalness.value = b.metalness;
	         b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
	         b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
	         b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
	         b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale);
	         b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale));
	         b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
	         b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
	      }
	      function t(a, b) {
	         var c, d, e, f, g = 0,
	            h = 0,
	            k = 0,
	            m, n, u, q = b.matrixWorldInverse,
	            l = 0,
	            r = 0,
	            t = 0,
	            z = 0,
	            p = 0;
	         c = 0;
	         for (d = a.length; c < d; c++) if (e = a[c], f = e.color, m = e.intensity, n = e.distance, u = e.shadow && e.shadow.map ? e.shadow.map.texture : null, e.isAmbientLight) g += f.r * m, h += f.g * m, k += f.b * m;
	         else if (e.isDirectionalLight) {
	            var v = Ba.get(e);
	            v.color.copy(e.color).multiplyScalar(e.intensity);
	            v.direction.setFromMatrixPosition(e.matrixWorld);
	            Qa.setFromMatrixPosition(e.target.matrixWorld);
	            v.direction.sub(Qa);
	            v.direction.transformDirection(q);
	            if (v.shadow = e.castShadow) f = e.shadow, v.shadowBias = f.bias, v.shadowRadius = f.radius, v.shadowMapSize = f.mapSize;
	            ea.directionalShadowMap[l] = u;
	            ea.directionalShadowMatrix[l] = e.shadow.matrix;
	            ea.directional[l] = v;
	            l++
	         } else if (e.isSpotLight) {
	            v = Ba.get(e);
	            v.position.setFromMatrixPosition(e.matrixWorld);
	            v.position.applyMatrix4(q);
	            v.color.copy(f).multiplyScalar(m);
	            v.distance = n;
	            v.direction.setFromMatrixPosition(e.matrixWorld);
	            Qa.setFromMatrixPosition(e.target.matrixWorld);
	            v.direction.sub(Qa);
	            v.direction.transformDirection(q);
	            v.coneCos = Math.cos(e.angle);
	            v.penumbraCos = Math.cos(e.angle * (1 - e.penumbra));
	            v.decay = 0 === e.distance ? 0 : e.decay;
	            if (v.shadow = e.castShadow) f = e.shadow, v.shadowBias = f.bias, v.shadowRadius = f.radius, v.shadowMapSize = f.mapSize;
	            ea.spotShadowMap[t] = u;
	            ea.spotShadowMatrix[t] = e.shadow.matrix;
	            ea.spot[t] = v;
	            t++
	         } else if (e.isRectAreaLight) v = Ba.get(e), v.color.copy(f).multiplyScalar(m / (e.width * e.height)), v.position.setFromMatrixPosition(e.matrixWorld), v.position.applyMatrix4(q), ra.identity(), qa.copy(e.matrixWorld), qa.premultiply(q), ra.extractRotation(qa), v.halfWidth.set(.5 * e.width, 0, 0), v.halfHeight.set(0, .5 * e.height, 0), v.halfWidth.applyMatrix4(ra), v.halfHeight.applyMatrix4(ra), ea.rectArea[z] = v, z++;
	         else if (e.isPointLight) {
	            v = Ba.get(e);
	            v.position.setFromMatrixPosition(e.matrixWorld);
	            v.position.applyMatrix4(q);
	            v.color.copy(e.color).multiplyScalar(e.intensity);
	            v.distance = e.distance;
	            v.decay = 0 === e.distance ? 0 : e.decay;
	            if (v.shadow = e.castShadow) f = e.shadow, v.shadowBias = f.bias, v.shadowRadius = f.radius, v.shadowMapSize = f.mapSize;
	            ea.pointShadowMap[r] = u;
	            ea.pointShadowMatrix[r] = e.shadow.matrix;
	            ea.point[r] = v;
	            r++
	         } else e.isHemisphereLight && (v = Ba.get(e), v.direction.setFromMatrixPosition(e.matrixWorld), v.direction.transformDirection(q), v.direction.normalize(), v.skyColor.copy(e.color).multiplyScalar(m), v.groundColor.copy(e.groundColor).multiplyScalar(m), ea.hemi[p] = v, p++);
	         ea.ambient[0] = g;
	         ea.ambient[1] = h;
	         ea.ambient[2] = k;
	         ea.directional.length = l;
	         ea.spot.length = t;
	         ea.rectArea.length = z;
	         ea.point.length = r;
	         ea.hemi.length = p;
	         ea.hash = l + "," + r + "," + t + "," + z + "," + p + "," + ea.shadows.length
	      }
	      function y(a) {
	         var b;
	         if (1e3 === a) return A.REPEAT;
	         if (1001 === a) return A.CLAMP_TO_EDGE;
	         if (1002 === a) return A.MIRRORED_REPEAT;
	         if (1003 === a) return A.NEAREST;
	         if (1004 === a) return A.NEAREST_MIPMAP_NEAREST;
	         if (1005 === a) return A.NEAREST_MIPMAP_LINEAR;
	         if (1006 === a) return A.LINEAR;
	         if (1007 === a) return A.LINEAR_MIPMAP_NEAREST;
	         if (1008 === a) return A.LINEAR_MIPMAP_LINEAR;
	         if (1009 === a) return A.UNSIGNED_BYTE;
	         if (1017 === a) return A.UNSIGNED_SHORT_4_4_4_4;
	         if (1018 === a) return A.UNSIGNED_SHORT_5_5_5_1;
	         if (1019 === a) return A.UNSIGNED_SHORT_5_6_5;
	         if (1010 === a) return A.BYTE;
	         if (1011 === a) return A.SHORT;
	         if (1012 === a) return A.UNSIGNED_SHORT;
	         if (1013 === a) return A.INT;
	         if (1014 === a) return A.UNSIGNED_INT;
	         if (1015 === a) return A.FLOAT;
	         if (1016 === a && (b = pa.get("OES_texture_half_float"), null !== b)) return b.HALF_FLOAT_OES;
	         if (1021 === a) return A.ALPHA;
	         if (1022 === a) return A.RGB;
	         if (1023 === a) return A.RGBA;
	         if (1024 === a) return A.LUMINANCE;
	         if (1025 === a) return A.LUMINANCE_ALPHA;
	         if (1026 === a) return A.DEPTH_COMPONENT;
	         if (1027 === a) return A.DEPTH_STENCIL;
	         if (100 === a) return A.FUNC_ADD;
	         if (101 === a) return A.FUNC_SUBTRACT;
	         if (102 === a) return A.FUNC_REVERSE_SUBTRACT;
	         if (200 === a) return A.ZERO;
	         if (201 === a) return A.ONE;
	         if (202 === a) return A.SRC_COLOR;
	         if (203 === a) return A.ONE_MINUS_SRC_COLOR;
	         if (204 === a) return A.SRC_ALPHA;
	         if (205 === a) return A.ONE_MINUS_SRC_ALPHA;
	         if (206 === a) return A.DST_ALPHA;
	         if (207 === a) return A.ONE_MINUS_DST_ALPHA;
	         if (208 === a) return A.DST_COLOR;
	         if (209 === a) return A.ONE_MINUS_DST_COLOR;
	         if (210 === a) return A.SRC_ALPHA_SATURATE;
	         if (2001 === a || 2002 === a || 2003 === a || 2004 === a) if (b = pa.get("WEBGL_compressed_texture_s3tc"), null !== b) {
	            if (2001 === a) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
	            if (2002 === a) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
	            if (2003 === a) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
	            if (2004 === a) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
	         }
	         if (2100 === a || 2101 === a || 2102 === a || 2103 === a) if (b = pa.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
	            if (2100 === a) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
	            if (2101 === a) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
	            if (2102 === a) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
	            if (2103 === a) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
	         }
	         if (2151 === a && (b = pa.get("WEBGL_compressed_texture_etc1"), null !== b)) return b.COMPRESSED_RGB_ETC1_WEBGL;
	         if (103 === a || 104 === a) if (b = pa.get("EXT_blend_minmax"), null !== b) {
	            if (103 === a) return b.MIN_EXT;
	            if (104 === a) return b.MAX_EXT
	         }
	         return 1020 === a && (b = pa.get("WEBGL_depth_texture"), null !== b) ? b.UNSIGNED_INT_24_8_WEBGL : 0
	      }
	      console.log("THREE.WebGLRenderer", "85");
	      a = a || {};
	      var x = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
	         v = void 0 !== a.context ? a.context : null,
	         G = void 0 !== a.alpha ? a.alpha : !1,
	         w = void 0 !== a.depth ? a.depth : !0,
	         O = void 0 !== a.stencil ? a.stencil : !0,
	         S = void 0 !== a.antialias ? a.antialias : !1,
	         E = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
	         F = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
	         aa = [],
	         R = null,
	         ca = new Float32Array(8),
	         D = [],
	         B = [];
	      this.domElement = x;
	      this.context = null;
	      this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
	      this.clippingPlanes = [];
	      this.localClippingEnabled = !1;
	      this.gammaFactor = 2;
	      this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
	      this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
	      this.maxMorphTargets = 8;
	      this.maxMorphNormals = 4;
	      var C = this,
	         M = null,
	         P = null,
	         K = null,
	         W = -1,
	         ba = "",
	         T = null,
	         Q = new ga,
	         L = null,
	         Z = new ga,
	         U = 0,
	         Ia = new H(0),
	         X = 0,
	         N = x.width,
	         da = x.height,
	         ka = 1,
	         ha = new ga(0, 0, N, da),
	         Pe = !1,
	         zc = new ga(0, 0, N, da),
	         ma = new jd,
	         Pa = new ig,
	         kd = !1,
	         Wd = !1,
	         ld = new J,
	         Qa = new p,
	         qa = new J,
	         ra = new J,
	         ea = {
	            hash: "",
	            ambient: [0, 0, 0],
	            directional: [],
	            directionalShadowMap: [],
	            directionalShadowMatrix: [],
	            spot: [],
	            spotShadowMap: [],
	            spotShadowMatrix: [],
	            rectArea: [],
	            point: [],
	            pointShadowMap: [],
	            pointShadowMatrix: [],
	            hemi: [],
	            shadows: []
	         },
	         va = {
	            geometries: 0,
	            textures: 0
	         },
	         oa = {
	            frame: 0,
	            calls: 0,
	            vertices: 0,
	            faces: 0,
	            points: 0
	         };
	      this.info = {
	         render: oa,
	         memory: va,
	         programs: null
	      };
	      var A;
	      try {
	         G = {
	            alpha: G,
	            depth: w,
	            stencil: O,
	            antialias: S,
	            premultipliedAlpha: E,
	            preserveDrawingBuffer: F
	         };
	         A = v || x.getContext("webgl", G) || x.getContext("experimental-webgl", G);
	         if (null === A) {
	            if (null !== x.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
	            throw "Error creating WebGL context."
	         }
	         void 0 === A.getShaderPrecisionFormat && (A.getShaderPrecisionFormat = function() {
	            return {
	               rangeMin: 1,
	               rangeMax: 1,
	               precision: 1
	            }
	         });
	         x.addEventListener("webglcontextlost", d, !1)
	      } catch (jg) {
	         console.error("THREE.WebGLRenderer: " + jg)
	      }
	      var pa = new hg(A);
	      pa.get("WEBGL_depth_texture");
	      pa.get("OES_texture_float");
	      pa.get("OES_texture_float_linear");
	      pa.get("OES_texture_half_float");
	      pa.get("OES_texture_half_float_linear");
	      pa.get("OES_standard_derivatives");
	      pa.get("ANGLE_instanced_arrays");
	      pa.get("OES_element_index_uint") && (I.MaxIndex = 4294967296);
	      var na = new gg(A, pa, a),
	         fa = new fg(A, pa, y),
	         ia = new eg,
	         sa = new dg(A, pa, fa, ia, na, y, va),
	         Aa = new Mf(A),
	         Da = new Tf(A, Aa, va),
	         wa = new Vf(A, Da, oa),
	         ya = new cg(this, na),
	         Ba = new Uf,
	         Ga = new Qf;
	      this.info.programs = ya.programs;
	      var Ka = new Sf(A, pa, oa),
	         La = new Rf(A, pa, oa),
	         Fa, za, ta, ua;
	      b();
	      this.context = A;
	      this.capabilities = na;
	      this.extensions = pa;
	      this.properties = ia;
	      this.state = fa;
	      var Ja = new Je(this, ea, wa, na);
	      this.shadowMap = Ja;
	      var Ma = new Jf(this, D),
	         Oa = new If(this, B);
	      this.getContext = function() {
	         return A
	      };
	      this.getContextAttributes = function() {
	         return A.getContextAttributes()
	      };
	      this.forceContextLoss = function() {
	         var a = pa.get("WEBGL_lose_context");
	         a && a.loseContext()
	      };
	      this.getMaxAnisotropy = function() {
	         return na.getMaxAnisotropy()
	      };
	      this.getPrecision = function() {
	         return na.precision
	      };
	      this.getPixelRatio = function() {
	         return ka
	      };
	      this.setPixelRatio = function(a) {
	         void 0 !== a && (ka = a, this.setSize(zc.z, zc.w, !1))
	      };
	      this.getSize = function() {
	         return {
	            width: N,
	            height: da
	         }
	      };
	      this.setSize = function(a, b, c) {
	         N = a;
	         da = b;
	         x.width = a * ka;
	         x.height = b * ka;
	         !1 !== c && (x.style.width = a + "px", x.style.height = b + "px");
	         this.setViewport(0, 0, a, b)
	      };
	      this.setViewport = function(a, b, c, d) {
	         fa.viewport(zc.set(a, b, c, d))
	      };
	      this.setScissor = function(a, b, c, d) {
	         fa.scissor(ha.set(a, b, c, d))
	      };
	      this.setScissorTest = function(a) {
	         fa.setScissorTest(Pe = a)
	      };
	      this.getClearColor = function() {
	         return Ia
	      };
	      this.setClearColor = function(a, b) {
	         Ia.set(a);
	         X = void 0 !== b ? b : 1;
	         fa.buffers.color.setClear(Ia.r, Ia.g, Ia.b, X, E)
	      };
	      this.getClearAlpha = function() {
	         return X
	      };
	      this.setClearAlpha = function(a) {
	         X = a;
	         fa.buffers.color.setClear(Ia.r, Ia.g, Ia.b, X, E)
	      };
	      this.clear = function(a, b, c) {
	         var d = 0;
	         if (void 0 === a || a) d |= A.COLOR_BUFFER_BIT;
	         if (void 0 === b || b) d |= A.DEPTH_BUFFER_BIT;
	         if (void 0 === c || c) d |= A.STENCIL_BUFFER_BIT;
	         A.clear(d)
	      };
	      this.clearColor = function() {
	         this.clear(!0, !1, !1)
	      };
	      this.clearDepth = function() {
	         this.clear(!1, !0, !1)
	      };
	      this.clearStencil = function() {
	         this.clear(!1, !1, !0)
	      };
	      this.clearTarget = function(a, b, c, d) {
	         this.setRenderTarget(a);
	         this.clear(b, c, d)
	      };
	      this.resetGLState = c;
	      this.dispose = function() {
	         x.removeEventListener("webglcontextlost", d, !1);
	         Ga.dispose()
	      };
	      this.renderBufferImmediate = function(a, b, c) {
	         fa.initAttributes();
	         var d = ia.get(a);
	         a.hasPositions && !d.position && (d.position = A.createBuffer());
	         a.hasNormals && !d.normal && (d.normal = A.createBuffer());
	         a.hasUvs && !d.uv && (d.uv = A.createBuffer());
	         a.hasColors && !d.color && (d.color = A.createBuffer());
	         b = b.getAttributes();
	         a.hasPositions && (A.bindBuffer(A.ARRAY_BUFFER, d.position), A.bufferData(A.ARRAY_BUFFER, a.positionArray, A.DYNAMIC_DRAW), fa.enableAttribute(b.position), A.vertexAttribPointer(b.position, 3, A.FLOAT, !1, 0, 0));
	         if (a.hasNormals) {
	            A.bindBuffer(A.ARRAY_BUFFER, d.normal);
	            if (!c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && 1 === c.shading) for (var e = 0, f = 3 * a.count; e < f; e += 9) {
	               var g = a.normalArray,
	                  h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3,
	                  k = (g[e + 1] + g[e + 4] + g[e + 7]) / 3,
	                  m = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
	               g[e + 0] = h;
	               g[e + 1] = k;
	               g[e + 2] = m;
	               g[e + 3] = h;
	               g[e + 4] = k;
	               g[e + 5] = m;
	               g[e + 6] = h;
	               g[e + 7] = k;
	               g[e + 8] = m
	            }
	            A.bufferData(A.ARRAY_BUFFER, a.normalArray, A.DYNAMIC_DRAW);
	            fa.enableAttribute(b.normal);
	            A.vertexAttribPointer(b.normal, 3, A.FLOAT, !1, 0, 0)
	         }
	         a.hasUvs && c.map && (A.bindBuffer(A.ARRAY_BUFFER, d.uv), A.bufferData(A.ARRAY_BUFFER, a.uvArray, A.DYNAMIC_DRAW), fa.enableAttribute(b.uv), A.vertexAttribPointer(Aa.uv, 2, A.FLOAT, !1, 0, 0));
	         a.hasColors && 0 !== c.vertexColors && (A.bindBuffer(A.ARRAY_BUFFER, d.color), A.bufferData(A.ARRAY_BUFFER, a.colorArray, A.DYNAMIC_DRAW), fa.enableAttribute(b.color), A.vertexAttribPointer(b.color, 3, A.FLOAT, !1, 0, 0));
	         fa.disableUnusedAttributes();
	         A.drawArrays(A.TRIANGLES, 0, a.count);
	         a.count = 0
	      };
	      this.renderBufferDirect = function(a, b, c, d, e, f) {
	         fa.setMaterial(d);
	         var g = n(a, b, d, e);
	         a = c.id + "_" + g.id + "_" + (!0 === d.wireframe);
	         var k = !1;
	         a !== ba && (ba = a, k = !0);
	         b = e.morphTargetInfluences;
	         if (void 0 !== b) {
	            var m = [];
	            a = 0;
	            for (var u = b.length; a < u; a++) k = b[a], m.push([k, a]);
	            m.sort(h);
	            8 < m.length && (m.length = 8);
	            var q = c.morphAttributes;
	            a = 0;
	            for (u = m.length; a < u; a++) k = m[a], ca[a] = k[0], 0 !== k[0] ? (b = k[1], !0 === d.morphTargets && q.position && c.addAttribute("morphTarget" + a, q.position[b]), !0 === d.morphNormals && q.normal && c.addAttribute("morphNormal" + a, q.normal[b])) : (!0 === d.morphTargets && c.removeAttribute("morphTarget" + a), !0 === d.morphNormals && c.removeAttribute("morphNormal" + a));
	            a = m.length;
	            for (b = ca.length; a < b; a++) ca[a] = 0;
	            g.getUniforms().setValue(A, "morphTargetInfluences", ca);
	            k = !0
	         }
	         b = c.index;
	         u = c.attributes.position;
	         m = 1;
	         !0 === d.wireframe && (b = Da.getWireframeAttribute(c), m = 2);
	         a = Ka;
	         null !== b && (a = La, a.setIndex(b));
	         if (k) {
	            k = void 0;
	            if (c && c.isInstancedBufferGeometry && null === pa.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
	            else {
	               void 0 === k && (k = 0);
	               fa.initAttributes();
	               var q = c.attributes,
	                  g = g.getAttributes(),
	                  l = d.defaultAttributeValues,
	                  r;
	               for (r in g) {
	                  var t = g[r];
	                  if (0 <= t) {
	                     var v = q[r];
	                     if (void 0 !== v) {
	                        var z = v.normalized,
	                           p = v.itemSize,
	                           w = Aa.get(v),
	                           x = w.buffer,
	                           y = w.type,
	                           w = w.bytesPerElement;
	                        if (v.isInterleavedBufferAttribute) {
	                           var G = v.data,
	                              O = G.stride,
	                              v = v.offset;
	                           G && G.isInstancedInterleavedBuffer ? (fa.enableAttributeAndDivisor(t, G.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = G.meshPerAttribute * G.count)) : fa.enableAttribute(t);
	                           A.bindBuffer(A.ARRAY_BUFFER, x);
	                           A.vertexAttribPointer(t, p, y, z, O * w, (k * O + v) * w)
	                        } else v.isInstancedBufferAttribute ? (fa.enableAttributeAndDivisor(t, v.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = v.meshPerAttribute * v.count)) : fa.enableAttribute(t), A.bindBuffer(A.ARRAY_BUFFER, x), A.vertexAttribPointer(t, p, y, z, 0, k * p * w)
	                     } else if (void 0 !== l && (z = l[r], void 0 !== z)) switch (z.length) {
	                     case 2:
	                        A.vertexAttrib2fv(t, z);
	                        break;
	                     case 3:
	                        A.vertexAttrib3fv(t, z);
	                        break;
	                     case 4:
	                        A.vertexAttrib4fv(t, z);
	                        break;
	                     default:
	                        A.vertexAttrib1fv(t, z)
	                     }
	                  }
	               }
	               fa.disableUnusedAttributes()
	            }
	            null !== b && A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, Aa.get(b).buffer)
	         }
	         r = 0;
	         null !== b ? r = b.count : void 0 !== u && (r = u.count);
	         u = c.drawRange.start * m;
	         k = null !== f ? f.start * m : 0;
	         b = Math.max(u, k);
	         f = Math.max(0, Math.min(r, u + c.drawRange.count * m, k + (null !== f ? f.count * m : Infinity)) - 1 - b + 1);
	         if (0 !== f) {
	            if (e.isMesh) if (!0 === d.wireframe) fa.setLineWidth(d.wireframeLinewidth * (null === P ? ka : 1)), a.setMode(A.LINES);
	            else switch (e.drawMode) {
	            case 0:
	               a.setMode(A.TRIANGLES);
	               break;
	            case 1:
	               a.setMode(A.TRIANGLE_STRIP);
	               break;
	            case 2:
	               a.setMode(A.TRIANGLE_FAN)
	            } else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), fa.setLineWidth(d * (null === P ? ka : 1)), e.isLineSegments ? a.setMode(A.LINES) : e.isLineLoop ? a.setMode(A.LINE_LOOP) : a.setMode(A.LINE_STRIP)) : e.isPoints && a.setMode(A.POINTS);
	            c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, b, f) : a.render(b, f)
	         }
	      };
	      this.compile = function(a, b) {
	         aa = [];
	         a.traverse(function(a) {
	            a.isLight && aa.push(a)
	         });
	         t(aa, b);
	         a.traverse(function(b) {
	            if (b.material) if (Array.isArray(b.material)) for (var c = 0; c < b.material.length; c++) q(b.material[c], a.fog, b);
	            else q(b.material, a.fog, b)
	         })
	      };
	      this.render = function(a, b, c, d) {
	         if (void 0 !== b && !0 !== b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
	         else {
	            ba = "";
	            W = -1;
	            T = null;
	            !0 === a.autoUpdate && a.updateMatrixWorld();
	            b.onBeforeRender(C);
	            null === b.parent && b.updateMatrixWorld();
	            b.matrixWorldInverse.getInverse(b.matrixWorld);
	            ld.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
	            ma.setFromMatrix(ld);
	            aa.length = 0;
	            D.length = 0;
	            B.length = 0;
	            Wd = this.localClippingEnabled;
	            kd = Pa.init(this.clippingPlanes, Wd, b);
	            R = Ga.get(a, b);
	            R.init();
	            k(a, b, C.sortObjects);
	            R.finish();
	            !0 === C.sortObjects && R.sort();
	            kd && Pa.beginShadows();
	            for (var e = aa, f = 0, g = 0, h = e.length; g < h; g++) {
	               var n = e[g];
	               n.castShadow && (ea.shadows[f] = n, f++)
	            }
	            ea.shadows.length = f;
	            Ja.render(a, b);
	            t(aa, b);
	            kd && Pa.endShadows();
	            oa.frame++;
	            oa.calls = 0;
	            oa.vertices = 0;
	            oa.faces = 0;
	            oa.points = 0;
	            void 0 === c && (c = null);
	            this.setRenderTarget(c);
	            e = a.background;
	            null === e ? fa.buffers.color.setClear(Ia.r, Ia.g, Ia.b, X, E) : e && e.isColor && (fa.buffers.color.setClear(e.r, e.g, e.b, 1, E), d = !0);
	            (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
	            e && e.isCubeTexture ? (void 0 === ta && (ta = new xa, ua = new Ca(new kb(5, 5, 5), new Ea({
	               uniforms: ab.cube.uniforms,
	               vertexShader: ab.cube.vertexShader,
	               fragmentShader: ab.cube.fragmentShader,
	               side: 1,
	               depthTest: !1,
	               depthWrite: !1,
	               fog: !1
	            }))), ta.projectionMatrix.copy(b.projectionMatrix), ta.matrixWorld.extractRotation(b.matrixWorld), ta.matrixWorldInverse.getInverse(ta.matrixWorld), ua.material.uniforms.tCube.value = e, ua.modelViewMatrix.multiplyMatrices(ta.matrixWorldInverse, ua.matrixWorld), wa.update(ua), C.renderBufferDirect(ta, null, ua.geometry, ua.material, ua, null)) : e && e.isTexture && (void 0 === Fa && (Fa = new Jb(-1, 1, 1, -1, 0, 1), za = new Ca(new lb(2, 2), new Na({
	               depthTest: !1,
	               depthWrite: !1,
	               fog: !1
	            }))), za.material.map = e, wa.update(za), C.renderBufferDirect(Fa, null, za.geometry, za.material, za, null));
	            d = R.opaque;
	            e = R.transparent;
	            a.overrideMaterial ? (f = a.overrideMaterial, d.length && m(d, a, b, f), e.length && m(e, a, b, f)) : (d.length && m(d, a, b), e.length && m(e, a, b));
	            Ma.render(a, b);
	            Oa.render(a, b, Z);
	            c && sa.updateRenderTargetMipmap(c);
	            fa.buffers.depth.setTest(!0);
	            fa.buffers.depth.setMask(!0);
	            fa.buffers.color.setMask(!0);
	            b.isArrayCamera && b.enabled && C.setScissorTest(!1);
	            b.onAfterRender(C)
	         }
	      };
	      this.setFaceCulling = function(a, b) {
	         fa.setCullFace(a);
	         fa.setFlipSided(0 === b)
	      };
	      this.allocTextureUnit = function() {
	         var a = U;
	         a >= na.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + na.maxTextures);
	         U += 1;
	         return a
	      };
	      this.setTexture2D = function() {
	         var a = !1;
	         return function(b, c) {
	            b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
	            sa.setTexture2D(b, c)
	         }
	      }();
	      this.setTexture = function() {
	         var a = !1;
	         return function(b, c) {
	            a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0);
	            sa.setTexture2D(b, c)
	         }
	      }();
	      this.setTextureCube = function() {
	         var a = !1;
	         return function(b, c) {
	            b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
	            b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? sa.setTextureCube(b, c) : sa.setTextureCubeDynamic(b, c)
	         }
	      }();
	      this.getRenderTarget = function() {
	         return P
	      };
	      this.setRenderTarget = function(a) {
	         (P = a) && void 0 === ia.get(a).__webglFramebuffer && sa.setupRenderTarget(a);
	         var b = a && a.isWebGLRenderTargetCube,
	            c;
	         a ? (c = ia.get(a), c = b ? c.__webglFramebuffer[a.activeCubeFace] : c.__webglFramebuffer, Q.copy(a.scissor), L = a.scissorTest, Z.copy(a.viewport)) : (c = null, Q.copy(ha).multiplyScalar(ka), L = Pe, Z.copy(zc).multiplyScalar(ka));
	         K !== c && (A.bindFramebuffer(A.FRAMEBUFFER, c), K = c);
	         fa.scissor(Q);
	         fa.setScissorTest(L);
	         fa.viewport(Z);
	         b && (b = ia.get(a.texture), A.framebufferTexture2D(A.FRAMEBUFFER, A.COLOR_ATTACHMENT0, A.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, b.__webglTexture, a.activeMipMapLevel))
	      };
	      this.readRenderTargetPixels = function(a, b, c, d, e, f) {
	         if (!1 === (a && a.isWebGLRenderTarget)) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
	         else {
	            var g = ia.get(a).__webglFramebuffer;
	            if (g) {
	               var h = !1;
	               g !== K && (A.bindFramebuffer(A.FRAMEBUFFER, g), h = !0);
	               try {
	                  var k = a.texture,
	                     m = k.format,
	                     n = k.type;
	                  1023 !== m && y(m) !== A.getParameter(A.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === n || y(n) === A.getParameter(A.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === n && (pa.get("OES_texture_float") || pa.get("WEBGL_color_buffer_float")) || 1016 === n && pa.get("EXT_color_buffer_half_float") ? A.checkFramebufferStatus(A.FRAMEBUFFER) === A.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && A.readPixels(b, c, d, e, y(m), y(n), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
	               } finally {
	                  h && A.bindFramebuffer(A.FRAMEBUFFER, K)
	               }
	            }
	         }
	      }
	   }
	   function Kb(a, b) {
	      this.name = "";
	      this.color = new H(a);
	      this.density = void 0 !== b ? b : 25e-5
	   }
	   function Lb(a, b, c) {
	      this.name = "";
	      this.color = new H(a);
	      this.near = void 0 !== b ? b : 1;
	      this.far = void 0 !== c ? c : 1e3
	   }
	   function md() {
	      B.call(this);
	      this.type = "Scene";
	      this.overrideMaterial = this.fog = this.background = null;
	      this.autoUpdate = !0
	   }
	   function Yd(a, b, c, d, e) {
	      B.call(this);
	      this.lensFlares = [];
	      this.positionScreen = new p;
	      this.customUpdateCallback = void 0;
	      void 0 !== a && this.add(a, b, c, d, e)
	   }
	   function cb(a) {
	      Z.call(this);
	      this.type = "SpriteMaterial";
	      this.color = new H(16777215);
	      this.map = null;
	      this.rotation = 0;
	      this.lights = this.fog = !1;
	      this.setValues(a)
	   }
	   function Ac(a) {
	      B.call(this);
	      this.type = "Sprite";
	      this.material = void 0 !== a ? a : new cb
	   }
	   function Bc() {
	      B.call(this);
	      this.type = "LOD";
	      Object.defineProperties(this, {
	         levels: {
	            enumerable: !0,
	            value: []
	         }
	      })
	   }
	   function Cc(a, b) {
	      a = a || [];
	      this.bones = a.slice(0);
	      this.boneMatrices = new Float32Array(16 * this.bones.length);
	      if (void 0 === b) this.calculateInverses();
	      else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
	      else {
	         console.warn("THREE.Skeleton boneInverses is the wrong length.");
	         this.boneInverses = [];
	         for (var c = 0, d = this.bones.length; c < d; c++) this.boneInverses.push(new J)
	      }
	   }
	   function nd() {
	      B.call(this);
	      this.type = "Bone"
	   }
	   function od(a, b) {
	      Ca.call(this, a, b);
	      this.type = "SkinnedMesh";
	      this.bindMode = "attached";
	      this.bindMatrix = new J;
	      this.bindMatrixInverse = new J;
	      var c = this.initBones(),
	         c = new Cc(c);
	      this.bind(c, this.matrixWorld);
	      this.normalizeSkinWeights()
	   }
	   function ha(a) {
	      Z.call(this);
	      this.type = "LineBasicMaterial";
	      this.color = new H(16777215);
	      this.linewidth = 1;
	      this.linejoin = this.linecap = "round";
	      this.lights = !1;
	      this.setValues(a)
	   }
	   function ya(a, b, c) {
	      if (1 === c) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new da(a, b);
	      B.call(this);
	      this.type = "Line";
	      this.geometry = void 0 !== a ? a : new I;
	      this.material = void 0 !== b ? b : new ha({
	         color: 16777215 * Math.random()
	      })
	   }
	   function da(a, b) {
	      ya.call(this, a, b);
	      this.type = "LineSegments"
	   }
	   function pd(a, b) {
	      ya.call(this, a, b);
	      this.type = "LineLoop"
	   }
	   function La(a) {
	      Z.call(this);
	      this.type = "PointsMaterial";
	      this.color = new H(16777215);
	      this.map = null;
	      this.size = 1;
	      this.sizeAttenuation = !0;
	      this.lights = !1;
	      this.setValues(a)
	   }
	   function Mb(a, b) {
	      B.call(this);
	      this.type = "Points";
	      this.geometry = void 0 !== a ? a : new I;
	      this.material = void 0 !== b ? b : new La({
	         color: 16777215 * Math.random()
	      })
	   }
	   function Dc() {
	      B.call(this);
	      this.type = "Group"
	   }
	   function qd(a, b, c, d, e, f, g, h, k) {
	      function m() {
	         requestAnimationFrame(m);
	         a.readyState >= a.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
	      }
	      X.call(this, a, b, c, d, e, f, g, h, k);
	      this.generateMipmaps = !1;
	      var u = this;
	      m()
	   }
	   function Nb(a, b, c, d, e, f, g, h, k, m, u, q) {
	      X.call(this, null, f, g, h, k, m, d, e, u, q);
	      this.image = {
	         width: b,
	         height: c
	      };
	      this.mipmaps = a;
	      this.generateMipmaps = this.flipY = !1
	   }
	   function rd(a, b, c, d, e, f, g, h, k) {
	      X.call(this, a, b, c, d, e, f, g, h, k);
	      this.needsUpdate = !0
	   }
	   function Ec(a, b, c, d, e, f, g, h, k, m) {
	      m = void 0 !== m ? m : 1026;
	      if (1026 !== m && 1027 !== m) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
	      void 0 === c && 1026 === m && (c = 1012);
	      void 0 === c && 1027 === m && (c = 1020);
	      X.call(this, null, d, e, f, g, h, m, c, k);
	      this.image = {
	         width: a,
	         height: b
	      };
	      this.magFilter = void 0 !== g ? g : 1003;
	      this.minFilter = void 0 !== h ? h : 1003;
	      this.generateMipmaps = this.flipY = !1
	   }
	   function Ob(a) {
	      I.call(this);
	      this.type = "WireframeGeometry";
	      var b = [],
	         c, d, e, f, g = [0, 0],
	         h = {},
	         k, m, u = ["a", "b", "c"];
	      if (a && a.isGeometry) {
	         var q = a.faces;
	         c = 0;
	         for (e = q.length; c < e; c++) {
	            var n = q[c];
	            for (d = 0; 3 > d; d++) k = n[u[d]], m = n[u[(d + 1) % 3]], g[0] = Math.min(k, m), g[1] = Math.max(k, m), k = g[0] + "," + g[1], void 0 === h[k] && (h[k] = {
	               index1: g[0],
	               index2: g[1]
	            })
	         }
	         for (k in h) c = h[k], u = a.vertices[c.index1], b.push(u.x, u.y, u.z), u = a.vertices[c.index2], b.push(u.x, u.y, u.z)
	      } else if (a && a.isBufferGeometry) {
	         var r, u = new p;
	         if (null !== a.index) {
	            q = a.attributes.position;
	            n = a.index;
	            r = a.groups;
	            0 === r.length && (r = [{
	               start: 0,
	               count: n.count,
	               materialIndex: 0
	            }]);
	            a = 0;
	            for (f = r.length; a < f; ++a) for (c = r[a], d = c.start, e = c.count, c = d, e = d + e; c < e; c += 3) for (d = 0; 3 > d; d++) k = n.getX(c + d), m = n.getX(c + (d + 1) % 3), g[0] = Math.min(k, m), g[1] = Math.max(k, m), k = g[0] + "," + g[1], void 0 === h[k] && (h[k] = {
	               index1: g[0],
	               index2: g[1]
	            });
	            for (k in h) c = h[k], u.fromBufferAttribute(q, c.index1), b.push(u.x, u.y, u.z), u.fromBufferAttribute(q, c.index2), b.push(u.x, u.y, u.z)
	         } else for (q = a.attributes.position, c = 0, e = q.count / 3; c < e; c++) for (d = 0; 3 > d; d++) h = 3 * c + d, u.fromBufferAttribute(q, h), b.push(u.x, u.y, u.z), h = 3 * c + (d + 1) % 3, u.fromBufferAttribute(q, h), b.push(u.x, u.y, u.z)
	      }
	      this.addAttribute("position", new C(b, 3))
	   }
	   function Fc(a, b, c) {
	      M.call(this);
	      this.type = "ParametricGeometry";
	      this.parameters = {
	         func: a,
	         slices: b,
	         stacks: c
	      };
	      this.fromBufferGeometry(new Pb(a, b, c));
	      this.mergeVertices()
	   }
	   function Pb(a, b, c) {
	      I.call(this);
	      this.type = "ParametricBufferGeometry";
	      this.parameters = {
	         func: a,
	         slices: b,
	         stacks: c
	      };
	      var d = [],
	         e = [],
	         f = [],
	         g = [],
	         h = new p,
	         k = new p,
	         m = new p,
	         u = new p,
	         q = new p,
	         n, r, l = b + 1;
	      for (n = 0; n <= c; n++) {
	         var t = n / c;
	         for (r = 0; r <= b; r++) {
	            var y = r / b,
	               k = a(y, t, k);
	            e.push(k.x, k.y, k.z);
	            0 <= y - 1e-5 ? (m = a(y - 1e-5, t, m), u.subVectors(k, m)) : (m = a(y + 1e-5, t, m), u.subVectors(m, k));
	            0 <= t - 1e-5 ? (m = a(y, t - 1e-5, m), q.subVectors(k, m)) : (m = a(y, t + 1e-5, m), q.subVectors(m, k));
	            h.crossVectors(u, q).normalize();
	            f.push(h.x, h.y, h.z);
	            g.push(y, t)
	         }
	      }
	      for (n = 0; n < c; n++) for (r = 0; r < b; r++) a = n * l + r + 1, h = (n + 1) * l + r + 1, k = (n + 1) * l + r, d.push(n * l + r, a, k), d.push(a, h, k);
	      this.setIndex(d);
	      this.addAttribute("position", new C(e, 3));
	      this.addAttribute("normal", new C(f, 3));
	      this.addAttribute("uv", new C(g, 2))
	   }
	   function Gc(a, b, c, d) {
	      M.call(this);
	      this.type = "PolyhedronGeometry";
	      this.parameters = {
	         vertices: a,
	         indices: b,
	         radius: c,
	         detail: d
	      };
	      this.fromBufferGeometry(new ia(a, b, c, d));
	      this.mergeVertices()
	   }
	   function ia(a, b, c, d) {
	      function e(a) {
	         h.push(a.x, a.y, a.z)
	      }
	      function f(b, c) {
	         var d = 3 * b;
	         c.x = a[d + 0];
	         c.y = a[d + 1];
	         c.z = a[d + 2]
	      }
	      function g(a, b, c, d) {
	         0 > d && 1 === a.x && (k[b] = a.x - 1);
	         0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5)
	      }
	      I.call(this);
	      this.type = "PolyhedronBufferGeometry";
	      this.parameters = {
	         vertices: a,
	         indices: b,
	         radius: c,
	         detail: d
	      };
	      c = c || 1;
	      var h = [],
	         k = [];
	      (function(a) {
	         for (var c = new p, d = new p, g = new p, h = 0; h < b.length; h += 3) {
	            f(b[h + 0], c);
	            f(b[h + 1], d);
	            f(b[h + 2], g);
	            var k = c,
	               l = d,
	               y = g,
	               x = Math.pow(2, a),
	               v = [],
	               G, w;
	            for (G = 0; G <= x; G++) {
	               v[G] = [];
	               var O = k.clone().lerp(y, G / x),
	                  S = l.clone().lerp(y, G / x),
	                  E = x - G;
	               for (w = 0; w <= E; w++) v[G][w] = 0 === w && G === x ? O : O.clone().lerp(S, w / E)
	            }
	            for (G = 0; G < x; G++) for (w = 0; w < 2 * (x - G) - 1; w++) k = Math.floor(w / 2), 0 === w % 2 ? (e(v[G][k + 1]), e(v[G + 1][k]), e(v[G][k])) : (e(v[G][k + 1]), e(v[G + 1][k + 1]), e(v[G + 1][k]))
	         }
	      })(d || 0);
	      (function(a) {
	         for (var b = new p, c = 0; c < h.length; c += 3) b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z
	      })(c);
	      (function() {
	         for (var a = new p, b = 0; b < h.length; b += 3) a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
	         for (var a = new p, b = new p, c = new p, d = new p, e = new D, f = new D, l = new D, y = 0, x = 0; y < h.length; y += 9, x += 6) {
	            a.set(h[y + 0], h[y + 1], h[y + 2]);
	            b.set(h[y + 3], h[y + 4], h[y + 5]);
	            c.set(h[y + 6], h[y + 7], h[y + 8]);
	            e.set(k[x + 0], k[x + 1]);
	            f.set(k[x + 2], k[x + 3]);
	            l.set(k[x + 4], k[x + 5]);
	            d.copy(a).add(b).add(c).divideScalar(3);
	            var v = Math.atan2(d.z, -d.x);
	            g(e, x + 0, a, v);
	            g(f, x + 2, b, v);
	            g(l, x + 4, c, v)
	         }
	         for (a = 0; a < k.length; a += 6) b = k[a + 0], c = k[a + 2], d = k[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (k[a + 0] += 1), .2 > c && (k[a + 2] += 1), .2 > d && (k[a + 4] += 1))
	      })();
	      this.addAttribute("position", new C(h, 3));
	      this.addAttribute("normal", new C(h.slice(), 3));
	      this.addAttribute("uv", new C(k, 2));
	      this.normalizeNormals()
	   }
	   function Hc(a, b) {
	      M.call(this);
	      this.type = "TetrahedronGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      };
	      this.fromBufferGeometry(new Qb(a, b));
	      this.mergeVertices()
	   }
	   function Qb(a, b) {
	      ia.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
	      this.type = "TetrahedronBufferGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      }
	   }
	   function Ic(a, b) {
	      M.call(this);
	      this.type = "OctahedronGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      };
	      this.fromBufferGeometry(new mb(a, b));
	      this.mergeVertices()
	   }
	   function mb(a, b) {
	      ia.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
	      this.type = "OctahedronBufferGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      }
	   }
	   function Jc(a, b) {
	      M.call(this);
	      this.type = "IcosahedronGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      };
	      this.fromBufferGeometry(new Rb(a, b));
	      this.mergeVertices()
	   }
	   function Rb(a, b) {
	      var c = (1 + Math.sqrt(5)) / 2;
	      ia.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
	      this.type = "IcosahedronBufferGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      }
	   }
	   function Kc(a, b) {
	      M.call(this);
	      this.type = "DodecahedronGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      };
	      this.fromBufferGeometry(new Sb(a, b));
	      this.mergeVertices()
	   }
	   function Sb(a, b) {
	      var c = (1 + Math.sqrt(5)) / 2,
	         d = 1 / c;
	      ia.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b);
	      this.type = "DodecahedronBufferGeometry";
	      this.parameters = {
	         radius: a,
	         detail: b
	      }
	   }
	   function Lc(a, b, c, d, e, f) {
	      M.call(this);
	      this.type = "TubeGeometry";
	      this.parameters = {
	         path: a,
	         tubularSegments: b,
	         radius: c,
	         radialSegments: d,
	         closed: e
	      };
	      void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed.");
	      a = new Tb(a, b, c, d, e);
	      this.tangents = a.tangents;
	      this.normals = a.normals;
	      this.binormals = a.binormals;
	      this.fromBufferGeometry(a);
	      this.mergeVertices()
	   }
	   function Tb(a, b, c, d, e) {
	      function f(e) {
	         var f = a.getPointAt(e / b),
	            m = g.normals[e];
	         e = g.binormals[e];
	         for (q = 0; q <= d; q++) {
	            var u = q / d * Math.PI * 2,
	               t = Math.sin(u),
	               u = -Math.cos(u);
	            k.x = u * m.x + t * e.x;
	            k.y = u * m.y + t * e.y;
	            k.z = u * m.z + t * e.z;
	            k.normalize();
	            l.push(k.x, k.y, k.z);
	            h.x = f.x + c * k.x;
	            h.y = f.y + c * k.y;
	            h.z = f.z + c * k.z;
	            n.push(h.x, h.y, h.z)
	         }
	      }
	      I.call(this);
	      this.type = "TubeBufferGeometry";
	      this.parameters = {
	         path: a,
	         tubularSegments: b,
	         radius: c,
	         radialSegments: d,
	         closed: e
	      };
	      b = b || 64;
	      c = c || 1;
	      d = d || 8;
	      e = e || !1;
	      var g = a.computeFrenetFrames(b, e);
	      this.tangents = g.tangents;
	      this.normals = g.normals;
	      this.binormals = g.binormals;
	      var h = new p,
	         k = new p,
	         m = new D,
	         u, q, n = [],
	         l = [],
	         z = [],
	         t = [];
	      for (u = 0; u < b; u++) f(u);
	      f(!1 === e ? b : 0);
	      for (u = 0; u <= b; u++) for (q = 0; q <= d; q++) m.x = u / b, m.y = q / d, z.push(m.x, m.y);
	      (function() {
	         for (q = 1; q <= b; q++) for (u = 1; u <= d; u++) {
	            var a = (d + 1) * q + (u - 1),
	               c = (d + 1) * q + u,
	               e = (d + 1) * (q - 1) + u;
	            t.push((d + 1) * (q - 1) + (u - 1), a, e);
	            t.push(a, c, e)
	         }
	      })();
	      this.setIndex(t);
	      this.addAttribute("position", new C(n, 3));
	      this.addAttribute("normal", new C(l, 3));
	      this.addAttribute("uv", new C(z, 2))
	   }
	   function Mc(a, b, c, d, e, f, g) {
	      M.call(this);
	      this.type = "TorusKnotGeometry";
	      this.parameters = {
	         radius: a,
	         tube: b,
	         tubularSegments: c,
	         radialSegments: d,
	         p: e,
	         q: f
	      };
	      void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
	      this.fromBufferGeometry(new Ub(a, b, c, d, e, f));
	      this.mergeVertices()
	   }
	   function Ub(a, b, c, d, e, f) {
	      function g(a, b, c, d, e) {
	         var f = Math.sin(a);
	         b = c / b * a;
	         c = Math.cos(b);
	         e.x = d * (2 + c) * .5 * Math.cos(a);
	         e.y = d * (2 + c) * f * .5;
	         e.z = d * Math.sin(b) * .5
	      }
	      I.call(this);
	      this.type = "TorusKnotBufferGeometry";
	      this.parameters = {
	         radius: a,
	         tube: b,
	         tubularSegments: c,
	         radialSegments: d,
	         p: e,
	         q: f
	      };
	      a = a || 100;
	      b = b || 40;
	      c = Math.floor(c) || 64;
	      d = Math.floor(d) || 8;
	      e = e || 2;
	      f = f || 3;
	      var h = [],
	         k = [],
	         m = [],
	         u = [],
	         q, n, l = new p,
	         z = new p,
	         t = new p,
	         y = new p,
	         x = new p,
	         v = new p,
	         G = new p;
	      for (q = 0; q <= c; ++q) for (n = q / c * e * Math.PI * 2, g(n, e, f, a, t), g(n + .01, e, f, a, y), v.subVectors(y, t), G.addVectors(y, t), x.crossVectors(v, G), G.crossVectors(x, v), x.normalize(), G.normalize(), n = 0; n <= d; ++n) {
	         var w = n / d * Math.PI * 2,
	            O = -b * Math.cos(w),
	            w = b * Math.sin(w);
	         l.x = t.x + (O * G.x + w * x.x);
	         l.y = t.y + (O * G.y + w * x.y);
	         l.z = t.z + (O * G.z + w * x.z);
	         k.push(l.x, l.y, l.z);
	         z.subVectors(l, t).normalize();
	         m.push(z.x, z.y, z.z);
	         u.push(q / c);
	         u.push(n / d)
	      }
	      for (n = 1; n <= c; n++) for (q = 1; q <= d; q++) a = (d + 1) * n + (q - 1), b = (d + 1) * n + q, e = (d + 1) * (n - 1) + q, h.push((d + 1) * (n - 1) + (q - 1), a, e), h.push(a, b, e);
	      this.setIndex(h);
	      this.addAttribute("position", new C(k, 3));
	      this.addAttribute("normal", new C(m, 3));
	      this.addAttribute("uv", new C(u, 2))
	   }
	   function Nc(a, b, c, d, e) {
	      M.call(this);
	      this.type = "TorusGeometry";
	      this.parameters = {
	         radius: a,
	         tube: b,
	         radialSegments: c,
	         tubularSegments: d,
	         arc: e
	      };
	      this.fromBufferGeometry(new Vb(a, b, c, d, e));
	      this.mergeVertices()
	   }
	   function Vb(a, b, c, d, e) {
	      I.call(this);
	      this.type = "TorusBufferGeometry";
	      this.parameters = {
	         radius: a,
	         tube: b,
	         radialSegments: c,
	         tubularSegments: d,
	         arc: e
	      };
	      a = a || 100;
	      b = b || 40;
	      c = Math.floor(c) || 8;
	      d = Math.floor(d) || 6;
	      e = e || 2 * Math.PI;
	      var f = [],
	         g = [],
	         h = [],
	         k = [],
	         m = new p,
	         u = new p,
	         q = new p,
	         n, l;
	      for (n = 0; n <= c; n++) for (l = 0; l <= d; l++) {
	         var z = l / d * e,
	            t = n / c * Math.PI * 2;
	         u.x = (a + b * Math.cos(t)) * Math.cos(z);
	         u.y = (a + b * Math.cos(t)) * Math.sin(z);
	         u.z = b * Math.sin(t);
	         g.push(u.x, u.y, u.z);
	         m.x = a * Math.cos(z);
	         m.y = a * Math.sin(z);
	         q.subVectors(u, m).normalize();
	         h.push(q.x, q.y, q.z);
	         k.push(l / d);
	         k.push(n / c)
	      }
	      for (n = 1; n <= c; n++) for (l = 1; l <= d; l++) a = (d + 1) * (n - 1) + l - 1, b = (d + 1) * (n - 1) + l, e = (d + 1) * n + l, f.push((d + 1) * n + l - 1, a, e), f.push(a, b, e);
	      this.setIndex(f);
	      this.addAttribute("position", new C(g, 3));
	      this.addAttribute("normal", new C(h, 3));
	      this.addAttribute("uv", new C(k, 2))
	   }
	   function db(a, b) {
	      M.call(this);
	      this.type = "ExtrudeGeometry";
	      this.parameters = {
	         shapes: a,
	         options: b
	      };
	      this.fromBufferGeometry(new Fa(a, b));
	      this.mergeVertices()
	   }
	   function Fa(a, b) {
	      "undefined" !== typeof a && (I.call(this), this.type = "ExtrudeBufferGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeVertexNormals())
	   }
	   function Oc(a, b) {
	      M.call(this);
	      this.type = "TextGeometry";
	      this.parameters = {
	         text: a,
	         parameters: b
	      };
	      this.fromBufferGeometry(new Wb(a, b));
	      this.mergeVertices()
	   }
	   function Wb(a, b) {
	      b = b || {};
	      var c = b.font;
	      if (!1 === (c && c.isFont)) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new M;
	      c = c.generateShapes(a, b.size, b.curveSegments);
	      b.amount = void 0 !== b.height ? b.height : 50;
	      void 0 === b.bevelThickness && (b.bevelThickness = 10);
	      void 0 === b.bevelSize && (b.bevelSize = 8);
	      void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
	      Fa.call(this, c, b);
	      this.type = "TextBufferGeometry"
	   }
	   function Pc(a, b, c, d, e, f, g) {
	      M.call(this);
	      this.type = "SphereGeometry";
	      this.parameters = {
	         radius: a,
	         widthSegments: b,
	         heightSegments: c,
	         phiStart: d,
	         phiLength: e,
	         thetaStart: f,
	         thetaLength: g
	      };
	      this.fromBufferGeometry(new nb(a, b, c, d, e, f, g));
	      this.mergeVertices()
	   }
	   function nb(a, b, c, d, e, f, g) {
	      I.call(this);
	      this.type = "SphereBufferGeometry";
	      this.parameters = {
	         radius: a,
	         widthSegments: b,
	         heightSegments: c,
	         phiStart: d,
	         phiLength: e,
	         thetaStart: f,
	         thetaLength: g
	      };
	      a = a || 50;
	      b = Math.max(3, Math.floor(b) || 8);
	      c = Math.max(2, Math.floor(c) || 6);
	      d = void 0 !== d ? d : 0;
	      e = void 0 !== e ? e : 2 * Math.PI;
	      f = void 0 !== f ? f : 0;
	      g = void 0 !== g ? g : Math.PI;
	      var h = f + g,
	         k, m, u = 0,
	         q = [],
	         n = new p,
	         l = new p,
	         z = [],
	         t = [],
	         y = [],
	         x = [];
	      for (m = 0; m <= c; m++) {
	         var v = [],
	            G = m / c;
	         for (k = 0; k <= b; k++) {
	            var w = k / b;
	            n.x = -a * Math.cos(d + w * e) * Math.sin(f + G * g);
	            n.y = a * Math.cos(f + G * g);
	            n.z = a * Math.sin(d + w * e) * Math.sin(f + G * g);
	            t.push(n.x, n.y, n.z);
	            l.set(n.x, n.y, n.z).normalize();
	            y.push(l.x, l.y, l.z);
	            x.push(w, 1 - G);
	            v.push(u++)
	         }
	         q.push(v)
	      }
	      for (m = 0; m < c; m++) for (k = 0; k < b; k++) a = q[m][k + 1], d = q[m][k], e = q[m + 1][k], g = q[m + 1][k + 1], (0 !== m || 0 < f) && z.push(a, d, g), (m !== c - 1 || h < Math.PI) && z.push(d, e, g);
	      this.setIndex(z);
	      this.addAttribute("position", new C(t, 3));
	      this.addAttribute("normal", new C(y, 3));
	      this.addAttribute("uv", new C(x, 2))
	   }
	   function Qc(a, b, c, d, e, f) {
	      M.call(this);
	      this.type = "RingGeometry";
	      this.parameters = {
	         innerRadius: a,
	         outerRadius: b,
	         thetaSegments: c,
	         phiSegments: d,
	         thetaStart: e,
	         thetaLength: f
	      };
	      this.fromBufferGeometry(new Xb(a, b, c, d, e, f));
	      this.mergeVertices()
	   }
	   function Xb(a, b, c, d, e, f) {
	      I.call(this);
	      this.type = "RingBufferGeometry";
	      this.parameters = {
	         innerRadius: a,
	         outerRadius: b,
	         thetaSegments: c,
	         phiSegments: d,
	         thetaStart: e,
	         thetaLength: f
	      };
	      a = a || 20;
	      b = b || 50;
	      e = void 0 !== e ? e : 0;
	      f = void 0 !== f ? f : 2 * Math.PI;
	      c = void 0 !== c ? Math.max(3, c) : 8;
	      d = void 0 !== d ? Math.max(1, d) : 1;
	      var g = [],
	         h = [],
	         k = [],
	         m = [],
	         u = a,
	         q = (b - a) / d,
	         n = new p,
	         l = new D,
	         z, t;
	      for (z = 0; z <= d; z++) {
	         for (t = 0; t <= c; t++) a = e + t / c * f, n.x = u * Math.cos(a), n.y = u * Math.sin(a), h.push(n.x, n.y, n.z), k.push(0, 0, 1), l.x = (n.x / b + 1) / 2, l.y = (n.y / b + 1) / 2, m.push(l.x, l.y);
	         u += q
	      }
	      for (z = 0; z < d; z++) for (b = z * (c + 1), t = 0; t < c; t++) a = t + b, e = a + c + 1, f = a + c + 2, u = a + 1, g.push(a, e, u), g.push(e, f, u);
	      this.setIndex(g);
	      this.addAttribute("position", new C(h, 3));
	      this.addAttribute("normal", new C(k, 3));
	      this.addAttribute("uv", new C(m, 2))
	   }
	   function Rc(a, b, c, d) {
	      M.call(this);
	      this.type = "LatheGeometry";
	      this.parameters = {
	         points: a,
	         segments: b,
	         phiStart: c,
	         phiLength: d
	      };
	      this.fromBufferGeometry(new Yb(a, b, c, d));
	      this.mergeVertices()
	   }
	   function Yb(a, b, c, d) {
	      I.call(this);
	      this.type = "LatheBufferGeometry";
	      this.parameters = {
	         points: a,
	         segments: b,
	         phiStart: c,
	         phiLength: d
	      };
	      b = Math.floor(b) || 12;
	      c = c || 0;
	      d = d || 2 * Math.PI;
	      d = Y.clamp(d, 0, 2 * Math.PI);
	      var e = [],
	         f = [],
	         g = [],
	         h = 1 / b,
	         k = new p,
	         m = new D,
	         u, q;
	      for (u = 0; u <= b; u++) {
	         q = c + u * h * d;
	         var n = Math.sin(q),
	            l = Math.cos(q);
	         for (q = 0; q <= a.length - 1; q++) k.x = a[q].x * n, k.y = a[q].y, k.z = a[q].x * l, f.push(k.x, k.y, k.z), m.x = u / b, m.y = q / (a.length - 1), g.push(m.x, m.y)
	      }
	      for (u = 0; u < b; u++) for (q = 0; q < a.length - 1; q++) c = q + u * a.length, h = c + a.length, k = c + a.length + 1, m = c + 1, e.push(c, h, m), e.push(h, k, m);
	      this.setIndex(e);
	      this.addAttribute("position", new C(f, 3));
	      this.addAttribute("uv", new C(g, 2));
	      this.computeVertexNormals();
	      if (d === 2 * Math.PI) for (d = this.attributes.normal.array, e = new p, f = new p, g = new p, c = b * a.length * 3, q = u = 0; u < a.length; u++, q += 3) e.x = d[q + 0], e.y = d[q + 1], e.z = d[q + 2], f.x = d[c + q + 0], f.y = d[c + q + 1], f.z = d[c + q + 2], g.addVectors(e, f).normalize(), d[q + 0] = d[c + q + 0] = g.x, d[q + 1] = d[c + q + 1] = g.y, d[q + 2] = d[c + q + 2] = g.z
	   }
	   function Zb(a, b) {
	      M.call(this);
	      this.type = "ShapeGeometry";
	      "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments);
	      this.parameters = {
	         shapes: a,
	         curveSegments: b
	      };
	      this.fromBufferGeometry(new $b(a, b));
	      this.mergeVertices()
	   }
	   function $b(a, b) {
	      function c(a) {
	         var c, h, m = e.length / 3;
	         a = a.extractPoints(b);
	         var l = a.shape,
	            t = a.holes;
	         if (!1 === za.isClockWise(l)) for (l = l.reverse(), a = 0, c = t.length; a < c; a++) h = t[a], !0 === za.isClockWise(h) && (t[a] = h.reverse());
	         var p = za.triangulateShape(l, t);
	         a = 0;
	         for (c = t.length; a < c; a++) h = t[a], l = l.concat(h);
	         a = 0;
	         for (c = l.length; a < c; a++) h = l[a], e.push(h.x, h.y, 0), f.push(0, 0, 1), g.push(h.x, h.y);
	         a = 0;
	         for (c = p.length; a < c; a++) l = p[a], d.push(l[0] + m, l[1] + m, l[2] + m), k += 3
	      }
	      I.call(this);
	      this.type = "ShapeBufferGeometry";
	      this.parameters = {
	         shapes: a,
	         curveSegments: b
	      };
	      b = b || 12;
	      var d = [],
	         e = [],
	         f = [],
	         g = [],
	         h = 0,
	         k = 0;
	      if (!1 === Array.isArray(a)) c(a);
	      else for (var m = 0; m < a.length; m++) c(a[m]), this.addGroup(h, k, m), h += k, k = 0;
	      this.setIndex(d);
	      this.addAttribute("position", new C(e, 3));
	      this.addAttribute("normal", new C(f, 3));
	      this.addAttribute("uv", new C(g, 2))
	   }
	   function ac(a, b) {
	      I.call(this);
	      this.type = "EdgesGeometry";
	      this.parameters = {
	         thresholdAngle: b
	      };
	      var c = [],
	         d = Math.cos(Y.DEG2RAD * (void 0 !== b ? b : 1)),
	         e = [0, 0],
	         f = {},
	         g, h, k = ["a", "b", "c"],
	         m;
	      a.isBufferGeometry ? (m = new M, m.fromBufferGeometry(a)) : m = a.clone();
	      m.mergeVertices();
	      m.computeFaceNormals();
	      var u = m.vertices;
	      m = m.faces;
	      for (var l = 0, n = m.length; l < n; l++) for (var r = m[l], p = 0; 3 > p; p++) g = r[k[p]], h = r[k[(p + 1) % 3]], e[0] = Math.min(g, h), e[1] = Math.max(g, h), g = e[0] + "," + e[1], void 0 === f[g] ? f[g] = {
	         index1: e[0],
	         index2: e[1],
	         face1: l,
	         face2: void 0
	      } : f[g].face2 = l;
	      for (g in f) if (e = f[g], void 0 === e.face2 || m[e.face1].normal.dot(m[e.face2].normal) <= d) k = u[e.index1], c.push(k.x, k.y, k.z), k = u[e.index2], c.push(k.x, k.y, k.z);
	      this.addAttribute("position", new C(c, 3))
	   }
	   function ob(a, b, c, d, e, f, g, h) {
	      M.call(this);
	      this.type = "CylinderGeometry";
	      this.parameters = {
	         radiusTop: a,
	         radiusBottom: b,
	         height: c,
	         radialSegments: d,
	         heightSegments: e,
	         openEnded: f,
	         thetaStart: g,
	         thetaLength: h
	      };
	      this.fromBufferGeometry(new Wa(a, b, c, d, e, f, g, h));
	      this.mergeVertices()
	   }
	   function Wa(a, b, c, d, e, f, g, h) {
	      function k(c) {
	         var e, f, k, t = new D,
	            E = new p,
	            F = 0,
	            aa = !0 === c ? a : b,
	            R = !0 === c ? 1 : -1;
	         f = z;
	         for (e = 1; e <= d; e++) l.push(0, y * R, 0), n.push(0, R, 0), r.push(.5, .5), z++;
	         k = z;
	         for (e = 0; e <= d; e++) {
	            var C = e / d * h + g,
	               B = Math.cos(C),
	               C = Math.sin(C);
	            E.x = aa * C;
	            E.y = y * R;
	            E.z = aa * B;
	            l.push(E.x, E.y, E.z);
	            n.push(0, R, 0);
	            t.x = .5 * B + .5;
	            t.y = .5 * C * R + .5;
	            r.push(t.x, t.y);
	            z++
	         }
	         for (e = 0; e < d; e++) t = f + e, E = k + e, !0 === c ? u.push(E, E + 1, t) : u.push(E + 1, E, t), F += 3;
	         m.addGroup(x, F, !0 === c ? 1 : 2);
	         x += F
	      }
	      I.call(this);
	      this.type = "CylinderBufferGeometry";
	      this.parameters = {
	         radiusTop: a,
	         radiusBottom: b,
	         height: c,
	         radialSegments: d,
	         heightSegments: e,
	         openEnded: f,
	         thetaStart: g,
	         thetaLength: h
	      };
	      var m = this;
	      a = void 0 !== a ? a : 20;
	      b = void 0 !== b ? b : 20;
	      c = void 0 !== c ? c : 100;
	      d = Math.floor(d) || 8;
	      e = Math.floor(e) || 1;
	      f = void 0 !== f ? f : !1;
	      g = void 0 !== g ? g : 0;
	      h = void 0 !== h ? h : 2 * Math.PI;
	      var u = [],
	         l = [],
	         n = [],
	         r = [],
	         z = 0,
	         t = [],
	         y = c / 2,
	         x = 0;
	      (function() {
	         var f, k, w = new p,
	            O = new p,
	            S = 0,
	            E = (b - a) / c;
	         for (k = 0; k <= e; k++) {
	            var F = [],
	               aa = k / e,
	               C = aa * (b - a) + a;
	            for (f = 0; f <= d; f++) {
	               var D = f / d,
	                  B = D * h + g,
	                  I = Math.sin(B),
	                  B = Math.cos(B);
	               O.x = C * I;
	               O.y = -aa * c + y;
	               O.z = C * B;
	               l.push(O.x, O.y, O.z);
	               w.set(I, E, B).normalize();
	               n.push(w.x, w.y, w.z);
	               r.push(D, 1 - aa);
	               F.push(z++)
	            }
	            t.push(F)
	         }
	         for (f = 0; f < d; f++) for (k = 0; k < e; k++) w = t[k + 1][f], O = t[k + 1][f + 1], E = t[k][f + 1], u.push(t[k][f], w, E), u.push(w, O, E), S += 6;
	         m.addGroup(x, S, 0);
	         x += S
	      })();
	      !1 === f && (0 < a && k(!0), 0 < b && k(!1));
	      this.setIndex(u);
	      this.addAttribute("position", new C(l, 3));
	      this.addAttribute("normal", new C(n, 3));
	      this.addAttribute("uv", new C(r, 2))
	   }
	   function Sc(a, b, c, d, e, f, g) {
	      ob.call(this, 0, a, b, c, d, e, f, g);
	      this.type = "ConeGeometry";
	      this.parameters = {
	         radius: a,
	         height: b,
	         radialSegments: c,
	         heightSegments: d,
	         openEnded: e,
	         thetaStart: f,
	         thetaLength: g
	      }
	   }
	   function Tc(a, b, c, d, e, f, g) {
	      Wa.call(this, 0, a, b, c, d, e, f, g);
	      this.type = "ConeBufferGeometry";
	      this.parameters = {
	         radius: a,
	         height: b,
	         radialSegments: c,
	         heightSegments: d,
	         openEnded: e,
	         thetaStart: f,
	         thetaLength: g
	      }
	   }
	   function Uc(a, b, c, d) {
	      M.call(this);
	      this.type = "CircleGeometry";
	      this.parameters = {
	         radius: a,
	         segments: b,
	         thetaStart: c,
	         thetaLength: d
	      };
	      this.fromBufferGeometry(new bc(a, b, c, d));
	      this.mergeVertices()
	   }
	   function bc(a, b, c, d) {
	      I.call(this);
	      this.type = "CircleBufferGeometry";
	      this.parameters = {
	         radius: a,
	         segments: b,
	         thetaStart: c,
	         thetaLength: d
	      };
	      a = a || 50;
	      b = void 0 !== b ? Math.max(3, b) : 8;
	      c = void 0 !== c ? c : 0;
	      d = void 0 !== d ? d : 2 * Math.PI;
	      var e = [],
	         f = [],
	         g = [],
	         h = [],
	         k, m, u = new p,
	         l = new D;
	      f.push(0, 0, 0);
	      g.push(0, 0, 1);
	      h.push(.5, .5);
	      m = 0;
	      for (k = 3; m <= b; m++, k += 3) {
	         var n = c + m / b * d;
	         u.x = a * Math.cos(n);
	         u.y = a * Math.sin(n);
	         f.push(u.x, u.y, u.z);
	         g.push(0, 0, 1);
	         l.x = (f[k] / a + 1) / 2;
	         l.y = (f[k + 1] / a + 1) / 2;
	         h.push(l.x, l.y)
	      }
	      for (k = 1; k <= b; k++) e.push(k, k + 1, 0);
	      this.setIndex(e);
	      this.addAttribute("position", new C(f, 3));
	      this.addAttribute("normal", new C(g, 3));
	      this.addAttribute("uv", new C(h, 2))
	   }
	   function cc(a) {
	      Ea.call(this, {
	         uniforms: Ha.merge([V.lights,
	         {
	            opacity: {
	               value: 1
	            }
	         }]),
	         vertexShader: U.shadow_vert,
	         fragmentShader: U.shadow_frag
	      });
	      this.transparent = this.lights = !0;
	      Object.defineProperties(this, {
	         opacity: {
	            enumerable: !0,
	            get: function() {
	               return this.uniforms.opacity.value
	            },
	            set: function(a) {
	               this.uniforms.opacity.value = a
	            }
	         }
	      });
	      this.setValues(a)
	   }
	   function dc(a) {
	      Ea.call(this, a);
	      this.type = "RawShaderMaterial"
	   }
	   function Ra(a) {
	      Z.call(this);
	      this.defines = {
	         STANDARD: ""
	      };
	      this.type = "MeshStandardMaterial";
	      this.color = new H(16777215);
	      this.metalness = this.roughness = .5;
	      this.lightMap = this.map = null;
	      this.lightMapIntensity = 1;
	      this.aoMap = null;
	      this.aoMapIntensity = 1;
	      this.emissive = new H(0);
	      this.emissiveIntensity = 1;
	      this.bumpMap = this.emissiveMap = null;
	      this.bumpScale = 1;
	      this.normalMap = null;
	      this.normalScale = new D(1, 1);
	      this.displacementMap = null;
	      this.displacementScale = 1;
	      this.displacementBias = 0;
	      this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
	      this.envMapIntensity = 1;
	      this.refractionRatio = .98;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.wireframeLinejoin = this.wireframeLinecap = "round";
	      this.morphNormals = this.morphTargets = this.skinning = !1;
	      this.setValues(a)
	   }
	   function pb(a) {
	      Ra.call(this);
	      this.defines = {
	         PHYSICAL: ""
	      };
	      this.type = "MeshPhysicalMaterial";
	      this.reflectivity = .5;
	      this.clearCoatRoughness = this.clearCoat = 0;
	      this.setValues(a)
	   }
	   function ta(a) {
	      Z.call(this);
	      this.type = "MeshPhongMaterial";
	      this.color = new H(16777215);
	      this.specular = new H(1118481);
	      this.shininess = 30;
	      this.lightMap = this.map = null;
	      this.lightMapIntensity = 1;
	      this.aoMap = null;
	      this.aoMapIntensity = 1;
	      this.emissive = new H(0);
	      this.emissiveIntensity = 1;
	      this.bumpMap = this.emissiveMap = null;
	      this.bumpScale = 1;
	      this.normalMap = null;
	      this.normalScale = new D(1, 1);
	      this.displacementMap = null;
	      this.displacementScale = 1;
	      this.displacementBias = 0;
	      this.envMap = this.alphaMap = this.specularMap = null;
	      this.combine = 0;
	      this.reflectivity = 1;
	      this.refractionRatio = .98;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.wireframeLinejoin = this.wireframeLinecap = "round";
	      this.morphNormals = this.morphTargets = this.skinning = !1;
	      this.setValues(a)
	   }
	   function qb(a) {
	      ta.call(this);
	      this.defines = {
	         TOON: ""
	      };
	      this.type = "MeshToonMaterial";
	      this.gradientMap = null;
	      this.setValues(a)
	   }
	   function rb(a) {
	      Z.call(this, a);
	      this.type = "MeshNormalMaterial";
	      this.bumpMap = null;
	      this.bumpScale = 1;
	      this.normalMap = null;
	      this.normalScale = new D(1, 1);
	      this.displacementMap = null;
	      this.displacementScale = 1;
	      this.displacementBias = 0;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1;
	      this.setValues(a)
	   }
	   function sb(a) {
	      Z.call(this);
	      this.type = "MeshLambertMaterial";
	      this.color = new H(16777215);
	      this.lightMap = this.map = null;
	      this.lightMapIntensity = 1;
	      this.aoMap = null;
	      this.aoMapIntensity = 1;
	      this.emissive = new H(0);
	      this.emissiveIntensity = 1;
	      this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
	      this.combine = 0;
	      this.reflectivity = 1;
	      this.refractionRatio = .98;
	      this.wireframe = !1;
	      this.wireframeLinewidth = 1;
	      this.wireframeLinejoin = this.wireframeLinecap = "round";
	      this.morphNormals = this.morphTargets = this.skinning = !1;
	      this.setValues(a)
	   }
	   function tb(a) {
	      Z.call(this);
	      this.type = "LineDashedMaterial";
	      this.color = new H(16777215);
	      this.scale = this.linewidth = 1;
	      this.dashSize = 3;
	      this.gapSize = 1;
	      this.lights = !1;
	      this.setValues(a)
	   }
	   function Zd(a, b, c) {
	      var d = this,
	         e = !1,
	         f = 0,
	         g = 0;
	      this.onStart = void 0;
	      this.onLoad = a;
	      this.onProgress = b;
	      this.onError = c;
	      this.itemStart = function(a) {
	         g++;
	         if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g);
	         e = !0
	      };
	      this.itemEnd = function(a) {
	         f++;
	         if (void 0 !== d.onProgress) d.onProgress(a, f, g);
	         if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad()
	      };
	      this.itemError = function(a) {
	         if (void 0 !== d.onError) d.onError(a)
	      }
	   }
	   function ua(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function Qe(a) {
	      this.manager = void 0 !== a ? a : Aa;
	      this._parser = null
	   }
	   function $d(a) {
	      this.manager = void 0 !== a ? a : Aa;
	      this._parser = null
	   }
	   function Vc(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function ae(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function sd(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function ma(a, b) {
	      B.call(this);
	      this.type = "Light";
	      this.color = new H(a);
	      this.intensity = void 0 !== b ? b : 1;
	      this.receiveShadow = void 0
	   }
	   function td(a, b, c) {
	      ma.call(this, a, c);
	      this.type = "HemisphereLight";
	      this.castShadow = void 0;
	      this.position.copy(B.DefaultUp);
	      this.updateMatrix();
	      this.groundColor = new H(b)
	   }
	   function ub(a) {
	      this.camera = a;
	      this.bias = 0;
	      this.radius = 1;
	      this.mapSize = new D(512, 512);
	      this.map = null;
	      this.matrix = new J
	   }
	   function ud() {
	      ub.call(this, new xa(50, 1, .5, 500))
	   }
	   function vd(a, b, c, d, e, f) {
	      ma.call(this, a, b);
	      this.type = "SpotLight";
	      this.position.copy(B.DefaultUp);
	      this.updateMatrix();
	      this.target = new B;
	      Object.defineProperty(this, "power", {
	         get: function() {
	            return this.intensity * Math.PI
	         },
	         set: function(a) {
	            this.intensity = a / Math.PI
	         }
	      });
	      this.distance = void 0 !== c ? c : 0;
	      this.angle = void 0 !== d ? d : Math.PI / 3;
	      this.penumbra = void 0 !== e ? e : 0;
	      this.decay = void 0 !== f ? f : 1;
	      this.shadow = new ud
	   }
	   function wd(a, b, c, d) {
	      ma.call(this, a, b);
	      this.type = "PointLight";
	      Object.defineProperty(this, "power", {
	         get: function() {
	            return 4 * this.intensity * Math.PI
	         },
	         set: function(a) {
	            this.intensity = a / (4 * Math.PI)
	         }
	      });
	      this.distance = void 0 !== c ? c : 0;
	      this.decay = void 0 !== d ? d : 1;
	      this.shadow = new ub(new xa(90, 1, .5, 500))
	   }
	   function xd() {
	      ub.call(this, new Jb(-5, 5, 5, -5, .5, 500))
	   }
	   function yd(a, b) {
	      ma.call(this, a, b);
	      this.type = "DirectionalLight";
	      this.position.copy(B.DefaultUp);
	      this.updateMatrix();
	      this.target = new B;
	      this.shadow = new xd
	   }
	   function zd(a, b) {
	      ma.call(this, a, b);
	      this.type = "AmbientLight";
	      this.castShadow = void 0
	   }
	   function Ad(a, b, c, d) {
	      ma.call(this, a, b);
	      this.type = "RectAreaLight";
	      this.position.set(0, 1, 0);
	      this.updateMatrix();
	      this.width = void 0 !== c ? c : 10;
	      this.height = void 0 !== d ? d : 10
	   }
	   function Da(a, b, c, d) {
	      this.parameterPositions = a;
	      this._cachedIndex = 0;
	      this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
	      this.sampleValues = b;
	      this.valueSize = c
	   }
	   function Bd(a, b, c, d) {
	      Da.call(this, a, b, c, d);
	      this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
	   }
	   function Wc(a, b, c, d) {
	      Da.call(this, a, b, c, d)
	   }
	   function Cd(a, b, c, d) {
	      Da.call(this, a, b, c, d)
	   }
	   function vb(a, b, c, d) {
	      if (void 0 === a) throw Error("track name is undefined");
	      if (void 0 === b || 0 === b.length) throw Error("no keyframes in track named " + a);
	      this.name = a;
	      this.times = va.convertArray(b, this.TimeBufferType);
	      this.values = va.convertArray(c, this.ValueBufferType);
	      this.setInterpolation(d || this.DefaultInterpolation);
	      this.validate();
	      this.optimize()
	   }
	   function ec(a, b, c, d) {
	      vb.call(this, a, b, c, d)
	   }
	   function Dd(a, b, c, d) {
	      Da.call(this, a, b, c, d)
	   }
	   function Xc(a, b, c, d) {
	      vb.call(this, a, b, c, d)
	   }
	   function fc(a, b, c, d) {
	      vb.call(this, a, b, c, d)
	   }
	   function Ed(a, b, c, d) {
	      vb.call(this, a, b, c, d)
	   }
	   function Fd(a, b, c) {
	      vb.call(this, a, b, c)
	   }
	   function Gd(a, b, c, d) {
	      vb.call(this, a, b, c, d)
	   }
	   function wb(a, b, c, d) {
	      vb.apply(this, arguments)
	   }
	   function Ba(a, b, c) {
	      this.name = a;
	      this.tracks = c;
	      this.duration = void 0 !== b ? b : -1;
	      this.uuid = Y.generateUUID();
	      0 > this.duration && this.resetDuration();
	      this.optimize()
	   }
	   function Hd(a) {
	      this.manager = void 0 !== a ? a : Aa;
	      this.textures = {}
	   }
	   function be(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function gc() {
	      this.onLoadStart = function() {};
	      this.onLoadProgress = function() {};
	      this.onLoadComplete = function() {}
	   }
	   function ce(a) {
	      "boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0);
	      this.manager = void 0 !== a ? a : Aa;
	      this.withCredentials = !1
	   }
	   function Re(a) {
	      this.manager = void 0 !== a ? a : Aa;
	      this.texturePath = ""
	   }
	   function Se(a, b, c, d, e) {
	      b = .5 * (d - b);
	      e = .5 * (e - c);
	      var f = a * a;
	      return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c
	   }
	   function xb(a, b, c, d) {
	      var e = 1 - a;
	      return e * e * b + 2 * (1 - a) * a * c + a * a * d
	   }
	   function yb(a, b, c, d, e) {
	      var f = 1 - a,
	         g = 1 - a;
	      return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
	   }
	   function na() {
	      this.arcLengthDivisions = 200
	   }
	   function Sa(a, b) {
	      this.arcLengthDivisions = 200;
	      this.v1 = a;
	      this.v2 = b
	   }
	   function Yc() {
	      this.arcLengthDivisions = 200;
	      this.curves = [];
	      this.autoClose = !1
	   }
	   function Xa(a, b, c, d, e, f, g, h) {
	      this.arcLengthDivisions = 200;
	      this.aX = a;
	      this.aY = b;
	      this.xRadius = c;
	      this.yRadius = d;
	      this.aStartAngle = e;
	      this.aEndAngle = f;
	      this.aClockwise = g;
	      this.aRotation = h || 0
	   }
	   function zb(a) {
	      this.arcLengthDivisions = 200;
	      this.points = void 0 === a ? [] : a
	   }
	   function hc(a, b, c, d) {
	      this.arcLengthDivisions = 200;
	      this.v0 = a;
	      this.v1 = b;
	      this.v2 = c;
	      this.v3 = d
	   }
	   function ic(a, b, c) {
	      this.arcLengthDivisions = 200;
	      this.v0 = a;
	      this.v1 = b;
	      this.v2 = c
	   }
	   function Zc(a) {
	      Yc.call(this);
	      this.currentPoint = new D;
	      a && this.fromPoints(a)
	   }
	   function Ab() {
	      Zc.apply(this, arguments);
	      this.holes = []
	   }
	   function de() {
	      this.subPaths = [];
	      this.currentPath = null
	   }
	   function ee(a) {
	      this.data = a
	   }
	   function Te(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function fe(a) {
	      this.manager = void 0 !== a ? a : Aa
	   }
	   function Ue() {
	      this.type = "StereoCamera";
	      this.aspect = 1;
	      this.eyeSep = .064;
	      this.cameraL = new xa;
	      this.cameraL.layers.enable(1);
	      this.cameraL.matrixAutoUpdate = !1;
	      this.cameraR = new xa;
	      this.cameraR.layers.enable(2);
	      this.cameraR.matrixAutoUpdate = !1
	   }
	   function Id(a, b, c) {
	      B.call(this);
	      this.type = "CubeCamera";
	      var d = new xa(90, 1, a, b);
	      d.up.set(0, -1, 0);
	      d.lookAt(new p(1, 0, 0));
	      this.add(d);
	      var e = new xa(90, 1, a, b);
	      e.up.set(0, -1, 0);
	      e.lookAt(new p(-1, 0, 0));
	      this.add(e);
	      var f = new xa(90, 1, a, b);
	      f.up.set(0, 0, 1);
	      f.lookAt(new p(0, 1, 0));
	      this.add(f);
	      var g = new xa(90, 1, a, b);
	      g.up.set(0, 0, -1);
	      g.lookAt(new p(0, -1, 0));
	      this.add(g);
	      var h = new xa(90, 1, a, b);
	      h.up.set(0, -1, 0);
	      h.lookAt(new p(0, 0, 1));
	      this.add(h);
	      var k = new xa(90, 1, a, b);
	      k.up.set(0, -1, 0);
	      k.lookAt(new p(0, 0, -1));
	      this.add(k);
	      this.renderTarget = new Eb(c, c, {
	         format: 1022,
	         magFilter: 1006,
	         minFilter: 1006
	      });
	      this.renderTarget.texture.name = "CubeCamera";
	      this.updateCubeMap = function(a, b) {
	         null === this.parent && this.updateMatrixWorld();
	         var c = this.renderTarget,
	            n = c.texture.generateMipmaps;
	         c.texture.generateMipmaps = !1;
	         c.activeCubeFace = 0;
	         a.render(b, d, c);
	         c.activeCubeFace = 1;
	         a.render(b, e, c);
	         c.activeCubeFace = 2;
	         a.render(b, f, c);
	         c.activeCubeFace = 3;
	         a.render(b, g, c);
	         c.activeCubeFace = 4;
	         a.render(b, h, c);
	         c.texture.generateMipmaps = n;
	         c.activeCubeFace = 5;
	         a.render(b, k, c);
	         a.setRenderTarget(null)
	      }
	   }
	   function ge(a) {
	      xa.call(this);
	      this.enabled = !1;
	      this.cameras = a || []
	   }
	   function he() {
	      B.call(this);
	      this.type = "AudioListener";
	      this.context = ie.getContext();
	      this.gain = this.context.createGain();
	      this.gain.connect(this.context.destination);
	      this.filter = null
	   }
	   function jc(a) {
	      B.call(this);
	      this.type = "Audio";
	      this.context = a.context;
	      this.gain = this.context.createGain();
	      this.gain.connect(a.getInput());
	      this.autoplay = !1;
	      this.buffer = null;
	      this.loop = !1;
	      this.startTime = 0;
	      this.playbackRate = 1;
	      this.isPlaying = !1;
	      this.hasPlaybackControl = !0;
	      this.sourceType = "empty";
	      this.filters = []
	   }
	   function je(a) {
	      jc.call(this, a);
	      this.panner = this.context.createPanner();
	      this.panner.connect(this.gain)
	   }
	   function ke(a, b) {
	      this.analyser = a.context.createAnalyser();
	      this.analyser.fftSize = void 0 !== b ? b : 2048;
	      this.data = new Uint8Array(this.analyser.frequencyBinCount);
	      a.getOutput().connect(this.analyser)
	   }
	   function le(a, b, c) {
	      this.binding = a;
	      this.valueSize = c;
	      a = Float64Array;
	      switch (b) {
	      case "quaternion":
	         b = this._slerp;
	         break;
	      case "string":
	      case "bool":
	         a = Array;
	         b = this._select;
	         break;
	      default:
	         b = this._lerp
	      }
	      this.buffer = new a(4 * c);
	      this._mixBufferRegion = b;
	      this.referenceCount = this.useCount = this.cumulativeWeight = 0
	   }
	   function Ve(a, b, c) {
	      c = c || oa.parseTrackName(b);
	      this._targetGroup = a;
	      this._bindings = a.subscribe_(b, c)
	   }
	   function oa(a, b, c) {
	      this.path = b;
	      this.parsedPath = c || oa.parseTrackName(b);
	      this.node = oa.findNode(a, this.parsedPath.nodeName) || a;
	      this.rootNode = a
	   }
	   function We(a) {
	      this.uuid = Y.generateUUID();
	      this._objects = Array.prototype.slice.call(arguments);
	      this.nCachedObjects_ = 0;
	      var b = {};
	      this._indicesByUUID = b;
	      for (var c = 0, d = arguments.length; c !== d; ++c) b[arguments[c].uuid] = c;
	      this._paths = [];
	      this._parsedPaths = [];
	      this._bindings = [];
	      this._bindingsIndicesByPath = {};
	      var e = this;
	      this.stats = {
	         objects: {
	            get total() {
	               return e._objects.length
	            }, get inUse() {
	               return this.total - e.nCachedObjects_
	            }
	         },
	         get bindingsPerObject() {
	            return e._bindings.length
	         }
	      }
	   }
	   function Xe(a, b, c) {
	      this._mixer = a;
	      this._clip = b;
	      this._localRoot = c || null;
	      a = b.tracks;
	      b = a.length;
	      c = Array(b);
	      for (var d = {
	         endingStart: 2400,
	         endingEnd: 2400
	      }, e = 0; e !== b; ++e) {
	         var f = a[e].createInterpolant(null);
	         c[e] = f;
	         f.settings = d
	      }
	      this._interpolantSettings = d;
	      this._interpolants = c;
	      this._propertyBindings = Array(b);
	      this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
	      this.loop = 2201;
	      this._loopCount = -1;
	      this._startTime = null;
	      this.time = 0;
	      this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
	      this.repetitions = Infinity;
	      this.paused = !1;
	      this.enabled = !0;
	      this.clampWhenFinished = !1;
	      this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
	   }
	   function Ye(a) {
	      this._root = a;
	      this._initMemoryManager();
	      this.time = this._accuIndex = 0;
	      this.timeScale = 1
	   }
	   function Jd(a, b) {
	      "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b);
	      this.value = a
	   }
	   function me() {
	      I.call(this);
	      this.type = "InstancedBufferGeometry";
	      this.maxInstancedCount = void 0
	   }
	   function ne(a, b, c, d) {
	      this.uuid = Y.generateUUID();
	      this.data = a;
	      this.itemSize = b;
	      this.offset = c;
	      this.normalized = !0 === d
	   }
	   function kc(a, b) {
	      this.uuid = Y.generateUUID();
	      this.array = a;
	      this.stride = b;
	      this.count = void 0 !== a ? a.length / b : 0;
	      this.dynamic = !1;
	      this.updateRange = {
	         offset: 0,
	         count: -1
	      };
	      this.onUploadCallback = function() {};
	      this.version = 0
	   }
	   function oe(a, b, c) {
	      kc.call(this, a, b);
	      this.meshPerAttribute = c || 1
	   }
	   function pe(a, b, c) {
	      L.call(this, a, b);
	      this.meshPerAttribute = c || 1
	   }
	   function Ze(a, b, c, d) {
	      this.ray = new hb(a, b);
	      this.near = c || 0;
	      this.far = d || Infinity;
	      this.params = {
	         Mesh: {},
	         Line: {},
	         LOD: {},
	         Points: {
	            threshold: 1
	         },
	         Sprite: {}
	      };
	      Object.defineProperties(this.params, {
	         PointCloud: {
	            get: function() {
	               console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
	               return this.Points
	            }
	         }
	      })
	   }
	   function $e(a, b) {
	      return a.distance - b.distance
	   }
	   function qe(a, b, c, d) {
	      if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
	         a = a.children;
	         d = 0;
	         for (var e = a.length; d < e; d++) qe(a[d], b, c, !0)
	      }
	   }
	   function af(a) {
	      this.autoStart = void 0 !== a ? a : !0;
	      this.elapsedTime = this.oldTime = this.startTime = 0;
	      this.running = !1
	   }
	   function bf(a, b, c) {
	      this.radius = void 0 !== a ? a : 1;
	      this.phi = void 0 !== b ? b : 0;
	      this.theta = void 0 !== c ? c : 0;
	      return this
	   }
	   function cf(a, b, c) {
	      this.radius = void 0 !== a ? a : 1;
	      this.theta = void 0 !== b ? b : 0;
	      this.y = void 0 !== c ? c : 0;
	      return this
	   }
	   function ra(a, b) {
	      Ca.call(this, a, b);
	      this.animationsMap = {};
	      this.animationsList = [];
	      var c = this.geometry.morphTargets.length;
	      this.createAnimation("__default", 0, c - 1, c / 1);
	      this.setAnimationWeight("__default", 1)
	   }
	   function $c(a) {
	      B.call(this);
	      this.material = a;
	      this.render = function(a) {}
	   }
	   function ad(a, b, c, d) {
	      this.object = a;
	      this.size = void 0 !== b ? b : 1;
	      a = void 0 !== c ? c : 16711680;
	      d = void 0 !== d ? d : 1;
	      b = 0;
	      (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count);
	      c = new I;
	      b = new C(6 * b, 3);
	      c.addAttribute("position", b);
	      da.call(this, c, new ha({
	         color: a,
	         linewidth: d
	      }));
	      this.matrixAutoUpdate = !1;
	      this.update()
	   }
	   function lc(a) {
	      B.call(this);
	      this.light = a;
	      this.light.updateMatrixWorld();
	      this.matrix = a.matrixWorld;
	      this.matrixAutoUpdate = !1;
	      a = new I;
	      for (var b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], c = 0, d = 1; 32 > c; c++, d++) {
	         var e = c / 32 * Math.PI * 2,
	            f = d / 32 * Math.PI * 2;
	         b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
	      }
	      a.addAttribute("position", new C(b, 3));
	      b = new ha({
	         fog: !1
	      });
	      this.cone = new da(a, b);
	      this.add(this.cone);
	      this.update()
	   }
	   function mc(a) {
	      this.bones = this.getBoneList(a);
	      for (var b = new I, c = [], d = [], e = new H(0, 0, 1), f = new H(0, 1, 0), g = 0; g < this.bones.length; g++) {
	         var h = this.bones[g];
	         h.parent && h.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), d.push(e.r, e.g, e.b), d.push(f.r, f.g, f.b))
	      }
	      b.addAttribute("position", new C(c, 3));
	      b.addAttribute("color", new C(d, 3));
	      c = new ha({
	         vertexColors: 2,
	         depthTest: !1,
	         depthWrite: !1,
	         transparent: !0
	      });
	      da.call(this, b, c);
	      this.root = a;
	      this.matrix = a.matrixWorld;
	      this.matrixAutoUpdate = !1;
	      this.update()
	   }
	   function nc(a, b) {
	      this.light = a;
	      this.light.updateMatrixWorld();
	      var c = new nb(b, 4, 2),
	         d = new Na({
	            wireframe: !0,
	            fog: !1
	         });
	      d.color.copy(this.light.color);
	      Ca.call(this, c, d);
	      this.matrix = this.light.matrixWorld;
	      this.matrixAutoUpdate = !1
	   }
	   function oc(a) {
	      B.call(this);
	      this.light = a;
	      this.light.updateMatrixWorld();
	      this.matrix = a.matrixWorld;
	      this.matrixAutoUpdate = !1;
	      a = new ha({
	         color: a.color
	      });
	      var b = new I;
	      b.addAttribute("position", new L(new Float32Array(15), 3));
	      this.add(new ya(b, a));
	      this.update()
	   }
	   function pc(a, b) {
	      B.call(this);
	      this.light = a;
	      this.light.updateMatrixWorld();
	      this.matrix = a.matrixWorld;
	      this.matrixAutoUpdate = !1;
	      var c = new mb(b);
	      c.rotateY(.5 * Math.PI);
	      var d = new Na({
	         vertexColors: 2,
	         wireframe: !0
	      }),
	         e = c.getAttribute("position"),
	         e = new Float32Array(3 * e.count);
	      c.addAttribute("color", new L(e, 3));
	      this.add(new Ca(c, d));
	      this.update()
	   }
	   function bd(a, b, c, d) {
	      a = a || 10;
	      b = b || 10;
	      c = new H(void 0 !== c ? c : 4473924);
	      d = new H(void 0 !== d ? d : 8947848);
	      var e = b / 2,
	         f = a / b,
	         g = a / 2;
	      a = [];
	      for (var h = [], k = 0, m = 0, u = -g; k <= b; k++, u += f) {
	         a.push(-g, 0, u, g, 0, u);
	         a.push(u, 0, -g, u, 0, g);
	         var l = k === e ? c : d;
	         l.toArray(h, m);
	         m += 3;
	         l.toArray(h, m);
	         m += 3;
	         l.toArray(h, m);
	         m += 3;
	         l.toArray(h, m);
	         m += 3
	      }
	      b = new I;
	      b.addAttribute("position", new C(a, 3));
	      b.addAttribute("color", new C(h, 3));
	      c = new ha({
	         vertexColors: 2
	      });
	      da.call(this, b, c)
	   }
	   function Kd(a, b, c, d, e, f) {
	      a = a || 10;
	      b = b || 16;
	      c = c || 8;
	      d = d || 64;
	      e = new H(void 0 !== e ? e : 4473924);
	      f = new H(void 0 !== f ? f : 8947848);
	      var g = [],
	         h = [],
	         k, m, u, l, n;
	      for (u = 0; u <= b; u++) m = u / b * 2 * Math.PI, k = Math.sin(m) * a, m = Math.cos(m) * a, g.push(0, 0, 0), g.push(k, 0, m), n = u & 1 ? e : f, h.push(n.r, n.g, n.b), h.push(n.r, n.g, n.b);
	      for (u = 0; u <= c; u++) for (n = u & 1 ? e : f, l = a - a / c * u, b = 0; b < d; b++) m = b / d * 2 * Math.PI, k = Math.sin(m) * l, m = Math.cos(m) * l, g.push(k, 0, m), h.push(n.r, n.g, n.b), m = (b + 1) / d * 2 * Math.PI, k = Math.sin(m) * l, m = Math.cos(m) * l, g.push(k, 0, m), h.push(n.r, n.g, n.b);
	      a = new I;
	      a.addAttribute("position", new C(g, 3));
	      a.addAttribute("color", new C(h, 3));
	      g = new ha({
	         vertexColors: 2
	      });
	      da.call(this, a, g)
	   }
	   function cd(a, b, c, d) {
	      this.object = a;
	      this.size = void 0 !== b ? b : 1;
	      a = void 0 !== c ? c : 16776960;
	      d = void 0 !== d ? d : 1;
	      b = 0;
	      (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
	      c = new I;
	      b = new C(6 * b, 3);
	      c.addAttribute("position", b);
	      da.call(this, c, new ha({
	         color: a,
	         linewidth: d
	      }));
	      this.matrixAutoUpdate = !1;
	      this.update()
	   }
	   function qc(a, b) {
	      B.call(this);
	      this.light = a;
	      this.light.updateMatrixWorld();
	      this.matrix = a.matrixWorld;
	      this.matrixAutoUpdate = !1;
	      void 0 === b && (b = 1);
	      var c = new I;
	      c.addAttribute("position", new C([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
	      var d = new ha({
	         fog: !1
	      });
	      this.add(new ya(c, d));
	      c = new I;
	      c.addAttribute("position", new C([0, 0, 0, 0, 0, 1], 3));
	      this.add(new ya(c, d));
	      this.update()
	   }
	   function dd(a) {
	      function b(a, b, d) {
	         c(a, d);
	         c(b, d)
	      }
	      function c(a, b) {
	         f.push(0, 0, 0);
	         g.push(b.r, b.g, b.b);
	         void 0 === h[a] && (h[a] = []);
	         h[a].push(f.length / 3 - 1)
	      }
	      var d = new I,
	         e = new ha({
	            color: 16777215,
	            vertexColors: 1
	         }),
	         f = [],
	         g = [],
	         h = {},
	         k = new H(16755200),
	         m = new H(16711680),
	         u = new H(43775),
	         l = new H(16777215),
	         n = new H(3355443);
	      b("n1", "n2", k);
	      b("n2", "n4", k);
	      b("n4", "n3", k);
	      b("n3", "n1", k);
	      b("f1", "f2", k);
	      b("f2", "f4", k);
	      b("f4", "f3", k);
	      b("f3", "f1", k);
	      b("n1", "f1", k);
	      b("n2", "f2", k);
	      b("n3", "f3", k);
	      b("n4", "f4", k);
	      b("p", "n1", m);
	      b("p", "n2", m);
	      b("p", "n3", m);
	      b("p", "n4", m);
	      b("u1", "u2", u);
	      b("u2", "u3", u);
	      b("u3", "u1", u);
	      b("c", "t", l);
	      b("p", "c", n);
	      b("cn1", "cn2", n);
	      b("cn3", "cn4", n);
	      b("cf1", "cf2", n);
	      b("cf3", "cf4", n);
	      d.addAttribute("position", new C(f, 3));
	      d.addAttribute("color", new C(g, 3));
	      da.call(this, d, e);
	      this.camera = a;
	      this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
	      this.matrix = a.matrixWorld;
	      this.matrixAutoUpdate = !1;
	      this.pointMap = h;
	      this.update()
	   }
	   function Bb(a, b) {
	      this.object = a;
	      void 0 === b && (b = 16776960);
	      var c = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
	         d = new Float32Array(24),
	         e = new I;
	      e.setIndex(new L(c, 1));
	      e.addAttribute("position", new L(d, 3));
	      da.call(this, e, new ha({
	         color: b
	      }));
	      this.matrixAutoUpdate = !1;
	      this.update()
	   }
	   function Cb(a, b, c, d, e, f) {
	      B.call(this);
	      void 0 === d && (d = 16776960);
	      void 0 === c && (c = 1);
	      void 0 === e && (e = .2 * c);
	      void 0 === f && (f = .2 * e);
	      void 0 === Ld && (Ld = new I, Ld.addAttribute("position", new C([0, 0, 0, 0, 1, 0], 3)), re = new Wa(0, .5, 1, 5, 1), re.translate(0, -.5, 0));
	      this.position.copy(b);
	      this.line = new ya(Ld, new ha({
	         color: d
	      }));
	      this.line.matrixAutoUpdate = !1;
	      this.add(this.line);
	      this.cone = new Ca(re, new Na({
	         color: d
	      }));
	      this.cone.matrixAutoUpdate = !1;
	      this.add(this.cone);
	      this.setDirection(a);
	      this.setLength(c, e, f)
	   }
	   function Md(a) {
	      a = a || 1;
	      var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
	      a = new I;
	      a.addAttribute("position", new C(b, 3));
	      a.addAttribute("color", new C([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
	      b = new ha({
	         vertexColors: 2
	      });
	      da.call(this, a, b)
	   }
	   function se() {
	      var a = 0,
	         b = 0,
	         c = 0,
	         d = 0;
	      return {
	         initCatmullRom: function(e, f, g, h, k) {
	            e = k * (g - e);
	            h = k * (h - f);
	            a = f;
	            b = e;
	            c = -3 * f + 3 * g - 2 * e - h;
	            d = 2 * f - 2 * g + e + h
	         },
	         initNonuniformCatmullRom: function(e, f, g, h, k, m, u) {
	            e = ((f - e) / k - (g - e) / (k + m) + (g - f) / m) * m;
	            h = ((g - f) / m - (h - f) / (m + u) + (h - g) / u) * m;
	            a = f;
	            b = e;
	            c = -3 * f + 3 * g - 2 * e - h;
	            d = 2 * f - 2 * g + e + h
	         },
	         calc: function(e) {
	            var f = e * e;
	            return a + b * e + c * f + d * f * e
	         }
	      }
	   }
	   function Ja(a) {
	      this.arcLengthDivisions = 200;
	      this.points = a || [];
	      this.closed = !1
	   }
	   function ed(a, b, c, d) {
	      this.arcLengthDivisions = 200;
	      this.v0 = a;
	      this.v1 = b;
	      this.v2 = c;
	      this.v3 = d
	   }
	   function fd(a, b, c) {
	      this.arcLengthDivisions = 200;
	      this.v0 = a;
	      this.v1 = b;
	      this.v2 = c
	   }
	   function gd(a, b) {
	      this.arcLengthDivisions = 200;
	      this.v1 = a;
	      this.v2 = b
	   }
	   function Nd(a, b, c, d, e, f) {
	      Xa.call(this, a, b, c, c, d, e, f)
	   }
	   function df(a) {
	      console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
	      Ja.call(this, a);
	      this.type = "catmullrom";
	      this.closed = !0
	   }
	   function ef(a) {
	      console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
	      Ja.call(this, a);
	      this.type = "catmullrom"
	   }
	   function te(a) {
	      console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
	      Ja.call(this, a);
	      this.type = "catmullrom"
	   }
	   void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
	   void 0 === Number.isInteger && (Number.isInteger = function(a) {
	      return "number" === typeof a && isFinite(a) && Math.floor(a) === a
	   });
	   void 0 === Math.sign && (Math.sign = function(a) {
	      return 0 > a ? -1 : 0 < a ? 1 : +a
	   });
	   void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
	      get: function() {
	         return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
	      }
	   });
	   void 0 === Object.assign &&
	   function() {
	      Object.assign = function(a) {
	         if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
	         for (var b = Object(a), c = 1; c < arguments.length; c++) {
	            var d = arguments[c];
	            if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
	         }
	         return b
	      }
	   }();
	   Object.assign(sa.prototype, {
	      addEventListener: function(a, b) {
	         void 0 === this._listeners && (this._listeners = {});
	         var c = this._listeners;
	         void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
	      },
	      hasEventListener: function(a, b) {
	         if (void 0 === this._listeners) return !1;
	         var c = this._listeners;
	         return void 0 !== c[a] && -1 !== c[a].indexOf(b)
	      },
	      removeEventListener: function(a, b) {
	         if (void 0 !== this._listeners) {
	            var c = this._listeners[a];
	            if (void 0 !== c) {
	               var d = c.indexOf(b); - 1 !== d && c.splice(d, 1)
	            }
	         }
	      },
	      dispatchEvent: function(a) {
	         if (void 0 !== this._listeners) {
	            var b = this._listeners[a.type];
	            if (void 0 !== b) {
	               a.target = this;
	               var c = [],
	                  d, e = b.length;
	               for (d = 0; d < e; d++) c[d] = b[d];
	               for (d = 0; d < e; d++) c[d].call(this, a)
	            }
	         }
	      }
	   });
	   var Y = {
	      DEG2RAD: Math.PI / 180,
	      RAD2DEG: 180 / Math.PI,
	      generateUUID: function() {
	         var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
	            b = Array(36),
	            c = 0,
	            d;
	         return function() {
	            for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? b[e] = "-" : 14 === e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 === e ? d & 3 | 8 : d]);
	            return b.join("")
	         }
	      }(),
	      clamp: function(a, b, c) {
	         return Math.max(b, Math.min(c, a))
	      },
	      euclideanModulo: function(a, b) {
	         return (a % b + b) % b
	      },
	      mapLinear: function(a, b, c, d, e) {
	         return d + (a - b) * (e - d) / (c - b)
	      },
	      lerp: function(a, b, c) {
	         return (1 - c) * a + c * b
	      },
	      smoothstep: function(a, b, c) {
	         if (a <= b) return 0;
	         if (a >= c) return 1;
	         a = (a - b) / (c - b);
	         return a * a * (3 - 2 * a)
	      },
	      smootherstep: function(a, b, c) {
	         if (a <= b) return 0;
	         if (a >= c) return 1;
	         a = (a - b) / (c - b);
	         return a * a * a * (a * (6 * a - 15) + 10)
	      },
	      randInt: function(a, b) {
	         return a + Math.floor(Math.random() * (b - a + 1))
	      },
	      randFloat: function(a, b) {
	         return a + Math.random() * (b - a)
	      },
	      randFloatSpread: function(a) {
	         return a * (.5 - Math.random())
	      },
	      degToRad: function(a) {
	         return a * Y.DEG2RAD
	      },
	      radToDeg: function(a) {
	         return a * Y.RAD2DEG
	      },
	      isPowerOfTwo: function(a) {
	         return 0 === (a & a - 1) && 0 !== a
	      },
	      nearestPowerOfTwo: function(a) {
	         return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
	      },
	      nextPowerOfTwo: function(a) {
	         a--;
	         a |= a >> 1;
	         a |= a >> 2;
	         a |= a >> 4;
	         a |= a >> 8;
	         a |= a >> 16;
	         a++;
	         return a
	      }
	   };
	   Object.defineProperties(D.prototype, {
	      width: {
	         get: function() {
	            return this.x
	         },
	         set: function(a) {
	            this.x = a
	         }
	      },
	      height: {
	         get: function() {
	            return this.y
	         },
	         set: function(a) {
	            this.y = a
	         }
	      }
	   });
	   Object.assign(D.prototype, {
	      isVector2: !0,
	      set: function(a, b) {
	         this.x = a;
	         this.y = b;
	         return this
	      },
	      setScalar: function(a) {
	         this.y = this.x = a;
	         return this
	      },
	      setX: function(a) {
	         this.x = a;
	         return this
	      },
	      setY: function(a) {
	         this.y = a;
	         return this
	      },
	      setComponent: function(a, b) {
	         switch (a) {
	         case 0:
	            this.x = b;
	            break;
	         case 1:
	            this.y = b;
	            break;
	         default:
	            throw Error("index is out of range: " + a)
	         }
	         return this
	      },
	      getComponent: function(a) {
	         switch (a) {
	         case 0:
	            return this.x;
	         case 1:
	            return this.y;
	         default:
	            throw Error("index is out of range: " + a)
	         }
	      },
	      clone: function() {
	         return new this.constructor(this.x, this.y)
	      },
	      copy: function(a) {
	         this.x = a.x;
	         this.y = a.y;
	         return this
	      },
	      add: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
	         this.x += a.x;
	         this.y += a.y;
	         return this
	      },
	      addScalar: function(a) {
	         this.x += a;
	         this.y += a;
	         return this
	      },
	      addVectors: function(a, b) {
	         this.x = a.x + b.x;
	         this.y = a.y + b.y;
	         return this
	      },
	      addScaledVector: function(a, b) {
	         this.x += a.x * b;
	         this.y += a.y * b;
	         return this
	      },
	      sub: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
	         this.x -= a.x;
	         this.y -= a.y;
	         return this
	      },
	      subScalar: function(a) {
	         this.x -= a;
	         this.y -= a;
	         return this
	      },
	      subVectors: function(a, b) {
	         this.x = a.x - b.x;
	         this.y = a.y - b.y;
	         return this
	      },
	      multiply: function(a) {
	         this.x *= a.x;
	         this.y *= a.y;
	         return this
	      },
	      multiplyScalar: function(a) {
	         this.x *= a;
	         this.y *= a;
	         return this
	      },
	      divide: function(a) {
	         this.x /= a.x;
	         this.y /= a.y;
	         return this
	      },
	      divideScalar: function(a) {
	         return this.multiplyScalar(1 / a)
	      },
	      min: function(a) {
	         this.x = Math.min(this.x, a.x);
	         this.y = Math.min(this.y, a.y);
	         return this
	      },
	      max: function(a) {
	         this.x = Math.max(this.x, a.x);
	         this.y = Math.max(this.y, a.y);
	         return this
	      },
	      clamp: function(a, b) {
	         this.x = Math.max(a.x, Math.min(b.x, this.x));
	         this.y = Math.max(a.y, Math.min(b.y, this.y));
	         return this
	      },
	      clampScalar: function() {
	         var a = new D,
	            b = new D;
	         return function(c, d) {
	            a.set(c, c);
	            b.set(d, d);
	            return this.clamp(a, b)
	         }
	      }(),
	      clampLength: function(a, b) {
	         var c = this.length();
	         return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
	      },
	      floor: function() {
	         this.x = Math.floor(this.x);
	         this.y = Math.floor(this.y);
	         return this
	      },
	      ceil: function() {
	         this.x = Math.ceil(this.x);
	         this.y = Math.ceil(this.y);
	         return this
	      },
	      round: function() {
	         this.x = Math.round(this.x);
	         this.y = Math.round(this.y);
	         return this
	      },
	      roundToZero: function() {
	         this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
	         this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
	         return this
	      },
	      negate: function() {
	         this.x = -this.x;
	         this.y = -this.y;
	         return this
	      },
	      dot: function(a) {
	         return this.x * a.x + this.y * a.y
	      },
	      lengthSq: function() {
	         return this.x * this.x + this.y * this.y
	      },
	      length: function() {
	         return Math.sqrt(this.x * this.x + this.y * this.y)
	      },
	      lengthManhattan: function() {
	         return Math.abs(this.x) + Math.abs(this.y)
	      },
	      normalize: function() {
	         return this.divideScalar(this.length())
	      },
	      angle: function() {
	         var a = Math.atan2(this.y, this.x);
	         0 > a && (a += 2 * Math.PI);
	         return a
	      },
	      distanceTo: function(a) {
	         return Math.sqrt(this.distanceToSquared(a))
	      },
	      distanceToSquared: function(a) {
	         var b = this.x - a.x;
	         a = this.y - a.y;
	         return b * b + a * a
	      },
	      distanceToManhattan: function(a) {
	         return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
	      },
	      setLength: function(a) {
	         return this.multiplyScalar(a / this.length())
	      },
	      lerp: function(a, b) {
	         this.x += (a.x - this.x) * b;
	         this.y += (a.y - this.y) * b;
	         return this
	      },
	      lerpVectors: function(a, b, c) {
	         return this.subVectors(b, a).multiplyScalar(c).add(a)
	      },
	      equals: function(a) {
	         return a.x === this.x && a.y === this.y
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         this.x = a[b];
	         this.y = a[b + 1];
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         a[b] = this.x;
	         a[b + 1] = this.y;
	         return a
	      },
	      fromBufferAttribute: function(a, b, c) {
	         void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
	         this.x = a.getX(b);
	         this.y = a.getY(b);
	         return this
	      },
	      rotateAround: function(a, b) {
	         var c = Math.cos(b),
	            d = Math.sin(b),
	            e = this.x - a.x,
	            f = this.y - a.y;
	         this.x = e * c - f * d + a.x;
	         this.y = e * d + f * c + a.y;
	         return this
	      }
	   });
	   var jf = 0;
	   X.DEFAULT_IMAGE = void 0;
	   X.DEFAULT_MAPPING = 300;
	   Object.defineProperty(X.prototype, "needsUpdate", {
	      set: function(a) {
	         !0 === a && this.version++
	      }
	   });
	   Object.assign(X.prototype, sa.prototype, {
	      constructor: X,
	      isTexture: !0,
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.name = a.name;
	         this.image = a.image;
	         this.mipmaps = a.mipmaps.slice(0);
	         this.mapping = a.mapping;
	         this.wrapS = a.wrapS;
	         this.wrapT = a.wrapT;
	         this.magFilter = a.magFilter;
	         this.minFilter = a.minFilter;
	         this.anisotropy = a.anisotropy;
	         this.format = a.format;
	         this.type = a.type;
	         this.offset.copy(a.offset);
	         this.repeat.copy(a.repeat);
	         this.generateMipmaps = a.generateMipmaps;
	         this.premultiplyAlpha = a.premultiplyAlpha;
	         this.flipY = a.flipY;
	         this.unpackAlignment = a.unpackAlignment;
	         this.encoding = a.encoding;
	         return this
	      },
	      toJSON: function(a) {
	         if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
	         var b = {
	            metadata: {
	               version: 4.5,
	               type: "Texture",
	               generator: "Texture.toJSON"
	            },
	            uuid: this.uuid,
	            name: this.name,
	            mapping: this.mapping,
	            repeat: [this.repeat.x, this.repeat.y],
	            offset: [this.offset.x, this.offset.y],
	            wrap: [this.wrapS, this.wrapT],
	            minFilter: this.minFilter,
	            magFilter: this.magFilter,
	            anisotropy: this.anisotropy,
	            flipY: this.flipY
	         };
	         if (void 0 !== this.image) {
	            var c = this.image;
	            void 0 === c.uuid && (c.uuid = Y.generateUUID());
	            if (void 0 === a.images[c.uuid]) {
	               var d = a.images,
	                  e = c.uuid,
	                  f = c.uuid,
	                  g;
	               void 0 !== c.toDataURL ? g = c : (g = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), g.width = c.width, g.height = c.height, g.getContext("2d").drawImage(c, 0, 0, c.width, c.height));
	               g = 2048 < g.width || 2048 < g.height ? g.toDataURL("image/jpeg", .6) : g.toDataURL("image/png");
	               d[e] = {
	                  uuid: f,
	                  url: g
	               }
	            }
	            b.image = c.uuid
	         }
	         return a.textures[this.uuid] = b
	      },
	      dispose: function() {
	         this.dispatchEvent({
	            type: "dispose"
	         })
	      },
	      transformUv: function(a) {
	         if (300 === this.mapping) {
	            a.multiply(this.repeat);
	            a.add(this.offset);
	            if (0 > a.x || 1 < a.x) switch (this.wrapS) {
	            case 1e3:
	               a.x -= Math.floor(a.x);
	               break;
	            case 1001:
	               a.x = 0 > a.x ? 0 : 1;
	               break;
	            case 1002:
	               a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
	            }
	            if (0 > a.y || 1 < a.y) switch (this.wrapT) {
	            case 1e3:
	               a.y -= Math.floor(a.y);
	               break;
	            case 1001:
	               a.y = 0 > a.y ? 0 : 1;
	               break;
	            case 1002:
	               a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
	            }
	            this.flipY && (a.y = 1 - a.y)
	         }
	      }
	   });
	   Object.assign(ga.prototype, {
	      isVector4: !0,
	      set: function(a, b, c, d) {
	         this.x = a;
	         this.y = b;
	         this.z = c;
	         this.w = d;
	         return this
	      },
	      setScalar: function(a) {
	         this.w = this.z = this.y = this.x = a;
	         return this
	      },
	      setX: function(a) {
	         this.x = a;
	         return this
	      },
	      setY: function(a) {
	         this.y = a;
	         return this
	      },
	      setZ: function(a) {
	         this.z = a;
	         return this
	      },
	      setW: function(a) {
	         this.w = a;
	         return this
	      },
	      setComponent: function(a, b) {
	         switch (a) {
	         case 0:
	            this.x = b;
	            break;
	         case 1:
	            this.y = b;
	            break;
	         case 2:
	            this.z = b;
	            break;
	         case 3:
	            this.w = b;
	            break;
	         default:
	            throw Error("index is out of range: " + a)
	         }
	         return this
	      },
	      getComponent: function(a) {
	         switch (a) {
	         case 0:
	            return this.x;
	         case 1:
	            return this.y;
	         case 2:
	            return this.z;
	         case 3:
	            return this.w;
	         default:
	            throw Error("index is out of range: " + a)
	         }
	      },
	      clone: function() {
	         return new this.constructor(this.x, this.y, this.z, this.w)
	      },
	      copy: function(a) {
	         this.x = a.x;
	         this.y = a.y;
	         this.z = a.z;
	         this.w = void 0 !== a.w ? a.w : 1;
	         return this
	      },
	      add: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
	         this.x += a.x;
	         this.y += a.y;
	         this.z += a.z;
	         this.w += a.w;
	         return this
	      },
	      addScalar: function(a) {
	         this.x += a;
	         this.y += a;
	         this.z += a;
	         this.w += a;
	         return this
	      },
	      addVectors: function(a, b) {
	         this.x = a.x + b.x;
	         this.y = a.y + b.y;
	         this.z = a.z + b.z;
	         this.w = a.w + b.w;
	         return this
	      },
	      addScaledVector: function(a, b) {
	         this.x += a.x * b;
	         this.y += a.y * b;
	         this.z += a.z * b;
	         this.w += a.w * b;
	         return this
	      },
	      sub: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
	         this.x -= a.x;
	         this.y -= a.y;
	         this.z -= a.z;
	         this.w -= a.w;
	         return this
	      },
	      subScalar: function(a) {
	         this.x -= a;
	         this.y -= a;
	         this.z -= a;
	         this.w -= a;
	         return this
	      },
	      subVectors: function(a, b) {
	         this.x = a.x - b.x;
	         this.y = a.y - b.y;
	         this.z = a.z - b.z;
	         this.w = a.w - b.w;
	         return this
	      },
	      multiplyScalar: function(a) {
	         this.x *= a;
	         this.y *= a;
	         this.z *= a;
	         this.w *= a;
	         return this
	      },
	      applyMatrix4: function(a) {
	         var b = this.x,
	            c = this.y,
	            d = this.z,
	            e = this.w;
	         a = a.elements;
	         this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
	         this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
	         this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
	         this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
	         return this
	      },
	      divideScalar: function(a) {
	         return this.multiplyScalar(1 / a)
	      },
	      setAxisAngleFromQuaternion: function(a) {
	         this.w = 2 * Math.acos(a.w);
	         var b = Math.sqrt(1 - a.w * a.w);
	         1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
	         return this
	      },
	      setAxisAngleFromRotationMatrix: function(a) {
	         var b, c, d;
	         a = a.elements;
	         var e = a[0];
	         d = a[4];
	         var f = a[8],
	            g = a[1],
	            h = a[5],
	            k = a[9];
	         c = a[2];
	         b = a[6];
	         var m = a[10];
	         if (.01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(k - b)) {
	            if (.1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(k + b) && .1 > Math.abs(e + h + m - 3)) return this.set(1, 0, 0, 0), this;
	            a = Math.PI;
	            e = (e + 1) / 2;
	            h = (h + 1) / 2;
	            m = (m + 1) / 2;
	            d = (d + g) / 4;
	            f = (f + c) / 4;
	            k = (k + b) / 4;
	            e > h && e > m ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > m ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : .01 > m ? (c = b = .707106781, d = 0) : (d = Math.sqrt(m), b = f / d, c = k / d);
	            this.set(b, c, d, a);
	            return this
	         }
	         a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));.001 > Math.abs(a) && (a = 1);
	         this.x = (b - k) / a;
	         this.y = (f - c) / a;
	         this.z = (g - d) / a;
	         this.w = Math.acos((e + h + m - 1) / 2);
	         return this
	      },
	      min: function(a) {
	         this.x = Math.min(this.x, a.x);
	         this.y = Math.min(this.y, a.y);
	         this.z = Math.min(this.z, a.z);
	         this.w = Math.min(this.w, a.w);
	         return this
	      },
	      max: function(a) {
	         this.x = Math.max(this.x, a.x);
	         this.y = Math.max(this.y, a.y);
	         this.z = Math.max(this.z, a.z);
	         this.w = Math.max(this.w, a.w);
	         return this
	      },
	      clamp: function(a, b) {
	         this.x = Math.max(a.x, Math.min(b.x, this.x));
	         this.y = Math.max(a.y, Math.min(b.y, this.y));
	         this.z = Math.max(a.z, Math.min(b.z, this.z));
	         this.w = Math.max(a.w, Math.min(b.w, this.w));
	         return this
	      },
	      clampScalar: function() {
	         var a = new ga,
	            b = new ga;
	         return function(c, d) {
	            a.set(c, c, c, c);
	            b.set(d, d, d, d);
	            return this.clamp(a, b)
	         }
	      }(),
	      floor: function() {
	         this.x = Math.floor(this.x);
	         this.y = Math.floor(this.y);
	         this.z = Math.floor(this.z);
	         this.w = Math.floor(this.w);
	         return this
	      },
	      ceil: function() {
	         this.x = Math.ceil(this.x);
	         this.y = Math.ceil(this.y);
	         this.z = Math.ceil(this.z);
	         this.w = Math.ceil(this.w);
	         return this
	      },
	      round: function() {
	         this.x = Math.round(this.x);
	         this.y = Math.round(this.y);
	         this.z = Math.round(this.z);
	         this.w = Math.round(this.w);
	         return this
	      },
	      roundToZero: function() {
	         this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
	         this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
	         this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
	         this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
	         return this
	      },
	      negate: function() {
	         this.x = -this.x;
	         this.y = -this.y;
	         this.z = -this.z;
	         this.w = -this.w;
	         return this
	      },
	      dot: function(a) {
	         return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
	      },
	      lengthSq: function() {
	         return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	      },
	      length: function() {
	         return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	      },
	      lengthManhattan: function() {
	         return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
	      },
	      normalize: function() {
	         return this.divideScalar(this.length())
	      },
	      setLength: function(a) {
	         return this.multiplyScalar(a / this.length())
	      },
	      lerp: function(a, b) {
	         this.x += (a.x - this.x) * b;
	         this.y += (a.y - this.y) * b;
	         this.z += (a.z - this.z) * b;
	         this.w += (a.w - this.w) * b;
	         return this
	      },
	      lerpVectors: function(a, b, c) {
	         return this.subVectors(b, a).multiplyScalar(c).add(a)
	      },
	      equals: function(a) {
	         return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         this.x = a[b];
	         this.y = a[b + 1];
	         this.z = a[b + 2];
	         this.w = a[b + 3];
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         a[b] = this.x;
	         a[b + 1] = this.y;
	         a[b + 2] = this.z;
	         a[b + 3] = this.w;
	         return a
	      },
	      fromBufferAttribute: function(a, b, c) {
	         void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
	         this.x = a.getX(b);
	         this.y = a.getY(b);
	         this.z = a.getZ(b);
	         this.w = a.getW(b);
	         return this
	      }
	   });
	   Object.assign(Db.prototype, sa.prototype, {
	      isWebGLRenderTarget: !0,
	      setSize: function(a, b) {
	         if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose();
	         this.viewport.set(0, 0, a, b);
	         this.scissor.set(0, 0, a, b)
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.width = a.width;
	         this.height = a.height;
	         this.viewport.copy(a.viewport);
	         this.texture = a.texture.clone();
	         this.depthBuffer = a.depthBuffer;
	         this.stencilBuffer = a.stencilBuffer;
	         this.depthTexture = a.depthTexture;
	         return this
	      },
	      dispose: function() {
	         this.dispatchEvent({
	            type: "dispose"
	         })
	      }
	   });
	   Eb.prototype = Object.create(Db.prototype);
	   Eb.prototype.constructor = Eb;
	   Eb.prototype.isWebGLRenderTargetCube = !0;
	   Object.assign(qa, {
	      slerp: function(a, b, c, d) {
	         return c.copy(a).slerp(b, d)
	      },
	      slerpFlat: function(a, b, c, d, e, f, g) {
	         var h = c[d + 0],
	            k = c[d + 1],
	            m = c[d + 2];
	         c = c[d + 3];
	         d = e[f + 0];
	         var u = e[f + 1],
	            l = e[f + 2];
	         e = e[f + 3];
	         if (c !== e || h !== d || k !== u || m !== l) {
	            f = 1 - g;
	            var n = h * d + k * u + m * l + c * e,
	               r = 0 <= n ? 1 : -1,
	               p = 1 - n * n;
	            p > Number.EPSILON && (p = Math.sqrt(p), n = Math.atan2(p, n * r), f = Math.sin(f * n) / p, g = Math.sin(g * n) / p);
	            r *= g;
	            h = h * f + d * r;
	            k = k * f + u * r;
	            m = m * f + l * r;
	            c = c * f + e * r;
	            f === 1 - g && (g = 1 / Math.sqrt(h * h + k * k + m * m + c * c), h *= g, k *= g, m *= g, c *= g)
	         }
	         a[b] = h;
	         a[b + 1] = k;
	         a[b + 2] = m;
	         a[b + 3] = c
	      }
	   });
	   Object.defineProperties(qa.prototype, {
	      x: {
	         get: function() {
	            return this._x
	         },
	         set: function(a) {
	            this._x = a;
	            this.onChangeCallback()
	         }
	      },
	      y: {
	         get: function() {
	            return this._y
	         },
	         set: function(a) {
	            this._y = a;
	            this.onChangeCallback()
	         }
	      },
	      z: {
	         get: function() {
	            return this._z
	         },
	         set: function(a) {
	            this._z = a;
	            this.onChangeCallback()
	         }
	      },
	      w: {
	         get: function() {
	            return this._w
	         },
	         set: function(a) {
	            this._w = a;
	            this.onChangeCallback()
	         }
	      }
	   });
	   Object.assign(qa.prototype, {
	      set: function(a, b, c, d) {
	         this._x = a;
	         this._y = b;
	         this._z = c;
	         this._w = d;
	         this.onChangeCallback();
	         return this
	      },
	      clone: function() {
	         return new this.constructor(this._x, this._y, this._z, this._w)
	      },
	      copy: function(a) {
	         this._x = a.x;
	         this._y = a.y;
	         this._z = a.z;
	         this._w = a.w;
	         this.onChangeCallback();
	         return this
	      },
	      setFromEuler: function(a, b) {
	         if (!1 === (a && a.isEuler)) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
	         var c = a._x,
	            d = a._y,
	            e = a._z,
	            f = a.order,
	            g = Math.cos,
	            h = Math.sin,
	            k = g(c / 2),
	            m = g(d / 2),
	            g = g(e / 2),
	            c = h(c / 2),
	            d = h(d / 2),
	            e = h(e / 2);
	         "XYZ" === f ? (this._x = c * m * g + k * d * e, this._y = k * d * g - c * m * e, this._z = k * m * e + c * d * g, this._w = k * m * g - c * d * e) : "YXZ" === f ? (this._x = c * m * g + k * d * e, this._y = k * d * g - c * m * e, this._z = k * m * e - c * d * g, this._w = k * m * g + c * d * e) : "ZXY" === f ? (this._x = c * m * g - k * d * e, this._y = k * d * g + c * m * e, this._z = k * m * e + c * d * g, this._w = k * m * g - c * d * e) : "ZYX" === f ? (this._x = c * m * g - k * d * e, this._y = k * d * g + c * m * e, this._z = k * m * e - c * d * g, this._w = k * m * g + c * d * e) : "YZX" === f ? (this._x = c * m * g + k * d * e, this._y = k * d * g + c * m * e, this._z = k * m * e - c * d * g, this._w = k * m * g - c * d * e) : "XZY" === f && (this._x = c * m * g - k * d * e, this._y = k * d * g - c * m * e, this._z = k * m * e + c * d * g, this._w = k * m * g + c * d * e);
	         if (!1 !== b) this.onChangeCallback();
	         return this
	      },
	      setFromAxisAngle: function(a, b) {
	         var c = b / 2,
	            d = Math.sin(c);
	         this._x = a.x * d;
	         this._y = a.y * d;
	         this._z = a.z * d;
	         this._w = Math.cos(c);
	         this.onChangeCallback();
	         return this
	      },
	      setFromRotationMatrix: function(a) {
	         var b = a.elements,
	            c = b[0];
	         a = b[4];
	         var d = b[8],
	            e = b[1],
	            f = b[5],
	            g = b[9],
	            h = b[2],
	            k = b[6],
	            b = b[10],
	            m = c + f + b;
	         0 < m ? (c = .5 / Math.sqrt(m + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);
	         this.onChangeCallback();
	         return this
	      },
	      setFromUnitVectors: function() {
	         var a = new p,
	            b;
	         return function(c, d) {
	            void 0 === a && (a = new p);
	            b = c.dot(d) + 1;
	            1e-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
	            this._x = a.x;
	            this._y = a.y;
	            this._z = a.z;
	            this._w = b;
	            return this.normalize()
	         }
	      }(),
	      inverse: function() {
	         return this.conjugate().normalize()
	      },
	      conjugate: function() {
	         this._x *= -1;
	         this._y *= -1;
	         this._z *= -1;
	         this.onChangeCallback();
	         return this
	      },
	      dot: function(a) {
	         return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
	      },
	      lengthSq: function() {
	         return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
	      },
	      length: function() {
	         return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
	      },
	      normalize: function() {
	         var a = this.length();
	         0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
	         this.onChangeCallback();
	         return this
	      },
	      multiply: function(a, b) {
	         return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
	      },
	      premultiply: function(a) {
	         return this.multiplyQuaternions(a, this)
	      },
	      multiplyQuaternions: function(a, b) {
	         var c = a._x,
	            d = a._y,
	            e = a._z,
	            f = a._w,
	            g = b._x,
	            h = b._y,
	            k = b._z,
	            m = b._w;
	         this._x = c * m + f * g + d * k - e * h;
	         this._y = d * m + f * h + e * g - c * k;
	         this._z = e * m + f * k + c * h - d * g;
	         this._w = f * m - c * g - d * h - e * k;
	         this.onChangeCallback();
	         return this
	      },
	      slerp: function(a, b) {
	         if (0 === b) return this;
	         if (1 === b) return this.copy(a);
	         var c = this._x,
	            d = this._y,
	            e = this._z,
	            f = this._w,
	            g = f * a._w + c * a._x + d * a._y + e * a._z;
	         0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
	         if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
	         var h = Math.sqrt(1 - g * g);
	         if (.001 > Math.abs(h)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
	         var k = Math.atan2(h, g),
	            g = Math.sin((1 - b) * k) / h,
	            h = Math.sin(b * k) / h;
	         this._w = f * g + this._w * h;
	         this._x = c * g + this._x * h;
	         this._y = d * g + this._y * h;
	         this._z = e * g + this._z * h;
	         this.onChangeCallback();
	         return this
	      },
	      equals: function(a) {
	         return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         this._x = a[b];
	         this._y = a[b + 1];
	         this._z = a[b + 2];
	         this._w = a[b + 3];
	         this.onChangeCallback();
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         a[b] = this._x;
	         a[b + 1] = this._y;
	         a[b + 2] = this._z;
	         a[b + 3] = this._w;
	         return a
	      },
	      onChange: function(a) {
	         this.onChangeCallback = a;
	         return this
	      },
	      onChangeCallback: function() {}
	   });
	   Object.assign(p.prototype, {
	      isVector3: !0,
	      set: function(a, b, c) {
	         this.x = a;
	         this.y = b;
	         this.z = c;
	         return this
	      },
	      setScalar: function(a) {
	         this.z = this.y = this.x = a;
	         return this
	      },
	      setX: function(a) {
	         this.x = a;
	         return this
	      },
	      setY: function(a) {
	         this.y = a;
	         return this
	      },
	      setZ: function(a) {
	         this.z = a;
	         return this
	      },
	      setComponent: function(a, b) {
	         switch (a) {
	         case 0:
	            this.x = b;
	            break;
	         case 1:
	            this.y = b;
	            break;
	         case 2:
	            this.z = b;
	            break;
	         default:
	            throw Error("index is out of range: " + a)
	         }
	         return this
	      },
	      getComponent: function(a) {
	         switch (a) {
	         case 0:
	            return this.x;
	         case 1:
	            return this.y;
	         case 2:
	            return this.z;
	         default:
	            throw Error("index is out of range: " + a)
	         }
	      },
	      clone: function() {
	         return new this.constructor(this.x, this.y, this.z)
	      },
	      copy: function(a) {
	         this.x = a.x;
	         this.y = a.y;
	         this.z = a.z;
	         return this
	      },
	      add: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
	         this.x += a.x;
	         this.y += a.y;
	         this.z += a.z;
	         return this
	      },
	      addScalar: function(a) {
	         this.x += a;
	         this.y += a;
	         this.z += a;
	         return this
	      },
	      addVectors: function(a, b) {
	         this.x = a.x + b.x;
	         this.y = a.y + b.y;
	         this.z = a.z + b.z;
	         return this
	      },
	      addScaledVector: function(a, b) {
	         this.x += a.x * b;
	         this.y += a.y * b;
	         this.z += a.z * b;
	         return this
	      },
	      sub: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
	         this.x -= a.x;
	         this.y -= a.y;
	         this.z -= a.z;
	         return this
	      },
	      subScalar: function(a) {
	         this.x -= a;
	         this.y -= a;
	         this.z -= a;
	         return this
	      },
	      subVectors: function(a, b) {
	         this.x = a.x - b.x;
	         this.y = a.y - b.y;
	         this.z = a.z - b.z;
	         return this
	      },
	      multiply: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
	         this.x *= a.x;
	         this.y *= a.y;
	         this.z *= a.z;
	         return this
	      },
	      multiplyScalar: function(a) {
	         this.x *= a;
	         this.y *= a;
	         this.z *= a;
	         return this
	      },
	      multiplyVectors: function(a, b) {
	         this.x = a.x * b.x;
	         this.y = a.y * b.y;
	         this.z = a.z * b.z;
	         return this
	      },
	      applyEuler: function() {
	         var a = new qa;
	         return function(b) {
	            !1 === (b && b.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
	            return this.applyQuaternion(a.setFromEuler(b))
	         }
	      }(),
	      applyAxisAngle: function() {
	         var a = new qa;
	         return function(b, c) {
	            return this.applyQuaternion(a.setFromAxisAngle(b, c))
	         }
	      }(),
	      applyMatrix3: function(a) {
	         var b = this.x,
	            c = this.y,
	            d = this.z;
	         a = a.elements;
	         this.x = a[0] * b + a[3] * c + a[6] * d;
	         this.y = a[1] * b + a[4] * c + a[7] * d;
	         this.z = a[2] * b + a[5] * c + a[8] * d;
	         return this
	      },
	      applyMatrix4: function(a) {
	         var b = this.x,
	            c = this.y,
	            d = this.z;
	         a = a.elements;
	         this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
	         this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
	         this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
	         return this.divideScalar(a[3] * b + a[7] * c + a[11] * d + a[15])
	      },
	      applyQuaternion: function(a) {
	         var b = this.x,
	            c = this.y,
	            d = this.z,
	            e = a.x,
	            f = a.y,
	            g = a.z;
	         a = a.w;
	         var h = a * b + f * d - g * c,
	            k = a * c + g * b - e * d,
	            m = a * d + e * c - f * b,
	            b = -e * b - f * c - g * d;
	         this.x = h * a + b * -e + k * -g - m * -f;
	         this.y = k * a + b * -f + m * -e - h * -g;
	         this.z = m * a + b * -g + h * -f - k * -e;
	         return this
	      },
	      project: function() {
	         var a = new J;
	         return function(b) {
	            a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
	            return this.applyMatrix4(a)
	         }
	      }(),
	      unproject: function() {
	         var a = new J;
	         return function(b) {
	            a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
	            return this.applyMatrix4(a)
	         }
	      }(),
	      transformDirection: function(a) {
	         var b = this.x,
	            c = this.y,
	            d = this.z;
	         a = a.elements;
	         this.x = a[0] * b + a[4] * c + a[8] * d;
	         this.y = a[1] * b + a[5] * c + a[9] * d;
	         this.z = a[2] * b + a[6] * c + a[10] * d;
	         return this.normalize()
	      },
	      divide: function(a) {
	         this.x /= a.x;
	         this.y /= a.y;
	         this.z /= a.z;
	         return this
	      },
	      divideScalar: function(a) {
	         return this.multiplyScalar(1 / a)
	      },
	      min: function(a) {
	         this.x = Math.min(this.x, a.x);
	         this.y = Math.min(this.y, a.y);
	         this.z = Math.min(this.z, a.z);
	         return this
	      },
	      max: function(a) {
	         this.x = Math.max(this.x, a.x);
	         this.y = Math.max(this.y, a.y);
	         this.z = Math.max(this.z, a.z);
	         return this
	      },
	      clamp: function(a, b) {
	         this.x = Math.max(a.x, Math.min(b.x, this.x));
	         this.y = Math.max(a.y, Math.min(b.y, this.y));
	         this.z = Math.max(a.z, Math.min(b.z, this.z));
	         return this
	      },
	      clampScalar: function() {
	         var a = new p,
	            b = new p;
	         return function(c, d) {
	            a.set(c, c, c);
	            b.set(d, d, d);
	            return this.clamp(a, b)
	         }
	      }(),
	      clampLength: function(a, b) {
	         var c = this.length();
	         return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
	      },
	      floor: function() {
	         this.x = Math.floor(this.x);
	         this.y = Math.floor(this.y);
	         this.z = Math.floor(this.z);
	         return this
	      },
	      ceil: function() {
	         this.x = Math.ceil(this.x);
	         this.y = Math.ceil(this.y);
	         this.z = Math.ceil(this.z);
	         return this
	      },
	      round: function() {
	         this.x = Math.round(this.x);
	         this.y = Math.round(this.y);
	         this.z = Math.round(this.z);
	         return this
	      },
	      roundToZero: function() {
	         this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
	         this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
	         this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
	         return this
	      },
	      negate: function() {
	         this.x = -this.x;
	         this.y = -this.y;
	         this.z = -this.z;
	         return this
	      },
	      dot: function(a) {
	         return this.x * a.x + this.y * a.y + this.z * a.z
	      },
	      lengthSq: function() {
	         return this.x * this.x + this.y * this.y + this.z * this.z
	      },
	      length: function() {
	         return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	      },
	      lengthManhattan: function() {
	         return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
	      },
	      normalize: function() {
	         return this.divideScalar(this.length())
	      },
	      setLength: function(a) {
	         return this.multiplyScalar(a / this.length())
	      },
	      lerp: function(a, b) {
	         this.x += (a.x - this.x) * b;
	         this.y += (a.y - this.y) * b;
	         this.z += (a.z - this.z) * b;
	         return this
	      },
	      lerpVectors: function(a, b, c) {
	         return this.subVectors(b, a).multiplyScalar(c).add(a)
	      },
	      cross: function(a, b) {
	         if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
	         var c = this.x,
	            d = this.y,
	            e = this.z;
	         this.x = d * a.z - e * a.y;
	         this.y = e * a.x - c * a.z;
	         this.z = c * a.y - d * a.x;
	         return this
	      },
	      crossVectors: function(a, b) {
	         var c = a.x,
	            d = a.y,
	            e = a.z,
	            f = b.x,
	            g = b.y,
	            h = b.z;
	         this.x = d * h - e * g;
	         this.y = e * f - c * h;
	         this.z = c * g - d * f;
	         return this
	      },
	      projectOnVector: function(a) {
	         var b = a.dot(this) / a.lengthSq();
	         return this.copy(a).multiplyScalar(b)
	      },
	      projectOnPlane: function() {
	         var a = new p;
	         return function(b) {
	            a.copy(this).projectOnVector(b);
	            return this.sub(a)
	         }
	      }(),
	      reflect: function() {
	         var a = new p;
	         return function(b) {
	            return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
	         }
	      }(),
	      angleTo: function(a) {
	         a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
	         return Math.acos(Y.clamp(a, -1, 1))
	      },
	      distanceTo: function(a) {
	         return Math.sqrt(this.distanceToSquared(a))
	      },
	      distanceToSquared: function(a) {
	         var b = this.x - a.x,
	            c = this.y - a.y;
	         a = this.z - a.z;
	         return b * b + c * c + a * a
	      },
	      distanceToManhattan: function(a) {
	         return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
	      },
	      setFromSpherical: function(a) {
	         var b = Math.sin(a.phi) * a.radius;
	         this.x = b * Math.sin(a.theta);
	         this.y = Math.cos(a.phi) * a.radius;
	         this.z = b * Math.cos(a.theta);
	         return this
	      },
	      setFromCylindrical: function(a) {
	         this.x = a.radius * Math.sin(a.theta);
	         this.y = a.y;
	         this.z = a.radius * Math.cos(a.theta);
	         return this
	      },
	      setFromMatrixPosition: function(a) {
	         return this.setFromMatrixColumn(a, 3)
	      },
	      setFromMatrixScale: function(a) {
	         var b = this.setFromMatrixColumn(a, 0).length(),
	            c = this.setFromMatrixColumn(a, 1).length();
	         a = this.setFromMatrixColumn(a, 2).length();
	         this.x = b;
	         this.y = c;
	         this.z = a;
	         return this
	      },
	      setFromMatrixColumn: function(a, b) {
	         return this.fromArray(a.elements, 4 * b)
	      },
	      equals: function(a) {
	         return a.x === this.x && a.y === this.y && a.z === this.z
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         this.x = a[b];
	         this.y = a[b + 1];
	         this.z = a[b + 2];
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         a[b] = this.x;
	         a[b + 1] = this.y;
	         a[b + 2] = this.z;
	         return a
	      },
	      fromBufferAttribute: function(a, b, c) {
	         void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
	         this.x = a.getX(b);
	         this.y = a.getY(b);
	         this.z = a.getZ(b);
	         return this
	      }
	   });
	   Object.assign(J.prototype, {
	      isMatrix4: !0,
	      set: function(a, b, c, d, e, f, g, h, k, m, u, l, n, r, p, t) {
	         var y = this.elements;
	         y[0] = a;
	         y[4] = b;
	         y[8] = c;
	         y[12] = d;
	         y[1] = e;
	         y[5] = f;
	         y[9] = g;
	         y[13] = h;
	         y[2] = k;
	         y[6] = m;
	         y[10] = u;
	         y[14] = l;
	         y[3] = n;
	         y[7] = r;
	         y[11] = p;
	         y[15] = t;
	         return this
	      },
	      identity: function() {
	         this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	         return this
	      },
	      clone: function() {
	         return (new J).fromArray(this.elements)
	      },
	      copy: function(a) {
	         var b = this.elements;
	         a = a.elements;
	         b[0] = a[0];
	         b[1] = a[1];
	         b[2] = a[2];
	         b[3] = a[3];
	         b[4] = a[4];
	         b[5] = a[5];
	         b[6] = a[6];
	         b[7] = a[7];
	         b[8] = a[8];
	         b[9] = a[9];
	         b[10] = a[10];
	         b[11] = a[11];
	         b[12] = a[12];
	         b[13] = a[13];
	         b[14] = a[14];
	         b[15] = a[15];
	         return this
	      },
	      copyPosition: function(a) {
	         var b = this.elements;
	         a = a.elements;
	         b[12] = a[12];
	         b[13] = a[13];
	         b[14] = a[14];
	         return this
	      },
	      extractBasis: function(a, b, c) {
	         a.setFromMatrixColumn(this, 0);
	         b.setFromMatrixColumn(this, 1);
	         c.setFromMatrixColumn(this, 2);
	         return this
	      },
	      makeBasis: function(a, b, c) {
	         this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
	         return this
	      },
	      extractRotation: function() {
	         var a = new p;
	         return function(b) {
	            var c = this.elements,
	               d = b.elements,
	               e = 1 / a.setFromMatrixColumn(b, 0).length(),
	               f = 1 / a.setFromMatrixColumn(b, 1).length();
	            b = 1 / a.setFromMatrixColumn(b, 2).length();
	            c[0] = d[0] * e;
	            c[1] = d[1] * e;
	            c[2] = d[2] * e;
	            c[4] = d[4] * f;
	            c[5] = d[5] * f;
	            c[6] = d[6] * f;
	            c[8] = d[8] * b;
	            c[9] = d[9] * b;
	            c[10] = d[10] * b;
	            return this
	         }
	      }(),
	      makeRotationFromEuler: function(a) {
	         !1 === (a && a.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
	         var b = this.elements,
	            c = a.x,
	            d = a.y,
	            e = a.z,
	            f = Math.cos(c),
	            c = Math.sin(c),
	            g = Math.cos(d),
	            d = Math.sin(d),
	            h = Math.cos(e),
	            e = Math.sin(e);
	         if ("XYZ" === a.order) {
	            a = f * h;
	            var k = f * e,
	               m = c * h,
	               u = c * e;
	            b[0] = g * h;
	            b[4] = -g * e;
	            b[8] = d;
	            b[1] = k + m * d;
	            b[5] = a - u * d;
	            b[9] = -c * g;
	            b[2] = u - a * d;
	            b[6] = m + k * d;
	            b[10] = f * g
	         } else "YXZ" === a.order ? (a = g * h, k = g * e, m = d * h, u = d * e, b[0] = a + u * c, b[4] = m * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - m, b[6] = u + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, m = d * h, u = d * e, b[0] = a - u * c, b[4] = -f * e, b[8] = m + k * c, b[1] = k + m * c, b[5] = f * h, b[9] = u - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, m = c * h, u = c * e, b[0] = g * h, b[4] = m * d - k, b[8] = a * d + u, b[1] = g * e, b[5] = u * d + a, b[9] = k * d - m, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, k = f * d, m = c * g, u = c * d, b[0] = g * h, b[4] = u - a * e, b[8] = m * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + m, b[10] = a - u * e) : "XZY" === a.order && (a = f * g, k = f * d, m = c * g, u = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + u, b[5] = f * h, b[9] = k * e - m, b[2] = m * e - k, b[6] = c * h, b[10] = u * e + a);
	         b[3] = 0;
	         b[7] = 0;
	         b[11] = 0;
	         b[12] = 0;
	         b[13] = 0;
	         b[14] = 0;
	         b[15] = 1;
	         return this
	      },
	      makeRotationFromQuaternion: function(a) {
	         var b = this.elements,
	            c = a._x,
	            d = a._y,
	            e = a._z,
	            f = a._w,
	            g = c + c,
	            h = d + d,
	            k = e + e;
	         a = c * g;
	         var m = c * h,
	            c = c * k,
	            u = d * h,
	            d = d * k,
	            e = e * k,
	            g = f * g,
	            h = f * h,
	            f = f * k;
	         b[0] = 1 - (u + e);
	         b[4] = m - f;
	         b[8] = c + h;
	         b[1] = m + f;
	         b[5] = 1 - (a + e);
	         b[9] = d - g;
	         b[2] = c - h;
	         b[6] = d + g;
	         b[10] = 1 - (a + u);
	         b[3] = 0;
	         b[7] = 0;
	         b[11] = 0;
	         b[12] = 0;
	         b[13] = 0;
	         b[14] = 0;
	         b[15] = 1;
	         return this
	      },
	      lookAt: function() {
	         var a = new p,
	            b = new p,
	            c = new p;
	         return function(d, e, f) {
	            var g = this.elements;
	            c.subVectors(d, e);
	            0 === c.lengthSq() && (c.z = 1);
	            c.normalize();
	            a.crossVectors(f, c);
	            0 === a.lengthSq() && (c.z += 1e-4, a.crossVectors(f, c));
	            a.normalize();
	            b.crossVectors(c, a);
	            g[0] = a.x;
	            g[4] = b.x;
	            g[8] = c.x;
	            g[1] = a.y;
	            g[5] = b.y;
	            g[9] = c.y;
	            g[2] = a.z;
	            g[6] = b.z;
	            g[10] = c.z;
	            return this
	         }
	      }(),
	      multiply: function(a, b) {
	         return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
	      },
	      premultiply: function(a) {
	         return this.multiplyMatrices(a, this)
	      },
	      multiplyMatrices: function(a, b) {
	         var c = a.elements,
	            d = b.elements,
	            e = this.elements,
	            f = c[0],
	            g = c[4],
	            h = c[8],
	            k = c[12],
	            m = c[1],
	            u = c[5],
	            l = c[9],
	            n = c[13],
	            r = c[2],
	            p = c[6],
	            t = c[10],
	            y = c[14],
	            x = c[3],
	            v = c[7],
	            G = c[11],
	            c = c[15],
	            w = d[0],
	            O = d[4],
	            S = d[8],
	            E = d[12],
	            F = d[1],
	            C = d[5],
	            R = d[9],
	            D = d[13],
	            B = d[2],
	            I = d[6],
	            H = d[10],
	            J = d[14],
	            P = d[3],
	            K = d[7],
	            W = d[11],
	            d = d[15];
	         e[0] = f * w + g * F + h * B + k * P;
	         e[4] = f * O + g * C + h * I + k * K;
	         e[8] = f * S + g * R + h * H + k * W;
	         e[12] = f * E + g * D + h * J + k * d;
	         e[1] = m * w + u * F + l * B + n * P;
	         e[5] = m * O + u * C + l * I + n * K;
	         e[9] = m * S + u * R + l * H + n * W;
	         e[13] = m * E + u * D + l * J + n * d;
	         e[2] = r * w + p * F + t * B + y * P;
	         e[6] = r * O + p * C + t * I + y * K;
	         e[10] = r * S + p * R + t * H + y * W;
	         e[14] = r * E + p * D + t * J + y * d;
	         e[3] = x * w + v * F + G * B + c * P;
	         e[7] = x * O + v * C + G * I + c * K;
	         e[11] = x * S + v * R + G * H + c * W;
	         e[15] = x * E + v * D + G * J + c * d;
	         return this
	      },
	      multiplyScalar: function(a) {
	         var b = this.elements;
	         b[0] *= a;
	         b[4] *= a;
	         b[8] *= a;
	         b[12] *= a;
	         b[1] *= a;
	         b[5] *= a;
	         b[9] *= a;
	         b[13] *= a;
	         b[2] *= a;
	         b[6] *= a;
	         b[10] *= a;
	         b[14] *= a;
	         b[3] *= a;
	         b[7] *= a;
	         b[11] *= a;
	         b[15] *= a;
	         return this
	      },
	      applyToBufferAttribute: function() {
	         var a = new p;
	         return function(b) {
	            for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z);
	            return b
	         }
	      }(),
	      determinant: function() {
	         var a = this.elements,
	            b = a[0],
	            c = a[4],
	            d = a[8],
	            e = a[12],
	            f = a[1],
	            g = a[5],
	            h = a[9],
	            k = a[13],
	            m = a[2],
	            u = a[6],
	            l = a[10],
	            n = a[14];
	         return a[3] * (+e * h * u - d * k * u - e * g * l + c * k * l + d * g * n - c * h * n) + a[7] * (+b * h * n - b * k * l + e * f * l - d * f * n + d * k * m - e * h * m) + a[11] * (+b * k * u - b * g * n - e * f * u + c * f * n + e * g * m - c * k * m) + a[15] * (-d * g * m - b * h * u + b * g * l + d * f * u - c * f * l + c * h * m)
	      },
	      transpose: function() {
	         var a = this.elements,
	            b;
	         b = a[1];
	         a[1] = a[4];
	         a[4] = b;
	         b = a[2];
	         a[2] = a[8];
	         a[8] = b;
	         b = a[6];
	         a[6] = a[9];
	         a[9] = b;
	         b = a[3];
	         a[3] = a[12];
	         a[12] = b;
	         b = a[7];
	         a[7] = a[13];
	         a[13] = b;
	         b = a[11];
	         a[11] = a[14];
	         a[14] = b;
	         return this
	      },
	      setPosition: function(a) {
	         var b = this.elements;
	         b[12] = a.x;
	         b[13] = a.y;
	         b[14] = a.z;
	         return this
	      },
	      getInverse: function(a, b) {
	         var c = this.elements,
	            d = a.elements,
	            e = d[0],
	            f = d[1],
	            g = d[2],
	            h = d[3],
	            k = d[4],
	            m = d[5],
	            l = d[6],
	            q = d[7],
	            n = d[8],
	            r = d[9],
	            p = d[10],
	            t = d[11],
	            y = d[12],
	            x = d[13],
	            v = d[14],
	            d = d[15],
	            G = r * v * q - x * p * q + x * l * t - m * v * t - r * l * d + m * p * d,
	            w = y * p * q - n * v * q - y * l * t + k * v * t + n * l * d - k * p * d,
	            O = n * x * q - y * r * q + y * m * t - k * x * t - n * m * d + k * r * d,
	            S = y * r * l - n * x * l - y * m * p + k * x * p + n * m * v - k * r * v,
	            E = e * G + f * w + g * O + h * S;
	         if (0 === E) {
	            if (!0 === b) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
	            console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
	            return this.identity()
	         }
	         E = 1 / E;
	         c[0] = G * E;
	         c[1] = (x * p * h - r * v * h - x * g * t + f * v * t + r * g * d - f * p * d) * E;
	         c[2] = (m * v * h - x * l * h + x * g * q - f * v * q - m * g * d + f * l * d) * E;
	         c[3] = (r * l * h - m * p * h - r * g * q + f * p * q + m * g * t - f * l * t) * E;
	         c[4] = w * E;
	         c[5] = (n * v * h - y * p * h + y * g * t - e * v * t - n * g * d + e * p * d) * E;
	         c[6] = (y * l * h - k * v * h - y * g * q + e * v * q + k * g * d - e * l * d) * E;
	         c[7] = (k * p * h - n * l * h + n * g * q - e * p * q - k * g * t + e * l * t) * E;
	         c[8] = O * E;
	         c[9] = (y * r * h - n * x * h - y * f * t + e * x * t + n * f * d - e * r * d) * E;
	         c[10] = (k * x * h - y * m * h + y * f * q - e * x * q - k * f * d + e * m * d) * E;
	         c[11] = (n * m * h - k * r * h - n * f * q + e * r * q + k * f * t - e * m * t) * E;
	         c[12] = S * E;
	         c[13] = (n * x * g - y * r * g + y * f * p - e * x * p - n * f * v + e * r * v) * E;
	         c[14] = (y * m * g - k * x * g - y * f * l + e * x * l + k * f * v - e * m * v) * E;
	         c[15] = (k * r * g - n * m * g + n * f * l - e * r * l - k * f * p + e * m * p) * E;
	         return this
	      },
	      scale: function(a) {
	         var b = this.elements,
	            c = a.x,
	            d = a.y;
	         a = a.z;
	         b[0] *= c;
	         b[4] *= d;
	         b[8] *= a;
	         b[1] *= c;
	         b[5] *= d;
	         b[9] *= a;
	         b[2] *= c;
	         b[6] *= d;
	         b[10] *= a;
	         b[3] *= c;
	         b[7] *= d;
	         b[11] *= a;
	         return this
	      },
	      getMaxScaleOnAxis: function() {
	         var a = this.elements;
	         return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
	      },
	      makeTranslation: function(a, b, c) {
	         this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
	         return this
	      },
	      makeRotationX: function(a) {
	         var b = Math.cos(a);
	         a = Math.sin(a);
	         this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
	         return this
	      },
	      makeRotationY: function(a) {
	         var b = Math.cos(a);
	         a = Math.sin(a);
	         this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
	         return this
	      },
	      makeRotationZ: function(a) {
	         var b = Math.cos(a);
	         a = Math.sin(a);
	         this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	         return this
	      },
	      makeRotationAxis: function(a, b) {
	         var c = Math.cos(b),
	            d = Math.sin(b),
	            e = 1 - c,
	            f = a.x,
	            g = a.y,
	            h = a.z,
	            k = e * f,
	            m = e * g;
	         this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, m * g + c, m * h - d * f, 0, k * h - d * g, m * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
	         return this
	      },
	      makeScale: function(a, b, c) {
	         this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
	         return this
	      },
	      makeShear: function(a, b, c) {
	         this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
	         return this
	      },
	      compose: function(a, b, c) {
	         this.makeRotationFromQuaternion(b);
	         this.scale(c);
	         this.setPosition(a);
	         return this
	      },
	      decompose: function() {
	         var a = new p,
	            b = new J;
	         return function(c, d, e) {
	            var f = this.elements,
	               g = a.set(f[0], f[1], f[2]).length(),
	               h = a.set(f[4], f[5], f[6]).length(),
	               k = a.set(f[8], f[9], f[10]).length();
	            0 > this.determinant() && (g = -g);
	            c.x = f[12];
	            c.y = f[13];
	            c.z = f[14];
	            b.copy(this);
	            c = 1 / g;
	            var f = 1 / h,
	               m = 1 / k;
	            b.elements[0] *= c;
	            b.elements[1] *= c;
	            b.elements[2] *= c;
	            b.elements[4] *= f;
	            b.elements[5] *= f;
	            b.elements[6] *= f;
	            b.elements[8] *= m;
	            b.elements[9] *= m;
	            b.elements[10] *= m;
	            d.setFromRotationMatrix(b);
	            e.x = g;
	            e.y = h;
	            e.z = k;
	            return this
	         }
	      }(),
	      makePerspective: function(a, b, c, d, e, f) {
	         void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
	         var g = this.elements;
	         g[0] = 2 * e / (b - a);
	         g[4] = 0;
	         g[8] = (b + a) / (b - a);
	         g[12] = 0;
	         g[1] = 0;
	         g[5] = 2 * e / (c - d);
	         g[9] = (c + d) / (c - d);
	         g[13] = 0;
	         g[2] = 0;
	         g[6] = 0;
	         g[10] = -(f + e) / (f - e);
	         g[14] = -2 * f * e / (f - e);
	         g[3] = 0;
	         g[7] = 0;
	         g[11] = -1;
	         g[15] = 0;
	         return this
	      },
	      makeOrthographic: function(a, b, c, d, e, f) {
	         var g = this.elements,
	            h = 1 / (b - a),
	            k = 1 / (c - d),
	            m = 1 / (f - e);
	         g[0] = 2 * h;
	         g[4] = 0;
	         g[8] = 0;
	         g[12] = -((b + a) * h);
	         g[1] = 0;
	         g[5] = 2 * k;
	         g[9] = 0;
	         g[13] = -((c + d) * k);
	         g[2] = 0;
	         g[6] = 0;
	         g[10] = -2 * m;
	         g[14] = -((f + e) * m);
	         g[3] = 0;
	         g[7] = 0;
	         g[11] = 0;
	         g[15] = 1;
	         return this
	      },
	      equals: function(a) {
	         var b = this.elements;
	         a = a.elements;
	         for (var c = 0; 16 > c; c++) if (b[c] !== a[c]) return !1;
	         return !0
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         var c = this.elements;
	         a[b] = c[0];
	         a[b + 1] = c[1];
	         a[b + 2] = c[2];
	         a[b + 3] = c[3];
	         a[b + 4] = c[4];
	         a[b + 5] = c[5];
	         a[b + 6] = c[6];
	         a[b + 7] = c[7];
	         a[b + 8] = c[8];
	         a[b + 9] = c[9];
	         a[b + 10] = c[10];
	         a[b + 11] = c[11];
	         a[b + 12] = c[12];
	         a[b + 13] = c[13];
	         a[b + 14] = c[14];
	         a[b + 15] = c[15];
	         return a
	      }
	   });
	   eb.prototype = Object.create(X.prototype);
	   eb.prototype.constructor = eb;
	   eb.prototype.isDataTexture = !0;
	   Za.prototype = Object.create(X.prototype);
	   Za.prototype.constructor = Za;
	   Za.prototype.isCubeTexture = !0;
	   Object.defineProperty(Za.prototype, "images", {
	      get: function() {
	         return this.image
	      },
	      set: function(a) {
	         this.image = a
	      }
	   });
	   var De = new X,
	      Ee = new Za,
	      ye = [],
	      Ae = [],
	      Ce = new Float32Array(16),
	      Be = new Float32Array(9);
	   Ie.prototype.setValue = function(a, b) {
	      for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
	         var f = c[d];
	         f.setValue(a, b[f.id])
	      }
	   };
	   var Qd = /([\w\d_]+)(\])?(\[|\.)?/g;
	   fb.prototype.setValue = function(a, b, c) {
	      b = this.map[b];
	      void 0 !== b && b.setValue(a, c, this.renderer)
	   };
	   fb.prototype.setOptional = function(a, b, c) {
	      b = b[c];
	      void 0 !== b && this.setValue(a, c, b)
	   };
	   fb.upload = function(a, b, c, d) {
	      for (var e = 0, f = b.length; e !== f; ++e) {
	         var g = b[e],
	            h = c[g.id];
	         !1 !== h.needsUpdate && g.setValue(a, h.value, d)
	      }
	   };
	   fb.seqWithValue = function(a, b) {
	      for (var c = [], d = 0, e = a.length; d !== e; ++d) {
	         var f = a[d];
	         f.id in b && c.push(f)
	      }
	      return c
	   };
	   var kg = {
	      aliceblue: 15792383,
	      antiquewhite: 16444375,
	      aqua: 65535,
	      aquamarine: 8388564,
	      azure: 15794175,
	      beige: 16119260,
	      bisque: 16770244,
	      black: 0,
	      blanchedalmond: 16772045,
	      blue: 255,
	      blueviolet: 9055202,
	      brown: 10824234,
	      burlywood: 14596231,
	      cadetblue: 6266528,
	      chartreuse: 8388352,
	      chocolate: 13789470,
	      coral: 16744272,
	      cornflowerblue: 6591981,
	      cornsilk: 16775388,
	      crimson: 14423100,
	      cyan: 65535,
	      darkblue: 139,
	      darkcyan: 35723,
	      darkgoldenrod: 12092939,
	      darkgray: 11119017,
	      darkgreen: 25600,
	      darkgrey: 11119017,
	      darkkhaki: 12433259,
	      darkmagenta: 9109643,
	      darkolivegreen: 5597999,
	      darkorange: 16747520,
	      darkorchid: 10040012,
	      darkred: 9109504,
	      darksalmon: 15308410,
	      darkseagreen: 9419919,
	      darkslateblue: 4734347,
	      darkslategray: 3100495,
	      darkslategrey: 3100495,
	      darkturquoise: 52945,
	      darkviolet: 9699539,
	      deeppink: 16716947,
	      deepskyblue: 49151,
	      dimgray: 6908265,
	      dimgrey: 6908265,
	      dodgerblue: 2003199,
	      firebrick: 11674146,
	      floralwhite: 16775920,
	      forestgreen: 2263842,
	      fuchsia: 16711935,
	      gainsboro: 14474460,
	      ghostwhite: 16316671,
	      gold: 16766720,
	      goldenrod: 14329120,
	      gray: 8421504,
	      green: 32768,
	      greenyellow: 11403055,
	      grey: 8421504,
	      honeydew: 15794160,
	      hotpink: 16738740,
	      indianred: 13458524,
	      indigo: 4915330,
	      ivory: 16777200,
	      khaki: 15787660,
	      lavender: 15132410,
	      lavenderblush: 16773365,
	      lawngreen: 8190976,
	      lemonchiffon: 16775885,
	      lightblue: 11393254,
	      lightcoral: 15761536,
	      lightcyan: 14745599,
	      lightgoldenrodyellow: 16448210,
	      lightgray: 13882323,
	      lightgreen: 9498256,
	      lightgrey: 13882323,
	      lightpink: 16758465,
	      lightsalmon: 16752762,
	      lightseagreen: 2142890,
	      lightskyblue: 8900346,
	      lightslategray: 7833753,
	      lightslategrey: 7833753,
	      lightsteelblue: 11584734,
	      lightyellow: 16777184,
	      lime: 65280,
	      limegreen: 3329330,
	      linen: 16445670,
	      magenta: 16711935,
	      maroon: 8388608,
	      mediumaquamarine: 6737322,
	      mediumblue: 205,
	      mediumorchid: 12211667,
	      mediumpurple: 9662683,
	      mediumseagreen: 3978097,
	      mediumslateblue: 8087790,
	      mediumspringgreen: 64154,
	      mediumturquoise: 4772300,
	      mediumvioletred: 13047173,
	      midnightblue: 1644912,
	      mintcream: 16121850,
	      mistyrose: 16770273,
	      moccasin: 16770229,
	      navajowhite: 16768685,
	      navy: 128,
	      oldlace: 16643558,
	      olive: 8421376,
	      olivedrab: 7048739,
	      orange: 16753920,
	      orangered: 16729344,
	      orchid: 14315734,
	      palegoldenrod: 15657130,
	      palegreen: 10025880,
	      paleturquoise: 11529966,
	      palevioletred: 14381203,
	      papayawhip: 16773077,
	      peachpuff: 16767673,
	      peru: 13468991,
	      pink: 16761035,
	      plum: 14524637,
	      powderblue: 11591910,
	      purple: 8388736,
	      red: 16711680,
	      rosybrown: 12357519,
	      royalblue: 4286945,
	      saddlebrown: 9127187,
	      salmon: 16416882,
	      sandybrown: 16032864,
	      seagreen: 3050327,
	      seashell: 16774638,
	      sienna: 10506797,
	      silver: 12632256,
	      skyblue: 8900331,
	      slateblue: 6970061,
	      slategray: 7372944,
	      slategrey: 7372944,
	      snow: 16775930,
	      springgreen: 65407,
	      steelblue: 4620980,
	      tan: 13808780,
	      teal: 32896,
	      thistle: 14204888,
	      tomato: 16737095,
	      turquoise: 4251856,
	      violet: 15631086,
	      wheat: 16113331,
	      white: 16777215,
	      whitesmoke: 16119285,
	      yellow: 16776960,
	      yellowgreen: 10145074
	   };
	   Object.assign(H.prototype, {
	      isColor: !0,
	      r: 1,
	      g: 1,
	      b: 1,
	      set: function(a) {
	         a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
	         return this
	      },
	      setScalar: function(a) {
	         this.b = this.g = this.r = a;
	         return this
	      },
	      setHex: function(a) {
	         a = Math.floor(a);
	         this.r = (a >> 16 & 255) / 255;
	         this.g = (a >> 8 & 255) / 255;
	         this.b = (a & 255) / 255;
	         return this
	      },
	      setRGB: function(a, b, c) {
	         this.r = a;
	         this.g = b;
	         this.b = c;
	         return this
	      },
	      setHSL: function() {
	         function a(a, c, d) {
	            0 > d && (d += 1);
	            1 < d && --d;
	            return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a
	         }
	         return function(b, c, d) {
	            b = Y.euclideanModulo(b, 1);
	            c = Y.clamp(c, 0, 1);
	            d = Y.clamp(d, 0, 1);
	            0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3));
	            return this
	         }
	      }(),
	      setStyle: function(a) {
	         function b(b) {
	            void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
	         }
	         var c;
	         if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
	            var d = c[2];
	            switch (c[1]) {
	            case "rgb":
	            case "rgba":
	               if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
	               if (c = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
	               break;
	            case "hsl":
	            case "hsla":
	               if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
	                  var d = parseFloat(c[1]) / 360,
	                     e = parseInt(c[2], 10) / 100,
	                     f = parseInt(c[3], 10) / 100;
	                  b(c[5]);
	                  return this.setHSL(d, e, f)
	               }
	            }
	         } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
	            c = c[1];
	            d = c.length;
	            if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
	            if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
	         }
	         a && 0 < a.length && (c = kg[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a));
	         return this
	      },
	      clone: function() {
	         return new this.constructor(this.r, this.g, this.b)
	      },
	      copy: function(a) {
	         this.r = a.r;
	         this.g = a.g;
	         this.b = a.b;
	         return this
	      },
	      copyGammaToLinear: function(a, b) {
	         void 0 === b && (b = 2);
	         this.r = Math.pow(a.r, b);
	         this.g = Math.pow(a.g, b);
	         this.b = Math.pow(a.b, b);
	         return this
	      },
	      copyLinearToGamma: function(a, b) {
	         void 0 === b && (b = 2);
	         var c = 0 < b ? 1 / b : 1;
	         this.r = Math.pow(a.r, c);
	         this.g = Math.pow(a.g, c);
	         this.b = Math.pow(a.b, c);
	         return this
	      },
	      convertGammaToLinear: function() {
	         var a = this.r,
	            b = this.g,
	            c = this.b;
	         this.r = a * a;
	         this.g = b * b;
	         this.b = c * c;
	         return this
	      },
	      convertLinearToGamma: function() {
	         this.r = Math.sqrt(this.r);
	         this.g = Math.sqrt(this.g);
	         this.b = Math.sqrt(this.b);
	         return this
	      },
	      getHex: function() {
	         return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
	      },
	      getHexString: function() {
	         return ("000000" + this.getHex().toString(16)).slice(-6)
	      },
	      getHSL: function(a) {
	         a = a || {
	            h: 0,
	            s: 0,
	            l: 0
	         };
	         var b = this.r,
	            c = this.g,
	            d = this.b,
	            e = Math.max(b, c, d),
	            f = Math.min(b, c, d),
	            g, h = (f + e) / 2;
	         if (f === e) f = g = 0;
	         else {
	            var k = e - f,
	               f = .5 >= h ? k / (e + f) : k / (2 - e - f);
	            switch (e) {
	            case b:
	               g = (c - d) / k + (c < d ? 6 : 0);
	               break;
	            case c:
	               g = (d - b) / k + 2;
	               break;
	            case d:
	               g = (b - c) / k + 4
	            }
	            g /= 6
	         }
	         a.h = g;
	         a.s = f;
	         a.l = h;
	         return a
	      },
	      getStyle: function() {
	         return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
	      },
	      offsetHSL: function(a, b, c) {
	         var d = this.getHSL();
	         d.h += a;
	         d.s += b;
	         d.l += c;
	         this.setHSL(d.h, d.s, d.l);
	         return this
	      },
	      add: function(a) {
	         this.r += a.r;
	         this.g += a.g;
	         this.b += a.b;
	         return this
	      },
	      addColors: function(a, b) {
	         this.r = a.r + b.r;
	         this.g = a.g + b.g;
	         this.b = a.b + b.b;
	         return this
	      },
	      addScalar: function(a) {
	         this.r += a;
	         this.g += a;
	         this.b += a;
	         return this
	      },
	      sub: function(a) {
	         this.r = Math.max(0, this.r - a.r);
	         this.g = Math.max(0, this.g - a.g);
	         this.b = Math.max(0, this.b - a.b);
	         return this
	      },
	      multiply: function(a) {
	         this.r *= a.r;
	         this.g *= a.g;
	         this.b *= a.b;
	         return this
	      },
	      multiplyScalar: function(a) {
	         this.r *= a;
	         this.g *= a;
	         this.b *= a;
	         return this
	      },
	      lerp: function(a, b) {
	         this.r += (a.r - this.r) * b;
	         this.g += (a.g - this.g) * b;
	         this.b += (a.b - this.b) * b;
	         return this
	      },
	      equals: function(a) {
	         return a.r === this.r && a.g === this.g && a.b === this.b
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         this.r = a[b];
	         this.g = a[b + 1];
	         this.b = a[b + 2];
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         a[b] = this.r;
	         a[b + 1] = this.g;
	         a[b + 2] = this.b;
	         return a
	      },
	      toJSON: function() {
	         return this.getHex()
	      }
	   });
	   var V = {
	      common: {
	         diffuse: {
	            value: new H(15658734)
	         },
	         opacity: {
	            value: 1
	         },
	         map: {
	            value: null
	         },
	         offsetRepeat: {
	            value: new ga(0, 0, 1, 1)
	         },
	         specularMap: {
	            value: null
	         },
	         alphaMap: {
	            value: null
	         },
	         envMap: {
	            value: null
	         },
	         flipEnvMap: {
	            value: -1
	         },
	         reflectivity: {
	            value: 1
	         },
	         refractionRatio: {
	            value: .98
	         }
	      },
	      aomap: {
	         aoMap: {
	            value: null
	         },
	         aoMapIntensity: {
	            value: 1
	         }
	      },
	      lightmap: {
	         lightMap: {
	            value: null
	         },
	         lightMapIntensity: {
	            value: 1
	         }
	      },
	      emissivemap: {
	         emissiveMap: {
	            value: null
	         }
	      },
	      bumpmap: {
	         bumpMap: {
	            value: null
	         },
	         bumpScale: {
	            value: 1
	         }
	      },
	      normalmap: {
	         normalMap: {
	            value: null
	         },
	         normalScale: {
	            value: new D(1, 1)
	         }
	      },
	      displacementmap: {
	         displacementMap: {
	            value: null
	         },
	         displacementScale: {
	            value: 1
	         },
	         displacementBias: {
	            value: 0
	         }
	      },
	      roughnessmap: {
	         roughnessMap: {
	            value: null
	         }
	      },
	      metalnessmap: {
	         metalnessMap: {
	            value: null
	         }
	      },
	      gradientmap: {
	         gradientMap: {
	            value: null
	         }
	      },
	      fog: {
	         fogDensity: {
	            value: 25e-5
	         },
	         fogNear: {
	            value: 1
	         },
	         fogFar: {
	            value: 2e3
	         },
	         fogColor: {
	            value: new H(16777215)
	         }
	      },
	      lights: {
	         ambientLightColor: {
	            value: []
	         },
	         directionalLights: {
	            value: [],
	            properties: {
	               direction: {},
	               color: {},
	               shadow: {},
	               shadowBias: {},
	               shadowRadius: {},
	               shadowMapSize: {}
	            }
	         },
	         directionalShadowMap: {
	            value: []
	         },
	         directionalShadowMatrix: {
	            value: []
	         },
	         spotLights: {
	            value: [],
	            properties: {
	               color: {},
	               position: {},
	               direction: {},
	               distance: {},
	               coneCos: {},
	               penumbraCos: {},
	               decay: {},
	               shadow: {},
	               shadowBias: {},
	               shadowRadius: {},
	               shadowMapSize: {}
	            }
	         },
	         spotShadowMap: {
	            value: []
	         },
	         spotShadowMatrix: {
	            value: []
	         },
	         pointLights: {
	            value: [],
	            properties: {
	               color: {},
	               position: {},
	               decay: {},
	               distance: {},
	               shadow: {},
	               shadowBias: {},
	               shadowRadius: {},
	               shadowMapSize: {}
	            }
	         },
	         pointShadowMap: {
	            value: []
	         },
	         pointShadowMatrix: {
	            value: []
	         },
	         hemisphereLights: {
	            value: [],
	            properties: {
	               direction: {},
	               skyColor: {},
	               groundColor: {}
	            }
	         },
	         rectAreaLights: {
	            value: [],
	            properties: {
	               color: {},
	               position: {},
	               width: {},
	               height: {}
	            }
	         }
	      },
	      points: {
	         diffuse: {
	            value: new H(15658734)
	         },
	         opacity: {
	            value: 1
	         },
	         size: {
	            value: 1
	         },
	         scale: {
	            value: 1
	         },
	         map: {
	            value: null
	         },
	         offsetRepeat: {
	            value: new ga(0, 0, 1, 1)
	         }
	      }
	   },
	      Ha = {
	         merge: function(a) {
	            for (var b = {}, c = 0; c < a.length; c++) {
	               var d = this.clone(a[c]),
	                  e;
	               for (e in d) b[e] = d[e]
	            }
	            return b
	         },
	         clone: function(a) {
	            var b = {},
	               c;
	            for (c in a) {
	               b[c] = {};
	               for (var d in a[c]) {
	                  var e = a[c][d];
	                  e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
	               }
	            }
	            return b
	         }
	      },
	      U = {
	         alphamap_fragment: "#ifdef USE_ALPHAMAP\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
	         alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n  uniform sampler2D alphaMap;\n#endif\n",
	         alphatest_fragment: "#ifdef ALPHATEST\n   if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
	         aomap_fragment: "#ifdef USE_AOMAP\n float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n   reflectedLight.indirectDiffuse *= ambientOcclusion;\n #if defined( USE_ENVMAP ) && defined( PHYSICAL )\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n      reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n   #endif\n#endif\n",
	         aomap_pars_fragment: "#ifdef USE_AOMAP\n  uniform sampler2D aoMap;\n uniform float aoMapIntensity;\n#endif",
	         begin_vertex: "\nvec3 transformed = vec3( position );\n",
	         beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
	         bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n  if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n      float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n      float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n      return distanceFalloff * maxDistanceCutoffFactor;\n#else\n     return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n }\n   return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n   return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n  float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n  float a2 = pow2( alpha );\n   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n   return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n   float a2 = pow2( alpha );\n   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n   return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n  float a2 = pow2( alpha );\n   float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n   return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n   float alpha = pow2( roughness );\n  vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n  float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n   float dotNH = saturate( dot( geometry.normal, halfDir ) );\n   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n vec3 F = F_Schlick( specularColor, dotLH );\n   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n   float D = D_GGX( alpha, dotNH );\n  return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n  const float LUT_SIZE  = 64.0;\n  const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n float theta = acos( dot( N, V ) );\n   vec2 uv = vec2(\n    sqrt( saturate( roughness ) ),\n    saturate( theta / ( 0.5 * PI ) ) );\n  uv = uv * LUT_SCALE + LUT_BIAS;\n   return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n float l = length( f );\n   return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n float x = dot( v1, v2 );\n float y = abs( x );\n   float a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n   float b = 3.45068 + (4.18814 + y) * y;\n  float v = a / b;\n   float theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n   return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n  vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n  vec3 lightNormal = cross( v1, v2 );\n  if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n  vec3 T1, T2;\n T1 = normalize( V - N * dot( V, N ) );\n  T2 = - cross( N, T1 );\n   mat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n   vec3 coords[ 4 ];\n  coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n  coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n  coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n  coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n  coords[ 0 ] = normalize( coords[ 0 ] );\n coords[ 1 ] = normalize( coords[ 1 ] );\n coords[ 2 ] = normalize( coords[ 2 ] );\n coords[ 3 ] = normalize( coords[ 3 ] );\n vec3 vectorFormFactor = vec3( 0.0 );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n   vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n   vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n   vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n   vec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n   return result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n   float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n   const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n  vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n  float dotNH = saturate( dot( geometry.normal, halfDir ) );\n   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n vec3 F = F_Schlick( specularColor, dotLH );\n   float G = G_BlinnPhong_Implicit( );\n  float D = D_BlinnPhong( shininess, dotNH );\n   return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n  return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n  return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
	         bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n uniform sampler2D bumpMap;\n  uniform float bumpScale;\n vec2 dHdxy_fwd() {\n    vec2 dSTdx = dFdx( vUv );\n      vec2 dSTdy = dFdy( vUv );\n      float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n      float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n    float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n    return vec2( dBx, dBy );\n }\n   vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n     vec3 vSigmaX = dFdx( surf_pos );\n     vec3 vSigmaY = dFdy( surf_pos );\n     vec3 vN = surf_norm;\n     vec3 R1 = cross( vSigmaY, vN );\n      vec3 R2 = cross( vN, vSigmaX );\n      float fDet = dot( vSigmaX, R1 );\n     vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n   }\n#endif\n",
	         clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n for ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n      vec4 plane = clippingPlanes[ i ];\n    if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n }\n      \n #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n     bool clipped = true;\n     for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n         vec4 plane = clippingPlanes[ i ];\n       clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n      }\n      if ( clipped ) discard;\n  \n #endif\n#endif\n",
	         clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n  #if ! defined( PHYSICAL ) && ! defined( PHONG )\n     varying vec3 vViewPosition;\n #endif\n uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
	         clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n  varying vec3 vViewPosition;\n#endif\n",
	         clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n vViewPosition = - mvPosition.xyz;\n#endif\n",
	         color_fragment: "#ifdef USE_COLOR\n diffuseColor.rgb *= vColor;\n#endif",
	         color_pars_fragment: "#ifdef USE_COLOR\n  varying vec3 vColor;\n#endif\n",
	         color_pars_vertex: "#ifdef USE_COLOR\n varying vec3 vColor;\n#endif",
	         color_vertex: "#ifdef USE_COLOR\n   vColor.xyz = color.xyz;\n#endif",
	         common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n   highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n bool visible;\n};\nstruct ReflectedLight {\n vec3 directDiffuse;\n   vec3 directSpecular;\n  vec3 indirectDiffuse;\n vec3 indirectSpecular;\n};\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n  return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n   float distance = dot( planeNormal, point - pointOnPlane );\n   return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n   return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n   return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n  mat3 tmp;\n tmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n  tmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n  tmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n  return tmp;\n}\n",
	         cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n  vec3 absDirection = abs(direction);\n  int face = -1;\n  if( absDirection.x > absDirection.z ) {\n    if(absDirection.x > absDirection.y )\n       face = direction.x > 0.0 ? 0 : 3;\n    else\n         face = direction.y > 0.0 ? 1 : 4;\n }\n   else {\n    if(absDirection.z > absDirection.y )\n       face = direction.z > 0.0 ? 2 : 5;\n    else\n         face = direction.y > 0.0 ? 1 : 4;\n }\n   return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n  float dxRoughness = dFdx(roughness);\n float dyRoughness = dFdy(roughness);\n vec3 dx = dFdx( vec * scale * dxRoughness );\n  vec3 dy = dFdy( vec * scale * dyRoughness );\n  float d = max( dot( dx, dx ), dot( dy, dy ) );\n   d = clamp(d, 1.0, cubeUV_rangeClamp);\n   float mipLevel = 0.5 * log2(d);\n   return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n  mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n   float a = 16.0 * cubeUV_rcpTextureSize;\n vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n   float powScale = exp2_packed.x * exp2_packed.y;\n  float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n  float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n bool bRes = mipLevel == 0.0;\n   scale =  bRes && (scale < a) ? a : scale;\n  vec3 r;\n   vec2 offset;\n int face = getFaceFromDirection(direction);\n   float rcpPowScale = 1.0 / powScale;\n  if( face == 0) {\n      r = vec3(direction.x, -direction.z, direction.y);\n      offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n    offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n  }\n   else if( face == 1) {\n    r = vec3(direction.y, direction.x, direction.z);\n    offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n    offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n  }\n   else if( face == 2) {\n    r = vec3(direction.z, direction.x, direction.y);\n    offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n      offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n  }\n   else if( face == 3) {\n    r = vec3(direction.x, direction.z, direction.y);\n    offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n     offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n   }\n   else if( face == 4) {\n    r = vec3(direction.y, direction.x, -direction.z);\n      offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n     offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n   }\n   else {\n    r = vec3(direction.z, -direction.x, direction.y);\n      offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n    offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n   }\n   r = normalize(r);\n  float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n vec2 base = offset + vec2( texelOffset );\n  return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n  float roughnessVal = roughness* cubeUV_maxLods3;\n float r1 = floor(roughnessVal);\n   float r2 = r1 + 1.0;\n  float t = fract(roughnessVal);\n vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n float s = mipInfo.y;\n  float level0 = mipInfo.x;\n   float level1 = level0 + 1.0;\n   level1 = level1 > 5.0 ? 5.0 : level1;\n   level0 += min( floor( s + 0.5 ), 5.0 );\n vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n   vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n   vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n   vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n   vec4 result = mix(color10, color20, t);\n return vec4(result.rgb, 1.0);\n}\n#endif\n",
	         defaultnormal_vertex: "#ifdef FLIP_SIDED\n   objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
	         displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n  uniform sampler2D displacementMap;\n   uniform float displacementScale;\n  uniform float displacementBias;\n#endif\n",
	         displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
	         emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
	         emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n  uniform sampler2D emissiveMap;\n#endif\n",
	         encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
	         encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n   return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n float maxComponent = max( max( value.r, value.g ), value.b );\n   float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n   float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n   M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n   float maxRGB = max( value.x, max( value.g, value.b ) );\n   float D      = max( maxRange / maxRGB, 1.0 );\n D            = min( floor( D ) / 255.0, 1.0 );\n   return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n vec4 vResult;\n   vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n   float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n   vResult.w = fract(Le);\n   vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n   vec3 Xp_Y_XYZp;\n Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n",
	         envmap_fragment: "#ifdef USE_ENVMAP\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n     vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n      vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n      #ifdef ENVMAP_MODE_REFLECTION\n        vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n    #else\n        vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n     #endif\n #else\n     vec3 reflectVec = vReflect;\n #endif\n #ifdef ENVMAP_TYPE_CUBE\n     vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n    vec2 sampleUV;\n     sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n    sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n      vec4 envColor = texture2D( envMap, sampleUV );\n   #elif defined( ENVMAP_TYPE_SPHERE )\n     vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n    vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n   #else\n     vec4 envColor = vec4( 0.0 );\n   #endif\n envColor = envMapTexelToLinear( envColor );\n   #ifdef ENVMAP_BLENDING_MULTIPLY\n      outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n   #elif defined( ENVMAP_BLENDING_MIX )\n    outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n #elif defined( ENVMAP_BLENDING_ADD )\n    outgoingLight += envColor.xyz * specularStrength * reflectivity;\n   #endif\n#endif\n",
	         envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n  uniform float reflectivity;\n uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n      varying vec3 vWorldPosition;\n   #endif\n #ifdef ENVMAP_TYPE_CUBE\n     uniform samplerCube envMap;\n #else\n     uniform sampler2D envMap;\n   #endif\n uniform float flipEnvMap;\n   #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n      uniform float refractionRatio;\n #else\n     varying vec3 vReflect;\n   #endif\n#endif\n",
	         envmap_pars_vertex: "#ifdef USE_ENVMAP\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n     varying vec3 vWorldPosition;\n   #else\n     varying vec3 vReflect;\n      uniform float refractionRatio;\n #endif\n#endif\n",
	         envmap_vertex: "#ifdef USE_ENVMAP\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n     vWorldPosition = worldPosition.xyz;\n  #else\n     vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n      vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n    #ifdef ENVMAP_MODE_REFLECTION\n        vReflect = reflect( cameraToVertex, worldNormal );\n     #else\n        vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n      #endif\n #endif\n#endif\n",
	         fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
	         fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
	         fog_fragment: "#ifdef USE_FOG\n  #ifdef FOG_EXP2\n    float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n   #else\n     float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n   #endif\n gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
	         fog_pars_fragment: "#ifdef USE_FOG\n   uniform vec3 fogColor;\n   varying float fogDepth;\n  #ifdef FOG_EXP2\n    uniform float fogDensity;\n   #else\n     uniform float fogNear;\n      uniform float fogFar;\n #endif\n#endif\n",
	         gradientmap_pars_fragment: "#ifdef TOON\n uniform sampler2D gradientMap;\n vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n      float dotNL = dot( normal, lightDirection );\n     vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n     #ifdef USE_GRADIENTMAP\n         return texture2D( gradientMap, coord ).rgb;\n      #else\n        return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n     #endif\n }\n#endif\n",
	         lightmap_fragment: "#ifdef USE_LIGHTMAP\n reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
	         lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n  uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n#endif",
	         lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n  vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n   for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n     getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n      dotNL = dot( geometry.normal, directLight.direction );\n    directLightColor_Diffuse = PI * directLight.color;\n     vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n    #ifdef DOUBLE_SIDED\n         vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n    #endif\n }\n#endif\n#if NUM_SPOT_LIGHTS > 0\n   for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n     dotNL = dot( geometry.normal, directLight.direction );\n    directLightColor_Diffuse = PI * directLight.color;\n     vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n    #ifdef DOUBLE_SIDED\n         vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n    #endif\n }\n#endif\n#if NUM_DIR_LIGHTS > 0\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n    getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n      dotNL = dot( geometry.normal, directLight.direction );\n    directLightColor_Diffuse = PI * directLight.color;\n     vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n    #ifdef DOUBLE_SIDED\n         vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n    #endif\n }\n#endif\n#if NUM_HEMI_LIGHTS > 0\n   for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n      vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n      #ifdef DOUBLE_SIDED\n         vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n      #endif\n }\n#endif\n",
	         lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n vec3 irradiance = ambientLightColor;\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n    irradiance *= PI;\n  #endif\n return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n struct DirectionalLight {\n      vec3 direction;\n    vec3 color;\n     int shadow;\n     float shadowBias;\n     float shadowRadius;\n      vec2 shadowMapSize;\n   };\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n   void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n     directLight.color = directionalLight.color;\n      directLight.direction = directionalLight.direction;\n    directLight.visible = true;\n }\n#endif\n#if NUM_POINT_LIGHTS > 0\n  struct PointLight {\n      vec3 position;\n     vec3 color;\n     float distance;\n    float decay;\n    int shadow;\n     float shadowBias;\n     float shadowRadius;\n      vec2 shadowMapSize;\n   };\n  uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n     vec3 lVector = pointLight.position - geometry.position;\n      directLight.direction = normalize( lVector );\n    float lightDistance = length( lVector );\n      directLight.color = pointLight.color;\n      directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n      directLight.visible = ( directLight.color != vec3( 0.0 ) );\n  }\n#endif\n#if NUM_SPOT_LIGHTS > 0\n   struct SpotLight {\n    vec3 position;\n     vec3 direction;\n    vec3 color;\n     float distance;\n    float decay;\n    float coneCos;\n     float penumbraCos;\n    int shadow;\n     float shadowBias;\n     float shadowRadius;\n      vec2 shadowMapSize;\n   };\n  uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n    vec3 lVector = spotLight.position - geometry.position;\n    directLight.direction = normalize( lVector );\n    float lightDistance = length( lVector );\n      float angleCos = dot( directLight.direction, spotLight.direction );\n      if ( angleCos > spotLight.coneCos ) {\n         float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n       directLight.color = spotLight.color;\n       directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n       directLight.visible = true;\n    } else {\n        directLight.color = vec3( 0.0 );\n        directLight.visible = false;\n      }\n   }\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n struct RectAreaLight {\n      vec3 color;\n     vec3 position;\n     vec3 halfWidth;\n    vec3 halfHeight;\n   };\n  uniform sampler2D ltcMat;  uniform sampler2D ltcMag;\n   uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n   struct HemisphereLight {\n    vec3 direction;\n    vec3 skyColor;\n     vec3 groundColor;\n  };\n  uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n      float dotNL = dot( geometry.normal, hemiLight.direction );\n      float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n     vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n     #ifndef PHYSICALLY_CORRECT_LIGHTS\n       irradiance *= PI;\n     #endif\n    return irradiance;\n }\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n  vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n    vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n      #ifdef ENVMAP_TYPE_CUBE\n        vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n         #ifdef TEXTURE_LOD_EXT\n            vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n         #else\n           vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n         #endif\n       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n    #elif defined( ENVMAP_TYPE_CUBE_UV )\n       vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n         vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n     #else\n        vec4 envMapColor = vec4( 0.0 );\n      #endif\n    return PI * envMapColor.rgb * envMapIntensity;\n   }\n   float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n      float maxMIPLevelScalar = float( maxMIPLevel );\n     float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n    return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n  }\n   vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n      #ifdef ENVMAP_MODE_REFLECTION\n        vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n      #else\n        vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n    #endif\n    reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n     float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n    #ifdef ENVMAP_TYPE_CUBE\n        vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n       #ifdef TEXTURE_LOD_EXT\n            vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n         #else\n           vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n         #endif\n       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n    #elif defined( ENVMAP_TYPE_CUBE_UV )\n       vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n       vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n      #elif defined( ENVMAP_TYPE_EQUIREC )\n       vec2 sampleUV;\n        sampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n        sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n        #ifdef TEXTURE_LOD_EXT\n            vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n         #else\n           vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n         #endif\n       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n    #elif defined( ENVMAP_TYPE_SPHERE )\n        vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n       #ifdef TEXTURE_LOD_EXT\n            vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n         #else\n           vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n         #endif\n       envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n    #endif\n    return envMapColor.rgb * envMapIntensity;\n  }\n#endif\n",
	         lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
	         lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n   vec3  diffuseColor;\n   vec3  specularColor;\n  float specularShininess;\n float specularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n void RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n      vec3 normal = geometry.normal;\n    vec3 viewDir = geometry.viewDir;\n     vec3 position = geometry.position;\n      vec3 lightPos = rectAreaLight.position;\n    vec3 halfWidth = rectAreaLight.halfWidth;\n     vec3 halfHeight = rectAreaLight.halfHeight;\n      vec3 lightColor = rectAreaLight.color;\n     float roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n      vec3 rectCoords[ 4 ];\n    rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;     rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n      rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n      rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n      vec2 uv = LTC_Uv( normal, viewDir, roughness );\n     float norm = texture2D( ltcMag, uv ).a;\n    vec4 t = texture2D( ltcMat, uv );\n    mat3 mInv = mat3(\n        vec3(   1,   0, t.y ),\n         vec3(   0, t.z,   0 ),\n         vec3( t.w,   0, t.x )\n    );\n     reflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n    reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n  }\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n   #ifdef TOON\n     vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n #else\n     float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n    vec3 irradiance = dotNL * directLight.color;\n  #endif\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n    irradiance *= PI;\n  #endif\n reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n   reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n  reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct           RE_Direct_BlinnPhong\n#define RE_Direct_RectArea      RE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse      RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )  (0)\n",
	         lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n   material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n   material.clearCoat = saturate( clearCoat );  material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
	         lights_physical_pars_fragment: "struct PhysicalMaterial {\n vec3  diffuseColor;\n   float specularRoughness;\n vec3  specularColor;\n  #ifndef STANDARD\n      float clearCoat;\n      float clearCoatRoughness;\n   #endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n  void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n    vec3 normal = geometry.normal;\n    vec3 viewDir = geometry.viewDir;\n     vec3 position = geometry.position;\n      vec3 lightPos = rectAreaLight.position;\n    vec3 halfWidth = rectAreaLight.halfWidth;\n     vec3 halfHeight = rectAreaLight.halfHeight;\n      vec3 lightColor = rectAreaLight.color;\n     float roughness = material.specularRoughness;\n    vec3 rectCoords[ 4 ];\n    rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;     rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n      rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n      rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n      vec2 uv = LTC_Uv( normal, viewDir, roughness );\n     float norm = texture2D( ltcMag, uv ).a;\n    vec4 t = texture2D( ltcMat, uv );\n    mat3 mInv = mat3(\n        vec3(   1,   0, t.y ),\n         vec3(   0, t.z,   0 ),\n         vec3( t.w,   0, t.x )\n    );\n     reflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n    reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n  }\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n vec3 irradiance = dotNL * directLight.color;\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    irradiance *= PI;\n  #endif\n #ifndef STANDARD\n      float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n     float clearCoatDHR = 0.0;\n   #endif\n reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n   reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n  #ifndef STANDARD\n      reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n #endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n  reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n   #ifndef STANDARD\n      float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n      float dotNL = dotNV;\n     float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n     float clearCoatDHR = 0.0;\n   #endif\n reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n #ifndef STANDARD\n      reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n  #endif\n}\n#define RE_Direct           RE_Direct_Physical\n#define RE_Direct_RectArea     RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse     RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular    RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n   return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
	         lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n   PointLight pointLight;\n   for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n     pointLight = pointLights[ i ];\n    getPointDirectLightIrradiance( pointLight, geometry, directLight );\n      #ifdef USE_SHADOWMAP\n     directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n      #endif\n    RE_Direct( directLight, geometry, material, reflectedLight );\n   }\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n  SpotLight spotLight;\n  for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      spotLight = spotLights[ i ];\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n     #ifdef USE_SHADOWMAP\n     directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n     #endif\n    RE_Direct( directLight, geometry, material, reflectedLight );\n   }\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n   DirectionalLight directionalLight;\n   for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n    directionalLight = directionalLights[ i ];\n    getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n      #ifdef USE_SHADOWMAP\n     directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n     #endif\n    RE_Direct( directLight, geometry, material, reflectedLight );\n   }\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n   RectAreaLight rectAreaLight;\n   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n    rectAreaLight = rectAreaLights[ i ];\n    RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n }\n#endif\n#if defined( RE_IndirectDiffuse )\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n  #ifdef USE_LIGHTMAP\n      vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n       lightMapIrradiance *= PI;\n      #endif\n    irradiance += lightMapIrradiance;\n #endif\n #if ( NUM_HEMI_LIGHTS > 0 )\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n         irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n    }\n   #endif\n #if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n      irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n   #endif\n RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n   #ifndef STANDARD\n      vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n  #else\n     vec3 clearCoatRadiance = vec3( 0.0 );\n   #endif\n RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
	         logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n  gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
	         logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n  uniform float logDepthBufFC;\n   #ifdef USE_LOGDEPTHBUF_EXT\n     varying float vFragDepth;\n   #endif\n#endif\n",
	         logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n #ifdef USE_LOGDEPTHBUF_EXT\n     varying float vFragDepth;\n   #endif\n uniform float logDepthBufFC;\n#endif",
	         logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n   gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n  #ifdef USE_LOGDEPTHBUF_EXT\n     vFragDepth = 1.0 + gl_Position.w;\n #else\n     gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n #endif\n#endif\n",
	         map_fragment: "#ifdef USE_MAP\n  vec4 texelColor = texture2D( map, vUv );\n   texelColor = mapTexelToLinear( texelColor );\n  diffuseColor *= texelColor;\n#endif\n",
	         map_pars_fragment: "#ifdef USE_MAP\n   uniform sampler2D map;\n#endif\n",
	         map_particle_fragment: "#ifdef USE_MAP\n  vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
	         map_particle_pars_fragment: "#ifdef USE_MAP\n   uniform vec4 offsetRepeat;\n  uniform sampler2D map;\n#endif\n",
	         metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n  vec4 texelMetalness = texture2D( metalnessMap, vUv );\n  metalnessFactor *= texelMetalness.b;\n#endif\n",
	         metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n   uniform sampler2D metalnessMap;\n#endif",
	         morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n  objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n  objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n  objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n  objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
	         morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n   #ifndef USE_MORPHNORMALS\n uniform float morphTargetInfluences[ 8 ];\n  #else\n  uniform float morphTargetInfluences[ 4 ];\n  #endif\n#endif",
	         morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n  transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n #ifndef USE_MORPHNORMALS\n transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n #endif\n#endif\n",
	         normal_flip: "#ifdef DOUBLE_SIDED\n float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n float flipNormal = 1.0;\n#endif\n",
	         normal_fragment: "#ifdef FLAT_SHADED\n vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n   vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n  normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
	         normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n   uniform sampler2D normalMap;\n   uniform vec2 normalScale;\n   vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n     vec3 q0 = dFdx( eye_pos.xyz );\n    vec3 q1 = dFdy( eye_pos.xyz );\n    vec2 st0 = dFdx( vUv.st );\n     vec2 st1 = dFdy( vUv.st );\n     vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n     vec3 N = normalize( surf_norm );\n     vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n     mapN.xy = normalScale * mapN.xy;\n     mat3 tsn = mat3( S, T, N );\n    return normalize( tsn * mapN );\n   }\n#endif\n",
	         packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8; return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n   return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
	         premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
	         project_vertex: "#ifdef USE_SKINNING\n vec4 mvPosition = modelViewMatrix * skinned;\n#else\n vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
	         dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
	         dithering_pars_fragment: "#if defined( DITHERING )\n  vec3 dithering( vec3 color ) {\n    float grid_position = rand( gl_FragCoord.xy );\n      vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n     dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n     return color + dither_shift_RGB;\n  }\n#endif\n",
	         roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n  vec4 texelRoughness = texture2D( roughnessMap, vUv );\n  roughnessFactor *= texelRoughness.g;\n#endif\n",
	         roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n   uniform sampler2D roughnessMap;\n#endif",
	         shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n   #if NUM_DIR_LIGHTS > 0\n      uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n    varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n   #endif\n #if NUM_SPOT_LIGHTS > 0\n     uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n    varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n   #endif\n #if NUM_POINT_LIGHTS > 0\n    uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n     varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n #endif\n float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n     return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n }\n   float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n      const vec2 offset = vec2( 0.0, 1.0 );\n      vec2 texelSize = vec2( 1.0 ) / size;\n    vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n     float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n     float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n     float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n     float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n     vec2 f = fract( uv * size + 0.5 );\n      float a = mix( lb, lt, f.y );\n     float b = mix( rb, rt, f.y );\n     float c = mix( a, b, f.x );\n    return c;\n }\n   float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n     shadowCoord.xyz /= shadowCoord.w;\n    shadowCoord.z += shadowBias;\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n      bool inFrustum = all( inFrustumVec );\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n      bool frustumTest = all( frustumTestVec );\n     if ( frustumTest ) {\n     #if defined( SHADOWMAP_TYPE_PCF )\n       vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n       float dx0 = - texelSize.x * shadowRadius;\n        float dy0 = - texelSize.y * shadowRadius;\n        float dx1 = + texelSize.x * shadowRadius;\n        float dy1 = + texelSize.y * shadowRadius;\n        return (\n           texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n           texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n          texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n         ) * ( 1.0 / 9.0 );\n    #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n         vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n       float dx0 = - texelSize.x * shadowRadius;\n        float dy0 = - texelSize.y * shadowRadius;\n        float dx1 = + texelSize.x * shadowRadius;\n        float dy1 = + texelSize.y * shadowRadius;\n        return (\n           texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n           texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n          texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n         ) * ( 1.0 / 9.0 );\n    #else\n        return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n     #endif\n    }\n      return 1.0;\n  }\n   vec2 cubeToUV( vec3 v, float texelSizeY ) {\n      vec3 absV = abs( v );\n    float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n    absV *= scaleToCube;\n     v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n      vec2 planar = v.xy;\n      float almostATexel = 1.5 * texelSizeY;\n     float almostOne = 1.0 - almostATexel;\n      if ( absV.z >= almostOne ) {\n         if ( v.z > 0.0 )\n            planar.x = 4.0 - v.x;\n    } else if ( absV.x >= almostOne ) {\n        float signX = sign( v.x );\n        planar.x = v.z * signX + 2.0 * signX;\n      } else if ( absV.y >= almostOne ) {\n        float signY = sign( v.y );\n        planar.x = v.x + 2.0 * signY + 2.0;\n        planar.y = v.z * signY - 2.0;\n     }\n      return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n   }\n   float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n      vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n     vec3 lightToPosition = shadowCoord.xyz;\n    vec3 bd3D = normalize( lightToPosition );\n     float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n    #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n        vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n         return (\n           texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n          texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n            texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n        ) * ( 1.0 / 9.0 );\n    #else\n        return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n    #endif\n }\n#endif\n",
	         shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n  #if NUM_DIR_LIGHTS > 0\n      uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n      varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n   #endif\n #if NUM_SPOT_LIGHTS > 0\n     uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n      varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n   #endif\n #if NUM_POINT_LIGHTS > 0\n    uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n    varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n #endif\n#endif\n",
	         shadowmap_vertex: "#ifdef USE_SHADOWMAP\n #if NUM_DIR_LIGHTS > 0\n   for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n    vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n   }\n   #endif\n #if NUM_SPOT_LIGHTS > 0\n  for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n  }\n   #endif\n #if NUM_POINT_LIGHTS > 0\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n     vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n   }\n   #endif\n#endif\n",
	         shadowmask_pars_fragment: "float getShadowMask() {\n  float shadow = 1.0;\n   #ifdef USE_SHADOWMAP\n  #if NUM_DIR_LIGHTS > 0\n   DirectionalLight directionalLight;\n   for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n    directionalLight = directionalLights[ i ];\n    shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n   }\n   #endif\n #if NUM_SPOT_LIGHTS > 0\n  SpotLight spotLight;\n  for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      spotLight = spotLights[ i ];\n      shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n   }\n   #endif\n #if NUM_POINT_LIGHTS > 0\n PointLight pointLight;\n   for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n     pointLight = pointLights[ i ];\n    shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n }\n   #endif\n #endif\n return shadow;\n}\n",
	         skinbase_vertex: "#ifdef USE_SKINNING\n   mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
	         skinning_pars_vertex: "#ifdef USE_SKINNING\n uniform mat4 bindMatrix;\n uniform mat4 bindMatrixInverse;\n   #ifdef BONE_TEXTURE\n      uniform sampler2D boneTexture;\n    uniform int boneTextureSize;\n      mat4 getBoneMatrix( const in float i ) {\n         float j = i * 4.0;\n       float x = mod( j, float( boneTextureSize ) );\n       float y = floor( j / float( boneTextureSize ) );\n       float dx = 1.0 / float( boneTextureSize );\n       float dy = 1.0 / float( boneTextureSize );\n       y = dy * ( y + 0.5 );\n       vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n         vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n         vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n         vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n         mat4 bone = mat4( v1, v2, v3, v4 );\n        return bone;\n    }\n   #else\n     uniform mat4 boneMatrices[ MAX_BONES ];\n    mat4 getBoneMatrix( const in float i ) {\n         mat4 bone = boneMatrices[ int(i) ];\n        return bone;\n    }\n   #endif\n#endif\n",
	         skinning_vertex: "#ifdef USE_SKINNING\n   vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n  vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n skinned += boneMatY * skinVertex * skinWeight.y;\n skinned += boneMatZ * skinVertex * skinWeight.z;\n skinned += boneMatW * skinVertex * skinWeight.w;\n skinned  = bindMatrixInverse * skinned;\n#endif\n",
	         skinnormal_vertex: "#ifdef USE_SKINNING\n mat4 skinMatrix = mat4( 0.0 );\n skinMatrix += skinWeight.x * boneMatX;\n  skinMatrix += skinWeight.y * boneMatY;\n  skinMatrix += skinWeight.z * boneMatZ;\n  skinMatrix += skinWeight.w * boneMatW;\n  skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n   objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
	         specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n   vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n#else\n specularStrength = 1.0;\n#endif",
	         specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n  uniform sampler2D specularMap;\n#endif",
	         tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
	         tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
	         uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n   varying vec2 vUv;\n#endif",
	         uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n  varying vec2 vUv;\n  uniform vec4 offsetRepeat;\n#endif\n",
	         uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
	         uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n  varying vec2 vUv2;\n#endif",
	         uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n attribute vec2 uv2;\n   varying vec2 vUv2;\n#endif",
	         uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n   vUv2 = uv2;\n#endif",
	         worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n  #ifdef USE_SKINNING\n      vec4 worldPosition = modelMatrix * skinned;\n   #else\n     vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n #endif\n#endif\n",
	         cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n   gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n  gl_FragColor.a *= opacity;\n}\n",
	         cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n  vWorldPosition = transformDirection( position, modelMatrix );\n   #include <begin_vertex>\n  #include <project_vertex>\n}\n",
	         depth_frag: "#if DEPTH_PACKING == 3200\n  uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n #include <clipping_planes_fragment>\n  vec4 diffuseColor = vec4( 1.0 );\n  #if DEPTH_PACKING == 3200\n      diffuseColor.a = opacity;\n   #endif\n #include <map_fragment>\n  #include <alphamap_fragment>\n   #include <alphatest_fragment>\n  #include <logdepthbuf_fragment>\n   #if DEPTH_PACKING == 3200\n      gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n   #elif DEPTH_PACKING == 3201\n    gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n   #endif\n}\n",
	         depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n  #include <uv_vertex>\n  #include <skinbase_vertex>\n  #include <begin_vertex>\n  #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n}\n",
	         distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n   #include <clipping_planes_fragment>\n  gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
	         distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n  #include <skinbase_vertex>\n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <worldpos_vertex>\n  #include <clipping_planes_vertex>\n vWorldPosition = worldPosition;\n}\n",
	         equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n   vec3 direction = normalize( vWorldPosition );\n vec2 sampleUV;\n  sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n   sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
	         equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n vWorldPosition = transformDirection( position, modelMatrix );\n   #include <begin_vertex>\n  #include <project_vertex>\n}\n",
	         linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n  if ( mod( vLineDistance, totalSize ) > dashSize ) {\n    discard;\n  }\n   vec3 outgoingLight = vec3( 0.0 );\n vec4 diffuseColor = vec4( diffuse, opacity );\n #include <logdepthbuf_fragment>\n   #include <color_fragment>\n   outgoingLight = diffuseColor.rgb;\n gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  #include <premultiplied_alpha_fragment>\n #include <tonemapping_fragment>\n   #include <encodings_fragment>\n  #include <fog_fragment>\n}\n",
	         linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n #include <color_vertex>\n  vLineDistance = scale * lineDistance;\n   vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n   gl_Position = projectionMatrix * mvPosition;\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n #include <fog_vertex>\n}\n",
	         meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n  vec4 diffuseColor = vec4( diffuse, opacity );\n #include <logdepthbuf_fragment>\n   #include <map_fragment>\n  #include <color_fragment>\n   #include <alphamap_fragment>\n   #include <alphatest_fragment>\n  #include <specularmap_fragment>\n   ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  #ifdef USE_LIGHTMAP\n      reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  #else\n     reflectedLight.indirectDiffuse += vec3( 1.0 );\n   #endif\n #include <aomap_fragment>\n   reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n vec3 outgoingLight = reflectedLight.indirectDiffuse;\n   #include <normal_flip>\n   #include <envmap_fragment>\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  #include <premultiplied_alpha_fragment>\n #include <tonemapping_fragment>\n   #include <encodings_fragment>\n  #include <fog_fragment>\n}\n",
	         meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n  #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n  #include <skinbase_vertex>\n  #ifdef USE_ENVMAP\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinnormal_vertex>\n   #include <defaultnormal_vertex>\n   #endif\n #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <logdepthbuf_vertex>\n  #include <worldpos_vertex>\n  #include <clipping_planes_vertex>\n #include <envmap_vertex>\n #include <fog_vertex>\n}\n",
	         meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n   varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n   #include <clipping_planes_fragment>\n  vec4 diffuseColor = vec4( diffuse, opacity );\n ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive;\n  #include <logdepthbuf_fragment>\n   #include <map_fragment>\n  #include <color_fragment>\n   #include <alphamap_fragment>\n   #include <alphatest_fragment>\n  #include <specularmap_fragment>\n   #include <emissivemap_fragment>\n   reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n  #include <lightmap_fragment>\n   reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n #ifdef DOUBLE_SIDED\n      reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n  #else\n     reflectedLight.directDiffuse = vLightFront;\n   #endif\n reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n   #include <aomap_fragment>\n   vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n  #include <normal_flip>\n   #include <envmap_fragment>\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  #include <tonemapping_fragment>\n   #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n #include <dithering_fragment>\n}\n",
	         meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n   varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n  #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n   #include <defaultnormal_vertex>\n   #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n #include <worldpos_vertex>\n  #include <envmap_vertex>\n #include <lights_lambert_vertex>\n  #include <shadowmap_vertex>\n #include <fog_vertex>\n}\n",
	         meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n  vec4 diffuseColor = vec4( diffuse, opacity );\n ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive;\n  #include <logdepthbuf_fragment>\n   #include <map_fragment>\n  #include <color_fragment>\n   #include <alphamap_fragment>\n   #include <alphatest_fragment>\n  #include <specularmap_fragment>\n   #include <normal_flip>\n   #include <normal_fragment>\n  #include <emissivemap_fragment>\n   #include <lights_phong_fragment>\n  #include <lights_template>\n  #include <aomap_fragment>\n   vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  #include <envmap_fragment>\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  #include <tonemapping_fragment>\n   #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n #include <dithering_fragment>\n}\n",
	         meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n   #include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n   vNormal = normalize( transformedNormal );\n#endif\n   #include <begin_vertex>\n  #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n vViewPosition = - mvPosition.xyz;\n #include <worldpos_vertex>\n  #include <envmap_vertex>\n #include <shadowmap_vertex>\n #include <fog_vertex>\n}\n",
	         meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n uniform float clearCoat;\n uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n   varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n #include <clipping_planes_fragment>\n  vec4 diffuseColor = vec4( diffuse, opacity );\n ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive;\n  #include <logdepthbuf_fragment>\n   #include <map_fragment>\n  #include <color_fragment>\n   #include <alphamap_fragment>\n   #include <alphatest_fragment>\n  #include <specularmap_fragment>\n   #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_flip>\n   #include <normal_fragment>\n  #include <emissivemap_fragment>\n   #include <lights_physical_fragment>\n  #include <lights_template>\n  #include <aomap_fragment>\n   vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  #include <tonemapping_fragment>\n   #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n #include <dithering_fragment>\n}\n",
	         meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n   #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n   #include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n   vNormal = normalize( transformedNormal );\n#endif\n   #include <begin_vertex>\n  #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n vViewPosition = - mvPosition.xyz;\n #include <worldpos_vertex>\n  #include <shadowmap_vertex>\n #include <fog_vertex>\n}\n",
	         normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n  varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n #include <logdepthbuf_fragment>\n   #include <normal_flip>\n   #include <normal_fragment>\n  gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
	         normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n  varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n #include <uv_vertex>\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n   #include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n   vNormal = normalize( transformedNormal );\n#endif\n   #include <begin_vertex>\n  #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n   #include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n vViewPosition = - mvPosition.xyz;\n#endif\n}\n",
	         points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n #include <clipping_planes_fragment>\n  vec3 outgoingLight = vec3( 0.0 );\n vec4 diffuseColor = vec4( diffuse, opacity );\n #include <logdepthbuf_fragment>\n   #include <map_particle_fragment>\n  #include <color_fragment>\n   #include <alphatest_fragment>\n  outgoingLight = diffuseColor.rgb;\n gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  #include <premultiplied_alpha_fragment>\n #include <tonemapping_fragment>\n   #include <encodings_fragment>\n  #include <fog_fragment>\n}\n",
	         points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n  #include <color_vertex>\n  #include <begin_vertex>\n  #include <project_vertex>\n   #ifdef USE_SIZEATTENUATION\n     gl_PointSize = size * ( scale / - mvPosition.z );\n   #else\n     gl_PointSize = size;\n  #endif\n #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n #include <worldpos_vertex>\n  #include <shadowmap_vertex>\n #include <fog_vertex>\n}\n",
	         shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n   gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
	         shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n   #include <begin_vertex>\n  #include <project_vertex>\n   #include <worldpos_vertex>\n  #include <shadowmap_vertex>\n}\n"
	      },
	      ab = {
	         basic: {
	            uniforms: Ha.merge([V.common, V.aomap, V.lightmap, V.fog]),
	            vertexShader: U.meshbasic_vert,
	            fragmentShader: U.meshbasic_frag
	         },
	         lambert: {
	            uniforms: Ha.merge([V.common, V.aomap, V.lightmap, V.emissivemap, V.fog, V.lights,
	            {
	               emissive: {
	                  value: new H(0)
	               }
	            }]),
	            vertexShader: U.meshlambert_vert,
	            fragmentShader: U.meshlambert_frag
	         },
	         phong: {
	            uniforms: Ha.merge([V.common, V.aomap, V.lightmap, V.emissivemap, V.bumpmap, V.normalmap, V.displacementmap, V.gradientmap, V.fog, V.lights,
	            {
	               emissive: {
	                  value: new H(0)
	               },
	               specular: {
	                  value: new H(1118481)
	               },
	               shininess: {
	                  value: 30
	               }
	            }]),
	            vertexShader: U.meshphong_vert,
	            fragmentShader: U.meshphong_frag
	         },
	         standard: {
	            uniforms: Ha.merge([V.common, V.aomap, V.lightmap, V.emissivemap, V.bumpmap, V.normalmap, V.displacementmap, V.roughnessmap, V.metalnessmap, V.fog, V.lights,
	            {
	               emissive: {
	                  value: new H(0)
	               },
	               roughness: {
	                  value: .5
	               },
	               metalness: {
	                  value: .5
	               },
	               envMapIntensity: {
	                  value: 1
	               }
	            }]),
	            vertexShader: U.meshphysical_vert,
	            fragmentShader: U.meshphysical_frag
	         },
	         points: {
	            uniforms: Ha.merge([V.points, V.fog]),
	            vertexShader: U.points_vert,
	            fragmentShader: U.points_frag
	         },
	         dashed: {
	            uniforms: Ha.merge([V.common, V.fog,
	            {
	               scale: {
	                  value: 1
	               },
	               dashSize: {
	                  value: 1
	               },
	               totalSize: {
	                  value: 2
	               }
	            }]),
	            vertexShader: U.linedashed_vert,
	            fragmentShader: U.linedashed_frag
	         },
	         depth: {
	            uniforms: Ha.merge([V.common, V.displacementmap]),
	            vertexShader: U.depth_vert,
	            fragmentShader: U.depth_frag
	         },
	         normal: {
	            uniforms: Ha.merge([V.common, V.bumpmap, V.normalmap, V.displacementmap,
	            {
	               opacity: {
	                  value: 1
	               }
	            }]),
	            vertexShader: U.normal_vert,
	            fragmentShader: U.normal_frag
	         },
	         cube: {
	            uniforms: {
	               tCube: {
	                  value: null
	               },
	               tFlip: {
	                  value: -1
	               },
	               opacity: {
	                  value: 1
	               }
	            },
	            vertexShader: U.cube_vert,
	            fragmentShader: U.cube_frag
	         },
	         equirect: {
	            uniforms: {
	               tEquirect: {
	                  value: null
	               },
	               tFlip: {
	                  value: -1
	               }
	            },
	            vertexShader: U.equirect_vert,
	            fragmentShader: U.equirect_frag
	         },
	         distanceRGBA: {
	            uniforms: {
	               lightPos: {
	                  value: new p
	               }
	            },
	            vertexShader: U.distanceRGBA_vert,
	            fragmentShader: U.distanceRGBA_frag
	         }
	      };
	   ab.physical = {
	      uniforms: Ha.merge([ab.standard.uniforms,
	      {
	         clearCoat: {
	            value: 0
	         },
	         clearCoatRoughness: {
	            value: 0
	         }
	      }]),
	      vertexShader: U.meshphysical_vert,
	      fragmentShader: U.meshphysical_frag
	   };
	   Object.assign(id.prototype, {
	      set: function(a, b) {
	         this.min.copy(a);
	         this.max.copy(b);
	         return this
	      },
	      setFromPoints: function(a) {
	         this.makeEmpty();
	         for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
	         return this
	      },
	      setFromCenterAndSize: function() {
	         var a = new D;
	         return function(b, c) {
	            var d = a.copy(c).multiplyScalar(.5);
	            this.min.copy(b).sub(d);
	            this.max.copy(b).add(d);
	            return this
	         }
	      }(),
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.min.copy(a.min);
	         this.max.copy(a.max);
	         return this
	      },
	      makeEmpty: function() {
	         this.min.x = this.min.y = Infinity;
	         this.max.x = this.max.y = -Infinity;
	         return this
	      },
	      isEmpty: function() {
	         return this.max.x < this.min.x || this.max.y < this.min.y
	      },
	      getCenter: function(a) {
	         a = a || new D;
	         return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
	      },
	      getSize: function(a) {
	         a = a || new D;
	         return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
	      },
	      expandByPoint: function(a) {
	         this.min.min(a);
	         this.max.max(a);
	         return this
	      },
	      expandByVector: function(a) {
	         this.min.sub(a);
	         this.max.add(a);
	         return this
	      },
	      expandByScalar: function(a) {
	         this.min.addScalar(-a);
	         this.max.addScalar(a);
	         return this
	      },
	      containsPoint: function(a) {
	         return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
	      },
	      containsBox: function(a) {
	         return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
	      },
	      getParameter: function(a, b) {
	         return (b || new D).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
	      },
	      intersectsBox: function(a) {
	         return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
	      },
	      clampPoint: function(a, b) {
	         return (b || new D).copy(a).clamp(this.min, this.max)
	      },
	      distanceToPoint: function() {
	         var a = new D;
	         return function(b) {
	            return a.copy(b).clamp(this.min, this.max).sub(b).length()
	         }
	      }(),
	      intersect: function(a) {
	         this.min.max(a.min);
	         this.max.min(a.max);
	         return this
	      },
	      union: function(a) {
	         this.min.min(a.min);
	         this.max.max(a.max);
	         return this
	      },
	      translate: function(a) {
	         this.min.add(a);
	         this.max.add(a);
	         return this
	      },
	      equals: function(a) {
	         return a.min.equals(this.min) && a.max.equals(this.max)
	      }
	   });
	   var Kf = 0;
	   Object.assign(Z.prototype, sa.prototype, {
	      isMaterial: !0,
	      setValues: function(a) {
	         if (void 0 !== a) for (var b in a) {
	            var c = a[b];
	            if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
	            else {
	               var d = this[b];
	               void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
	            }
	         }
	      },
	      toJSON: function(a) {
	         function b(a) {
	            var b = [],
	               c;
	            for (c in a) {
	               var d = a[c];
	               delete d.metadata;
	               b.push(d)
	            }
	            return b
	         }
	         var c = void 0 === a;
	         c && (a = {
	            textures: {},
	            images: {}
	         });
	         var d = {
	            metadata: {
	               version: 4.5,
	               type: "Material",
	               generator: "Material.toJSON"
	            }
	         };
	         d.uuid = this.uuid;
	         d.type = this.type;
	         "" !== this.name && (d.name = this.name);
	         this.color && this.color.isColor && (d.color = this.color.getHex());
	         void 0 !== this.roughness && (d.roughness = this.roughness);
	         void 0 !== this.metalness && (d.metalness = this.metalness);
	         this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
	         this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
	         void 0 !== this.shininess && (d.shininess = this.shininess);
	         void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat);
	         void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness);
	         this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
	         this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
	         this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
	         this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
	         this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray());
	         this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
	         this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
	         this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
	         this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
	         this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
	         this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity);
	         this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
	         void 0 !== this.size && (d.size = this.size);
	         void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
	         1 !== this.blending && (d.blending = this.blending);
	         2 !== this.shading && (d.shading = this.shading);
	         0 !== this.side && (d.side = this.side);
	         0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
	         1 > this.opacity && (d.opacity = this.opacity);
	         !0 === this.transparent && (d.transparent = this.transparent);
	         d.depthFunc = this.depthFunc;
	         d.depthTest = this.depthTest;
	         d.depthWrite = this.depthWrite;
	         0 < this.alphaTest && (d.alphaTest = this.alphaTest);
	         !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha);
	         !0 === this.wireframe && (d.wireframe = this.wireframe);
	         1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
	         "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
	         "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
	         d.skinning = this.skinning;
	         d.morphTargets = this.morphTargets;
	         d.dithering = this.dithering;
	         c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
	         return d
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.name = a.name;
	         this.fog = a.fog;
	         this.lights = a.lights;
	         this.blending = a.blending;
	         this.side = a.side;
	         this.shading = a.shading;
	         this.vertexColors = a.vertexColors;
	         this.opacity = a.opacity;
	         this.transparent = a.transparent;
	         this.blendSrc = a.blendSrc;
	         this.blendDst = a.blendDst;
	         this.blendEquation = a.blendEquation;
	         this.blendSrcAlpha = a.blendSrcAlpha;
	         this.blendDstAlpha = a.blendDstAlpha;
	         this.blendEquationAlpha = a.blendEquationAlpha;
	         this.depthFunc = a.depthFunc;
	         this.depthTest = a.depthTest;
	         this.depthWrite = a.depthWrite;
	         this.colorWrite = a.colorWrite;
	         this.precision = a.precision;
	         this.polygonOffset = a.polygonOffset;
	         this.polygonOffsetFactor = a.polygonOffsetFactor;
	         this.polygonOffsetUnits = a.polygonOffsetUnits;
	         this.dithering = a.dithering;
	         this.alphaTest = a.alphaTest;
	         this.premultipliedAlpha = a.premultipliedAlpha;
	         this.overdraw = a.overdraw;
	         this.visible = a.visible;
	         this.clipShadows = a.clipShadows;
	         this.clipIntersection = a.clipIntersection;
	         a = a.clippingPlanes;
	         var b = null;
	         if (null !== a) for (var c = a.length, b = Array(c), d = 0; d !== c; ++d) b[d] = a[d].clone();
	         this.clippingPlanes = b;
	         return this
	      },
	      dispose: function() {
	         this.dispatchEvent({
	            type: "dispose"
	         })
	      }
	   });
	   Ea.prototype = Object.create(Z.prototype);
	   Ea.prototype.constructor = Ea;
	   Ea.prototype.isShaderMaterial = !0;
	   Ea.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.fragmentShader = a.fragmentShader;
	      this.vertexShader = a.vertexShader;
	      this.uniforms = Ha.clone(a.uniforms);
	      this.defines = a.defines;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      this.lights = a.lights;
	      this.clipping = a.clipping;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      this.morphNormals = a.morphNormals;
	      this.extensions = a.extensions;
	      return this
	   };
	   Ea.prototype.toJSON = function(a) {
	      a = Z.prototype.toJSON.call(this, a);
	      a.uniforms = this.uniforms;
	      a.vertexShader = this.vertexShader;
	      a.fragmentShader = this.fragmentShader;
	      return a
	   };
	   $a.prototype = Object.create(Z.prototype);
	   $a.prototype.constructor = $a;
	   $a.prototype.isMeshDepthMaterial = !0;
	   $a.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.depthPacking = a.depthPacking;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      this.map = a.map;
	      this.alphaMap = a.alphaMap;
	      this.displacementMap = a.displacementMap;
	      this.displacementScale = a.displacementScale;
	      this.displacementBias = a.displacementBias;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      return this
	   };
	   Object.assign(Ta.prototype, {
	      isBox3: !0,
	      set: function(a, b) {
	         this.min.copy(a);
	         this.max.copy(b);
	         return this
	      },
	      setFromArray: function(a) {
	         for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.length; h < k; h += 3) {
	            var m = a[h],
	               l = a[h + 1],
	               q = a[h + 2];
	            m < b && (b = m);
	            l < c && (c = l);
	            q < d && (d = q);
	            m > e && (e = m);
	            l > f && (f = l);
	            q > g && (g = q)
	         }
	         this.min.set(b, c, d);
	         this.max.set(e, f, g);
	         return this
	      },
	      setFromBufferAttribute: function(a) {
	         for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.count; h < k; h++) {
	            var m = a.getX(h),
	               l = a.getY(h),
	               q = a.getZ(h);
	            m < b && (b = m);
	            l < c && (c = l);
	            q < d && (d = q);
	            m > e && (e = m);
	            l > f && (f = l);
	            q > g && (g = q)
	         }
	         this.min.set(b, c, d);
	         this.max.set(e, f, g);
	         return this
	      },
	      setFromPoints: function(a) {
	         this.makeEmpty();
	         for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
	         return this
	      },
	      setFromCenterAndSize: function() {
	         var a = new p;
	         return function(b, c) {
	            var d = a.copy(c).multiplyScalar(.5);
	            this.min.copy(b).sub(d);
	            this.max.copy(b).add(d);
	            return this
	         }
	      }(),
	      setFromObject: function(a) {
	         this.makeEmpty();
	         return this.expandByObject(a)
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.min.copy(a.min);
	         this.max.copy(a.max);
	         return this
	      },
	      makeEmpty: function() {
	         this.min.x = this.min.y = this.min.z = Infinity;
	         this.max.x = this.max.y = this.max.z = -Infinity;
	         return this
	      },
	      isEmpty: function() {
	         return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
	      },
	      getCenter: function(a) {
	         a = a || new p;
	         return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
	      },
	      getSize: function(a) {
	         a = a || new p;
	         return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
	      },
	      expandByPoint: function(a) {
	         this.min.min(a);
	         this.max.max(a);
	         return this
	      },
	      expandByVector: function(a) {
	         this.min.sub(a);
	         this.max.add(a);
	         return this
	      },
	      expandByScalar: function(a) {
	         this.min.addScalar(-a);
	         this.max.addScalar(a);
	         return this
	      },
	      expandByObject: function() {
	         var a = new p;
	         return function(b) {
	            var c = this;
	            b.updateMatrixWorld(!0);
	            b.traverse(function(b) {
	               var e, f;
	               e = b.geometry;
	               if (void 0 !== e) if (e.isGeometry) {
	                  var g = e.vertices;
	                  e = 0;
	                  for (f = g.length; e < f; e++) a.copy(g[e]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
	               } else if (e.isBufferGeometry && (g = e.attributes.position, void 0 !== g)) for (e = 0, f = g.count; e < f; e++) a.fromBufferAttribute(g, e).applyMatrix4(b.matrixWorld), c.expandByPoint(a)
	            });
	            return this
	         }
	      }(),
	      containsPoint: function(a) {
	         return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
	      },
	      containsBox: function(a) {
	         return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
	      },
	      getParameter: function(a, b) {
	         return (b || new p).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
	      },
	      intersectsBox: function(a) {
	         return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
	      },
	      intersectsSphere: function() {
	         var a = new p;
	         return function(b) {
	            this.clampPoint(b.center, a);
	            return a.distanceToSquared(b.center) <= b.radius * b.radius
	         }
	      }(),
	      intersectsPlane: function(a) {
	         var b, c;
	         0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x);
	         0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
	         0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
	         return b <= a.constant && c >= a.constant
	      },
	      clampPoint: function(a, b) {
	         return (b || new p).copy(a).clamp(this.min, this.max)
	      },
	      distanceToPoint: function() {
	         var a = new p;
	         return function(b) {
	            return a.copy(b).clamp(this.min, this.max).sub(b).length()
	         }
	      }(),
	      getBoundingSphere: function() {
	         var a = new p;
	         return function(b) {
	            b = b || new Ga;
	            this.getCenter(b.center);
	            b.radius = .5 * this.getSize(a).length();
	            return b
	         }
	      }(),
	      intersect: function(a) {
	         this.min.max(a.min);
	         this.max.min(a.max);
	         this.isEmpty() && this.makeEmpty();
	         return this
	      },
	      union: function(a) {
	         this.min.min(a.min);
	         this.max.max(a.max);
	         return this
	      },
	      applyMatrix4: function() {
	         var a = [new p, new p, new p, new p, new p, new p, new p, new p];
	         return function(b) {
	            if (this.isEmpty()) return this;
	            a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
	            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
	            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
	            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
	            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
	            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
	            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
	            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
	            this.setFromPoints(a);
	            return this
	         }
	      }(),
	      translate: function(a) {
	         this.min.add(a);
	         this.max.add(a);
	         return this
	      },
	      equals: function(a) {
	         return a.min.equals(this.min) && a.max.equals(this.max)
	      }
	   });
	   Object.assign(Ga.prototype, {
	      set: function(a, b) {
	         this.center.copy(a);
	         this.radius = b;
	         return this
	      },
	      setFromPoints: function() {
	         var a = new Ta;
	         return function(b, c) {
	            var d = this.center;
	            void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
	            for (var e = 0, f = 0, g = b.length; f < g; f++) e = Math.max(e, d.distanceToSquared(b[f]));
	            this.radius = Math.sqrt(e);
	            return this
	         }
	      }(),
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.center.copy(a.center);
	         this.radius = a.radius;
	         return this
	      },
	      empty: function() {
	         return 0 >= this.radius
	      },
	      containsPoint: function(a) {
	         return a.distanceToSquared(this.center) <= this.radius * this.radius
	      },
	      distanceToPoint: function(a) {
	         return a.distanceTo(this.center) - this.radius
	      },
	      intersectsSphere: function(a) {
	         var b = this.radius + a.radius;
	         return a.center.distanceToSquared(this.center) <= b * b
	      },
	      intersectsBox: function(a) {
	         return a.intersectsSphere(this)
	      },
	      intersectsPlane: function(a) {
	         return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
	      },
	      clampPoint: function(a, b) {
	         var c = this.center.distanceToSquared(a),
	            d = b || new p;
	         d.copy(a);
	         c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
	         return d
	      },
	      getBoundingBox: function(a) {
	         a = a || new Ta;
	         a.set(this.center, this.center);
	         a.expandByScalar(this.radius);
	         return a
	      },
	      applyMatrix4: function(a) {
	         this.center.applyMatrix4(a);
	         this.radius *= a.getMaxScaleOnAxis();
	         return this
	      },
	      translate: function(a) {
	         this.center.add(a);
	         return this
	      },
	      equals: function(a) {
	         return a.center.equals(this.center) && a.radius === this.radius
	      }
	   });
	   Object.assign(Ka.prototype, {
	      isMatrix3: !0,
	      set: function(a, b, c, d, e, f, g, h, k) {
	         var m = this.elements;
	         m[0] = a;
	         m[1] = d;
	         m[2] = g;
	         m[3] = b;
	         m[4] = e;
	         m[5] = h;
	         m[6] = c;
	         m[7] = f;
	         m[8] = k;
	         return this
	      },
	      identity: function() {
	         this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).fromArray(this.elements)
	      },
	      copy: function(a) {
	         var b = this.elements;
	         a = a.elements;
	         b[0] = a[0];
	         b[1] = a[1];
	         b[2] = a[2];
	         b[3] = a[3];
	         b[4] = a[4];
	         b[5] = a[5];
	         b[6] = a[6];
	         b[7] = a[7];
	         b[8] = a[8];
	         return this
	      },
	      setFromMatrix4: function(a) {
	         a = a.elements;
	         this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
	         return this
	      },
	      applyToBufferAttribute: function() {
	         var a = new p;
	         return function(b) {
	            for (var c = 0, d = b.count; c < d; c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z);
	            return b
	         }
	      }(),
	      multiply: function(a) {
	         return this.multiplyMatrices(this, a)
	      },
	      premultiply: function(a) {
	         return this.multiplyMatrices(a, this)
	      },
	      multiplyMatrices: function(a, b) {
	         var c = a.elements,
	            d = b.elements,
	            e = this.elements,
	            f = c[0],
	            g = c[3],
	            h = c[6],
	            k = c[1],
	            m = c[4],
	            l = c[7],
	            q = c[2],
	            n = c[5],
	            c = c[8],
	            r = d[0],
	            p = d[3],
	            t = d[6],
	            y = d[1],
	            x = d[4],
	            v = d[7],
	            G = d[2],
	            w = d[5],
	            d = d[8];
	         e[0] = f * r + g * y + h * G;
	         e[3] = f * p + g * x + h * w;
	         e[6] = f * t + g * v + h * d;
	         e[1] = k * r + m * y + l * G;
	         e[4] = k * p + m * x + l * w;
	         e[7] = k * t + m * v + l * d;
	         e[2] = q * r + n * y + c * G;
	         e[5] = q * p + n * x + c * w;
	         e[8] = q * t + n * v + c * d;
	         return this
	      },
	      multiplyScalar: function(a) {
	         var b = this.elements;
	         b[0] *= a;
	         b[3] *= a;
	         b[6] *= a;
	         b[1] *= a;
	         b[4] *= a;
	         b[7] *= a;
	         b[2] *= a;
	         b[5] *= a;
	         b[8] *= a;
	         return this
	      },
	      determinant: function() {
	         var a = this.elements,
	            b = a[0],
	            c = a[1],
	            d = a[2],
	            e = a[3],
	            f = a[4],
	            g = a[5],
	            h = a[6],
	            k = a[7],
	            a = a[8];
	         return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h
	      },
	      getInverse: function(a, b) {
	         a && a.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
	         var c = a.elements,
	            d = this.elements,
	            e = c[0],
	            f = c[1],
	            g = c[2],
	            h = c[3],
	            k = c[4],
	            m = c[5],
	            l = c[6],
	            q = c[7],
	            c = c[8],
	            n = c * k - m * q,
	            r = m * l - c * h,
	            p = q * h - k * l,
	            t = e * n + f * r + g * p;
	         if (0 === t) {
	            if (!0 === b) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
	            console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
	            return this.identity()
	         }
	         t = 1 / t;
	         d[0] = n * t;
	         d[1] = (g * q - c * f) * t;
	         d[2] = (m * f - g * k) * t;
	         d[3] = r * t;
	         d[4] = (c * e - g * l) * t;
	         d[5] = (g * h - m * e) * t;
	         d[6] = p * t;
	         d[7] = (f * l - q * e) * t;
	         d[8] = (k * e - f * h) * t;
	         return this
	      },
	      transpose: function() {
	         var a, b = this.elements;
	         a = b[1];
	         b[1] = b[3];
	         b[3] = a;
	         a = b[2];
	         b[2] = b[6];
	         b[6] = a;
	         a = b[5];
	         b[5] = b[7];
	         b[7] = a;
	         return this
	      },
	      getNormalMatrix: function(a) {
	         return this.setFromMatrix4(a).getInverse(this).transpose()
	      },
	      transposeIntoArray: function(a) {
	         var b = this.elements;
	         a[0] = b[0];
	         a[1] = b[3];
	         a[2] = b[6];
	         a[3] = b[1];
	         a[4] = b[4];
	         a[5] = b[7];
	         a[6] = b[2];
	         a[7] = b[5];
	         a[8] = b[8];
	         return this
	      },
	      equals: function(a) {
	         var b = this.elements;
	         a = a.elements;
	         for (var c = 0; 9 > c; c++) if (b[c] !== a[c]) return !1;
	         return !0
	      },
	      fromArray: function(a, b) {
	         void 0 === b && (b = 0);
	         for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         var c = this.elements;
	         a[b] = c[0];
	         a[b + 1] = c[1];
	         a[b + 2] = c[2];
	         a[b + 3] = c[3];
	         a[b + 4] = c[4];
	         a[b + 5] = c[5];
	         a[b + 6] = c[6];
	         a[b + 7] = c[7];
	         a[b + 8] = c[8];
	         return a
	      }
	   });
	   Object.assign(wa.prototype, {
	      set: function(a, b) {
	         this.normal.copy(a);
	         this.constant = b;
	         return this
	      },
	      setComponents: function(a, b, c, d) {
	         this.normal.set(a, b, c);
	         this.constant = d;
	         return this
	      },
	      setFromNormalAndCoplanarPoint: function(a, b) {
	         this.normal.copy(a);
	         this.constant = -b.dot(this.normal);
	         return this
	      },
	      setFromCoplanarPoints: function() {
	         var a = new p,
	            b = new p;
	         return function(c, d, e) {
	            d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
	            this.setFromNormalAndCoplanarPoint(d, c);
	            return this
	         }
	      }(),
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.normal.copy(a.normal);
	         this.constant = a.constant;
	         return this
	      },
	      normalize: function() {
	         var a = 1 / this.normal.length();
	         this.normal.multiplyScalar(a);
	         this.constant *= a;
	         return this
	      },
	      negate: function() {
	         this.constant *= -1;
	         this.normal.negate();
	         return this
	      },
	      distanceToPoint: function(a) {
	         return this.normal.dot(a) + this.constant
	      },
	      distanceToSphere: function(a) {
	         return this.distanceToPoint(a.center) - a.radius
	      },
	      projectPoint: function(a, b) {
	         return this.orthoPoint(a, b).sub(a).negate()
	      },
	      orthoPoint: function(a, b) {
	         var c = this.distanceToPoint(a);
	         return (b || new p).copy(this.normal).multiplyScalar(c)
	      },
	      intersectLine: function() {
	         var a = new p;
	         return function(b, c) {
	            var d = c || new p,
	               e = b.delta(a),
	               f = this.normal.dot(e);
	            if (0 === f) {
	               if (0 === this.distanceToPoint(b.start)) return d.copy(b.start)
	            } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)
	         }
	      }(),
	      intersectsLine: function(a) {
	         var b = this.distanceToPoint(a.start);
	         a = this.distanceToPoint(a.end);
	         return 0 > b && 0 < a || 0 > a && 0 < b
	      },
	      intersectsBox: function(a) {
	         return a.intersectsPlane(this)
	      },
	      intersectsSphere: function(a) {
	         return a.intersectsPlane(this)
	      },
	      coplanarPoint: function(a) {
	         return (a || new p).copy(this.normal).multiplyScalar(-this.constant)
	      },
	      applyMatrix4: function() {
	         var a = new p,
	            b = new Ka;
	         return function(c, d) {
	            var e = this.coplanarPoint(a).applyMatrix4(c),
	               f = d || b.getNormalMatrix(c),
	               f = this.normal.applyMatrix3(f).normalize();
	            this.constant = -e.dot(f);
	            return this
	         }
	      }(),
	      translate: function(a) {
	         this.constant -= a.dot(this.normal);
	         return this
	      },
	      equals: function(a) {
	         return a.normal.equals(this.normal) && a.constant === this.constant
	      }
	   });
	   Object.assign(jd.prototype, {
	      set: function(a, b, c, d, e, f) {
	         var g = this.planes;
	         g[0].copy(a);
	         g[1].copy(b);
	         g[2].copy(c);
	         g[3].copy(d);
	         g[4].copy(e);
	         g[5].copy(f);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
	         return this
	      },
	      setFromMatrix: function(a) {
	         var b = this.planes,
	            c = a.elements;
	         a = c[0];
	         var d = c[1],
	            e = c[2],
	            f = c[3],
	            g = c[4],
	            h = c[5],
	            k = c[6],
	            m = c[7],
	            l = c[8],
	            q = c[9],
	            n = c[10],
	            r = c[11],
	            p = c[12],
	            t = c[13],
	            y = c[14],
	            c = c[15];
	         b[0].setComponents(f - a, m - g, r - l, c - p).normalize();
	         b[1].setComponents(f + a, m + g, r + l, c + p).normalize();
	         b[2].setComponents(f + d, m + h, r + q, c + t).normalize();
	         b[3].setComponents(f - d, m - h, r - q, c - t).normalize();
	         b[4].setComponents(f - e, m - k, r - n, c - y).normalize();
	         b[5].setComponents(f + e, m + k, r + n, c + y).normalize();
	         return this
	      },
	      intersectsObject: function() {
	         var a = new Ga;
	         return function(b) {
	            var c = b.geometry;
	            null === c.boundingSphere && c.computeBoundingSphere();
	            a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);
	            return this.intersectsSphere(a)
	         }
	      }(),
	      intersectsSprite: function() {
	         var a = new Ga;
	         return function(b) {
	            a.center.set(0, 0, 0);
	            a.radius = .7071067811865476;
	            a.applyMatrix4(b.matrixWorld);
	            return this.intersectsSphere(a)
	         }
	      }(),
	      intersectsSphere: function(a) {
	         var b = this.planes,
	            c = a.center;
	         a = -a.radius;
	         for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;
	         return !0
	      },
	      intersectsBox: function() {
	         var a = new p,
	            b = new p;
	         return function(c) {
	            for (var d = this.planes, e = 0; 6 > e; e++) {
	               var f = d[e];
	               a.x = 0 < f.normal.x ? c.min.x : c.max.x;
	               b.x = 0 < f.normal.x ? c.max.x : c.min.x;
	               a.y = 0 < f.normal.y ? c.min.y : c.max.y;
	               b.y = 0 < f.normal.y ? c.max.y : c.min.y;
	               a.z = 0 < f.normal.z ? c.min.z : c.max.z;
	               b.z = 0 < f.normal.z ? c.max.z : c.min.z;
	               var g = f.distanceToPoint(a),
	                  f = f.distanceToPoint(b);
	               if (0 > g && 0 > f) return !1
	            }
	            return !0
	         }
	      }(),
	      containsPoint: function(a) {
	         for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return !1;
	         return !0
	      }
	   });
	   Object.assign(hb.prototype, {
	      set: function(a, b) {
	         this.origin.copy(a);
	         this.direction.copy(b);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.origin.copy(a.origin);
	         this.direction.copy(a.direction);
	         return this
	      },
	      at: function(a, b) {
	         return (b || new p).copy(this.direction).multiplyScalar(a).add(this.origin)
	      },
	      lookAt: function(a) {
	         this.direction.copy(a).sub(this.origin).normalize();
	         return this
	      },
	      recast: function() {
	         var a = new p;
	         return function(b) {
	            this.origin.copy(this.at(b, a));
	            return this
	         }
	      }(),
	      closestPointToPoint: function(a, b) {
	         var c = b || new p;
	         c.subVectors(a, this.origin);
	         var d = c.dot(this.direction);
	         return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
	      },
	      distanceToPoint: function(a) {
	         return Math.sqrt(this.distanceSqToPoint(a))
	      },
	      distanceSqToPoint: function() {
	         var a = new p;
	         return function(b) {
	            var c = a.subVectors(b, this.origin).dot(this.direction);
	            if (0 > c) return this.origin.distanceToSquared(b);
	            a.copy(this.direction).multiplyScalar(c).add(this.origin);
	            return a.distanceToSquared(b)
	         }
	      }(),
	      distanceSqToSegment: function() {
	         var a = new p,
	            b = new p,
	            c = new p;
	         return function(d, e, f, g) {
	            a.copy(d).add(e).multiplyScalar(.5);
	            b.copy(e).sub(d).normalize();
	            c.copy(this.origin).sub(a);
	            var h = .5 * d.distanceTo(e),
	               k = -this.direction.dot(b),
	               m = c.dot(this.direction),
	               l = -c.dot(b),
	               q = c.lengthSq(),
	               n = Math.abs(1 - k * k),
	               r;
	            0 < n ? (d = k * l - m, e = k * m - l, r = h * n, 0 <= d ? e >= -r ? e <= r ? (h = 1 / n, d *= h, e *= h, k = d * (d + k * e + 2 * m) + e * (k * d + e + 2 * l) + q) : (e = h, d = Math.max(0, -(k * e + m)), k = -d * d + e * (e + 2 * l) + q) : (e = -h, d = Math.max(0, -(k * e + m)), k = -d * d + e * (e + 2 * l) + q) : e <= -r ? (d = Math.max(0, -(-k * h + m)), e = 0 < d ? -h : Math.min(Math.max(-h, -l), h), k = -d * d + e * (e + 2 * l) + q) : e <= r ? (d = 0, e = Math.min(Math.max(-h, -l), h), k = e * (e + 2 * l) + q) : (d = Math.max(0, -(k * h + m)), e = 0 < d ? h : Math.min(Math.max(-h, -l), h), k = -d * d + e * (e + 2 * l) + q)) : (e = 0 < k ? -h : h, d = Math.max(0, -(k * e + m)), k = -d * d + e * (e + 2 * l) + q);
	            f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
	            g && g.copy(b).multiplyScalar(e).add(a);
	            return k
	         }
	      }(),
	      intersectSphere: function() {
	         var a = new p;
	         return function(b, c) {
	            a.subVectors(b.center, this.origin);
	            var d = a.dot(this.direction),
	               e = a.dot(a) - d * d,
	               f = b.radius * b.radius;
	            if (e > f) return null;
	            f = Math.sqrt(f - e);
	            e = d - f;
	            d += f;
	            return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
	         }
	      }(),
	      intersectsSphere: function(a) {
	         return this.distanceToPoint(a.center) <= a.radius
	      },
	      distanceToPlane: function(a) {
	         var b = a.normal.dot(this.direction);
	         if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
	         a = -(this.origin.dot(a.normal) + a.constant) / b;
	         return 0 <= a ? a : null
	      },
	      intersectPlane: function(a, b) {
	         var c = this.distanceToPlane(a);
	         return null === c ? null : this.at(c, b)
	      },
	      intersectsPlane: function(a) {
	         var b = a.distanceToPoint(this.origin);
	         return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
	      },
	      intersectBox: function(a, b) {
	         var c, d, e, f, g;
	         d = 1 / this.direction.x;
	         f = 1 / this.direction.y;
	         g = 1 / this.direction.z;
	         var h = this.origin;
	         0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
	         0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
	         if (c > f || e > d) return null;
	         if (e > c || c !== c) c = e;
	         if (f < d || d !== d) d = f;
	         0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
	         if (c > g || e > d) return null;
	         if (e > c || c !== c) c = e;
	         if (g < d || d !== d) d = g;
	         return 0 > d ? null : this.at(0 <= c ? c : d, b)
	      },
	      intersectsBox: function() {
	         var a = new p;
	         return function(b) {
	            return null !== this.intersectBox(b, a)
	         }
	      }(),
	      intersectTriangle: function() {
	         var a = new p,
	            b = new p,
	            c = new p,
	            d = new p;
	         return function(e, f, g, h, k) {
	            b.subVectors(f, e);
	            c.subVectors(g, e);
	            d.crossVectors(b, c);
	            f = this.direction.dot(d);
	            if (0 < f) {
	               if (h) return null;
	               h = 1
	            } else if (0 > f) h = -1, f = -f;
	            else return null;
	            a.subVectors(this.origin, e);
	            e = h * this.direction.dot(c.crossVectors(a, c));
	            if (0 > e) return null;
	            g = h * this.direction.dot(b.cross(a));
	            if (0 > g || e + g > f) return null;
	            e = -h * a.dot(d);
	            return 0 > e ? null : this.at(e / f, k)
	         }
	      }(),
	      applyMatrix4: function(a) {
	         this.direction.add(this.origin).applyMatrix4(a);
	         this.origin.applyMatrix4(a);
	         this.direction.sub(this.origin);
	         this.direction.normalize();
	         return this
	      },
	      equals: function(a) {
	         return a.origin.equals(this.origin) && a.direction.equals(this.direction)
	      }
	   });
	   bb.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
	   bb.DefaultOrder = "XYZ";
	   Object.defineProperties(bb.prototype, {
	      x: {
	         get: function() {
	            return this._x
	         },
	         set: function(a) {
	            this._x = a;
	            this.onChangeCallback()
	         }
	      },
	      y: {
	         get: function() {
	            return this._y
	         },
	         set: function(a) {
	            this._y = a;
	            this.onChangeCallback()
	         }
	      },
	      z: {
	         get: function() {
	            return this._z
	         },
	         set: function(a) {
	            this._z = a;
	            this.onChangeCallback()
	         }
	      },
	      order: {
	         get: function() {
	            return this._order
	         },
	         set: function(a) {
	            this._order = a;
	            this.onChangeCallback()
	         }
	      }
	   });
	   Object.assign(bb.prototype, {
	      isEuler: !0,
	      set: function(a, b, c, d) {
	         this._x = a;
	         this._y = b;
	         this._z = c;
	         this._order = d || this._order;
	         this.onChangeCallback();
	         return this
	      },
	      clone: function() {
	         return new this.constructor(this._x, this._y, this._z, this._order)
	      },
	      copy: function(a) {
	         this._x = a._x;
	         this._y = a._y;
	         this._z = a._z;
	         this._order = a._order;
	         this.onChangeCallback();
	         return this
	      },
	      setFromRotationMatrix: function(a, b, c) {
	         var d = Y.clamp,
	            e = a.elements;
	         a = e[0];
	         var f = e[4],
	            g = e[8],
	            h = e[1],
	            k = e[5],
	            m = e[9],
	            l = e[2],
	            q = e[6],
	            e = e[10];
	         b = b || this._order;
	         "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-m, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(q, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-l, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(-l, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(q, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-m, k), this._y = Math.atan2(-l, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
	         this._order = b;
	         if (!1 !== c) this.onChangeCallback();
	         return this
	      },
	      setFromQuaternion: function() {
	         var a = new J;
	         return function(b, c, d) {
	            a.makeRotationFromQuaternion(b);
	            return this.setFromRotationMatrix(a, c, d)
	         }
	      }(),
	      setFromVector3: function(a, b) {
	         return this.set(a.x, a.y, a.z, b || this._order)
	      },
	      reorder: function() {
	         var a = new qa;
	         return function(b) {
	            a.setFromEuler(this);
	            return this.setFromQuaternion(a, b)
	         }
	      }(),
	      equals: function(a) {
	         return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
	      },
	      fromArray: function(a) {
	         this._x = a[0];
	         this._y = a[1];
	         this._z = a[2];
	         void 0 !== a[3] && (this._order = a[3]);
	         this.onChangeCallback();
	         return this
	      },
	      toArray: function(a, b) {
	         void 0 === a && (a = []);
	         void 0 === b && (b = 0);
	         a[b] = this._x;
	         a[b + 1] = this._y;
	         a[b + 2] = this._z;
	         a[b + 3] = this._order;
	         return a
	      },
	      toVector3: function(a) {
	         return a ? a.set(this._x, this._y, this._z) : new p(this._x, this._y, this._z)
	      },
	      onChange: function(a) {
	         this.onChangeCallback = a;
	         return this
	      },
	      onChangeCallback: function() {}
	   });
	   Object.assign(Rd.prototype, {
	      set: function(a) {
	         this.mask = 1 << a | 0
	      },
	      enable: function(a) {
	         this.mask = this.mask | 1 << a | 0
	      },
	      toggle: function(a) {
	         this.mask ^= 1 << a | 0
	      },
	      disable: function(a) {
	         this.mask &= ~ (1 << a | 0)
	      },
	      test: function(a) {
	         return 0 !== (this.mask & a.mask)
	      }
	   });
	   var Lf = 0;
	   B.DefaultUp = new p(0, 1, 0);
	   B.DefaultMatrixAutoUpdate = !0;
	   Object.assign(B.prototype, sa.prototype, {
	      isObject3D: !0,
	      applyMatrix: function(a) {
	         this.matrix.multiplyMatrices(a, this.matrix);
	         this.matrix.decompose(this.position, this.quaternion, this.scale)
	      },
	      setRotationFromAxisAngle: function(a, b) {
	         this.quaternion.setFromAxisAngle(a, b)
	      },
	      setRotationFromEuler: function(a) {
	         this.quaternion.setFromEuler(a, !0)
	      },
	      setRotationFromMatrix: function(a) {
	         this.quaternion.setFromRotationMatrix(a)
	      },
	      setRotationFromQuaternion: function(a) {
	         this.quaternion.copy(a)
	      },
	      rotateOnAxis: function() {
	         var a = new qa;
	         return function(b, c) {
	            a.setFromAxisAngle(b, c);
	            this.quaternion.multiply(a);
	            return this
	         }
	      }(),
	      rotateX: function() {
	         var a = new p(1, 0, 0);
	         return function(b) {
	            return this.rotateOnAxis(a, b)
	         }
	      }(),
	      rotateY: function() {
	         var a = new p(0, 1, 0);
	         return function(b) {
	            return this.rotateOnAxis(a, b)
	         }
	      }(),
	      rotateZ: function() {
	         var a = new p(0, 0, 1);
	         return function(b) {
	            return this.rotateOnAxis(a, b)
	         }
	      }(),
	      translateOnAxis: function() {
	         var a = new p;
	         return function(b, c) {
	            a.copy(b).applyQuaternion(this.quaternion);
	            this.position.add(a.multiplyScalar(c));
	            return this
	         }
	      }(),
	      translateX: function() {
	         var a = new p(1, 0, 0);
	         return function(b) {
	            return this.translateOnAxis(a, b)
	         }
	      }(),
	      translateY: function() {
	         var a = new p(0, 1, 0);
	         return function(b) {
	            return this.translateOnAxis(a, b)
	         }
	      }(),
	      translateZ: function() {
	         var a = new p(0, 0, 1);
	         return function(b) {
	            return this.translateOnAxis(a, b)
	         }
	      }(),
	      localToWorld: function(a) {
	         return a.applyMatrix4(this.matrixWorld)
	      },
	      worldToLocal: function() {
	         var a = new J;
	         return function(b) {
	            return b.applyMatrix4(a.getInverse(this.matrixWorld))
	         }
	      }(),
	      lookAt: function() {
	         var a = new J;
	         return function(b) {
	            this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up);
	            this.quaternion.setFromRotationMatrix(a)
	         }
	      }(),
	      add: function(a) {
	         if (1 < arguments.length) {
	            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
	            return this
	         }
	         if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
	         a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
	            type: "added"
	         }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
	         return this
	      },
	      remove: function(a) {
	         if (1 < arguments.length) for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
	         b = this.children.indexOf(a); - 1 !== b && (a.parent = null, a.dispatchEvent({
	            type: "removed"
	         }), this.children.splice(b, 1))
	      },
	      getObjectById: function(a) {
	         return this.getObjectByProperty("id", a)
	      },
	      getObjectByName: function(a) {
	         return this.getObjectByProperty("name", a)
	      },
	      getObjectByProperty: function(a, b) {
	         if (this[a] === b) return this;
	         for (var c = 0, d = this.children.length; c < d; c++) {
	            var e = this.children[c].getObjectByProperty(a, b);
	            if (void 0 !== e) return e
	         }
	      },
	      getWorldPosition: function(a) {
	         a = a || new p;
	         this.updateMatrixWorld(!0);
	         return a.setFromMatrixPosition(this.matrixWorld)
	      },
	      getWorldQuaternion: function() {
	         var a = new p,
	            b = new p;
	         return function(c) {
	            c = c || new qa;
	            this.updateMatrixWorld(!0);
	            this.matrixWorld.decompose(a, c, b);
	            return c
	         }
	      }(),
	      getWorldRotation: function() {
	         var a = new qa;
	         return function(b) {
	            b = b || new bb;
	            this.getWorldQuaternion(a);
	            return b.setFromQuaternion(a, this.rotation.order, !1)
	         }
	      }(),
	      getWorldScale: function() {
	         var a = new p,
	            b = new qa;
	         return function(c) {
	            c = c || new p;
	            this.updateMatrixWorld(!0);
	            this.matrixWorld.decompose(a, b, c);
	            return c
	         }
	      }(),
	      getWorldDirection: function() {
	         var a = new qa;
	         return function(b) {
	            b = b || new p;
	            this.getWorldQuaternion(a);
	            return b.set(0, 0, 1).applyQuaternion(a)
	         }
	      }(),
	      raycast: function() {},
	      traverse: function(a) {
	         a(this);
	         for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
	      },
	      traverseVisible: function(a) {
	         if (!1 !== this.visible) {
	            a(this);
	            for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
	         }
	      },
	      traverseAncestors: function(a) {
	         var b = this.parent;
	         null !== b && (a(b), b.traverseAncestors(a))
	      },
	      updateMatrix: function() {
	         this.matrix.compose(this.position, this.quaternion, this.scale);
	         this.matrixWorldNeedsUpdate = !0
	      },
	      updateMatrixWorld: function(a) {
	         this.matrixAutoUpdate && this.updateMatrix();
	         if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
	         for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
	      },
	      toJSON: function(a) {
	         function b(b, c) {
	            void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
	            return c.uuid
	         }
	         function c(a) {
	            var b = [],
	               c;
	            for (c in a) {
	               var d = a[c];
	               delete d.metadata;
	               b.push(d)
	            }
	            return b
	         }
	         var d = void 0 === a || "" === a,
	            e = {};
	         d && (a = {
	            geometries: {},
	            materials: {},
	            textures: {},
	            images: {}
	         }, e.metadata = {
	            version: 4.5,
	            type: "Object",
	            generator: "Object3D.toJSON"
	         });
	         var f = {};
	         f.uuid = this.uuid;
	         f.type = this.type;
	         "" !== this.name && (f.name = this.name);
	         "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
	         !0 === this.castShadow && (f.castShadow = !0);
	         !0 === this.receiveShadow && (f.receiveShadow = !0);
	         !1 === this.visible && (f.visible = !1);
	         f.matrix = this.matrix.toArray();
	         void 0 !== this.geometry && (f.geometry = b(a.geometries, this.geometry));
	         if (void 0 !== this.material) if (Array.isArray(this.material)) {
	            for (var g = [], h = 0, k = this.material.length; h < k; h++) g.push(b(a.materials, this.material[h]));
	            f.material = g
	         } else f.material = b(a.materials, this.material);
	         if (0 < this.children.length) for (f.children = [], h = 0; h < this.children.length; h++) f.children.push(this.children[h].toJSON(a).object);
	         d && (d = c(a.geometries), g = c(a.materials), h = c(a.textures), k = c(a.images), 0 < d.length && (e.geometries = d), 0 < g.length && (e.materials = g), 0 < h.length && (e.textures = h), 0 < k.length && (e.images = k));
	         e.object = f;
	         return e
	      },
	      clone: function(a) {
	         return (new this.constructor).copy(this, a)
	      },
	      copy: function(a, b) {
	         void 0 === b && (b = !0);
	         this.name = a.name;
	         this.up.copy(a.up);
	         this.position.copy(a.position);
	         this.quaternion.copy(a.quaternion);
	         this.scale.copy(a.scale);
	         this.matrix.copy(a.matrix);
	         this.matrixWorld.copy(a.matrixWorld);
	         this.matrixAutoUpdate = a.matrixAutoUpdate;
	         this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
	         this.layers.mask = a.layers.mask;
	         this.visible = a.visible;
	         this.castShadow = a.castShadow;
	         this.receiveShadow = a.receiveShadow;
	         this.frustumCulled = a.frustumCulled;
	         this.renderOrder = a.renderOrder;
	         this.userData = JSON.parse(JSON.stringify(a.userData));
	         if (!0 === b) for (var c = 0; c < a.children.length; c++) this.add(a.children[c].clone());
	         return this
	      }
	   });
	   Object.assign(Hb.prototype, {
	      set: function(a, b) {
	         this.start.copy(a);
	         this.end.copy(b);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.start.copy(a.start);
	         this.end.copy(a.end);
	         return this
	      },
	      getCenter: function(a) {
	         return (a || new p).addVectors(this.start, this.end).multiplyScalar(.5)
	      },
	      delta: function(a) {
	         return (a || new p).subVectors(this.end, this.start)
	      },
	      distanceSq: function() {
	         return this.start.distanceToSquared(this.end)
	      },
	      distance: function() {
	         return this.start.distanceTo(this.end)
	      },
	      at: function(a, b) {
	         var c = b || new p;
	         return this.delta(c).multiplyScalar(a).add(this.start)
	      },
	      closestPointToPointParameter: function() {
	         var a = new p,
	            b = new p;
	         return function(c, d) {
	            a.subVectors(c, this.start);
	            b.subVectors(this.end, this.start);
	            var e = b.dot(b),
	               e = b.dot(a) / e;
	            d && (e = Y.clamp(e, 0, 1));
	            return e
	         }
	      }(),
	      closestPointToPoint: function(a, b, c) {
	         a = this.closestPointToPointParameter(a, b);
	         c = c || new p;
	         return this.delta(c).multiplyScalar(a).add(this.start)
	      },
	      applyMatrix4: function(a) {
	         this.start.applyMatrix4(a);
	         this.end.applyMatrix4(a);
	         return this
	      },
	      equals: function(a) {
	         return a.start.equals(this.start) && a.end.equals(this.end)
	      }
	   });
	   Object.assign(Ua, {
	      normal: function() {
	         var a = new p;
	         return function(b, c, d, e) {
	            e = e || new p;
	            e.subVectors(d, c);
	            a.subVectors(b, c);
	            e.cross(a);
	            b = e.lengthSq();
	            return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
	         }
	      }(),
	      barycoordFromPoint: function() {
	         var a = new p,
	            b = new p,
	            c = new p;
	         return function(d, e, f, g, h) {
	            a.subVectors(g, e);
	            b.subVectors(f, e);
	            c.subVectors(d, e);
	            d = a.dot(a);
	            e = a.dot(b);
	            f = a.dot(c);
	            var k = b.dot(b);
	            g = b.dot(c);
	            var m = d * k - e * e;
	            h = h || new p;
	            if (0 === m) return h.set(-2, -1, -1);
	            m = 1 / m;
	            k = (k * f - e * g) * m;
	            d = (d * g - e * f) * m;
	            return h.set(1 - k - d, d, k)
	         }
	      }(),
	      containsPoint: function() {
	         var a = new p;
	         return function(b, c, d, e) {
	            b = Ua.barycoordFromPoint(b, c, d, e, a);
	            return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
	         }
	      }()
	   });
	   Object.assign(Ua.prototype, {
	      set: function(a, b, c) {
	         this.a.copy(a);
	         this.b.copy(b);
	         this.c.copy(c);
	         return this
	      },
	      setFromPointsAndIndices: function(a, b, c, d) {
	         this.a.copy(a[b]);
	         this.b.copy(a[c]);
	         this.c.copy(a[d]);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.a.copy(a.a);
	         this.b.copy(a.b);
	         this.c.copy(a.c);
	         return this
	      },
	      area: function() {
	         var a = new p,
	            b = new p;
	         return function() {
	            a.subVectors(this.c, this.b);
	            b.subVectors(this.a, this.b);
	            return .5 * a.cross(b).length()
	         }
	      }(),
	      midpoint: function(a) {
	         return (a || new p).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
	      },
	      normal: function(a) {
	         return Ua.normal(this.a, this.b, this.c, a)
	      },
	      plane: function(a) {
	         return (a || new wa).setFromCoplanarPoints(this.a, this.b, this.c)
	      },
	      barycoordFromPoint: function(a, b) {
	         return Ua.barycoordFromPoint(a, this.a, this.b, this.c, b)
	      },
	      containsPoint: function(a) {
	         return Ua.containsPoint(a, this.a, this.b, this.c)
	      },
	      closestPointToPoint: function() {
	         var a = new wa,
	            b = [new Hb, new Hb, new Hb],
	            c = new p,
	            d = new p;
	         return function(e, f) {
	            var g = f || new p,
	               h = Infinity;
	            a.setFromCoplanarPoints(this.a, this.b, this.c);
	            a.projectPoint(e, c);
	            if (!0 === this.containsPoint(c)) g.copy(c);
	            else {
	               b[0].set(this.a, this.b);
	               b[1].set(this.b, this.c);
	               b[2].set(this.c, this.a);
	               for (var k = 0; k < b.length; k++) {
	                  b[k].closestPointToPoint(c, !0, d);
	                  var m = c.distanceToSquared(d);
	                  m < h && (h = m, g.copy(d))
	               }
	            }
	            return g
	         }
	      }(),
	      equals: function(a) {
	         return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
	      }
	   });
	   Object.assign(Va.prototype, {
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.a = a.a;
	         this.b = a.b;
	         this.c = a.c;
	         this.normal.copy(a.normal);
	         this.color.copy(a.color);
	         this.materialIndex = a.materialIndex;
	         for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
	         b = 0;
	         for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
	         return this
	      }
	   });
	   Na.prototype = Object.create(Z.prototype);
	   Na.prototype.constructor = Na;
	   Na.prototype.isMeshBasicMaterial = !0;
	   Na.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.map = a.map;
	      this.lightMap = a.lightMap;
	      this.lightMapIntensity = a.lightMapIntensity;
	      this.aoMap = a.aoMap;
	      this.aoMapIntensity = a.aoMapIntensity;
	      this.specularMap = a.specularMap;
	      this.alphaMap = a.alphaMap;
	      this.envMap = a.envMap;
	      this.combine = a.combine;
	      this.reflectivity = a.reflectivity;
	      this.refractionRatio = a.refractionRatio;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      this.wireframeLinecap = a.wireframeLinecap;
	      this.wireframeLinejoin = a.wireframeLinejoin;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      return this
	   };
	   Object.defineProperty(L.prototype, "needsUpdate", {
	      set: function(a) {
	         !0 === a && this.version++
	      }
	   });
	   Object.assign(L.prototype, {
	      isBufferAttribute: !0,
	      setArray: function(a) {
	         if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
	         this.count = void 0 !== a ? a.length / this.itemSize : 0;
	         this.array = a
	      },
	      setDynamic: function(a) {
	         this.dynamic = a;
	         return this
	      },
	      copy: function(a) {
	         this.array = new a.array.constructor(a.array);
	         this.itemSize = a.itemSize;
	         this.count = a.count;
	         this.normalized = a.normalized;
	         this.dynamic = a.dynamic;
	         return this
	      },
	      copyAt: function(a, b, c) {
	         a *= this.itemSize;
	         c *= b.itemSize;
	         for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
	         return this
	      },
	      copyArray: function(a) {
	         this.array.set(a);
	         return this
	      },
	      copyColorsArray: function(a) {
	         for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
	            var f = a[d];
	            void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new H);
	            b[c++] = f.r;
	            b[c++] = f.g;
	            b[c++] = f.b
	         }
	         return this
	      },
	      copyIndicesArray: function(a) {
	         for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
	            var f = a[d];
	            b[c++] = f.a;
	            b[c++] = f.b;
	            b[c++] = f.c
	         }
	         return this
	      },
	      copyVector2sArray: function(a) {
	         for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
	            var f = a[d];
	            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new D);
	            b[c++] = f.x;
	            b[c++] = f.y
	         }
	         return this
	      },
	      copyVector3sArray: function(a) {
	         for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
	            var f = a[d];
	            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new p);
	            b[c++] = f.x;
	            b[c++] = f.y;
	            b[c++] = f.z
	         }
	         return this
	      },
	      copyVector4sArray: function(a) {
	         for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
	            var f = a[d];
	            void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new ga);
	            b[c++] = f.x;
	            b[c++] = f.y;
	            b[c++] = f.z;
	            b[c++] = f.w
	         }
	         return this
	      },
	      set: function(a, b) {
	         void 0 === b && (b = 0);
	         this.array.set(a, b);
	         return this
	      },
	      getX: function(a) {
	         return this.array[a * this.itemSize]
	      },
	      setX: function(a, b) {
	         this.array[a * this.itemSize] = b;
	         return this
	      },
	      getY: function(a) {
	         return this.array[a * this.itemSize + 1]
	      },
	      setY: function(a, b) {
	         this.array[a * this.itemSize + 1] = b;
	         return this
	      },
	      getZ: function(a) {
	         return this.array[a * this.itemSize + 2]
	      },
	      setZ: function(a, b) {
	         this.array[a * this.itemSize + 2] = b;
	         return this
	      },
	      getW: function(a) {
	         return this.array[a * this.itemSize + 3]
	      },
	      setW: function(a, b) {
	         this.array[a * this.itemSize + 3] = b;
	         return this
	      },
	      setXY: function(a, b, c) {
	         a *= this.itemSize;
	         this.array[a + 0] = b;
	         this.array[a + 1] = c;
	         return this
	      },
	      setXYZ: function(a, b, c, d) {
	         a *= this.itemSize;
	         this.array[a + 0] = b;
	         this.array[a + 1] = c;
	         this.array[a + 2] = d;
	         return this
	      },
	      setXYZW: function(a, b, c, d, e) {
	         a *= this.itemSize;
	         this.array[a + 0] = b;
	         this.array[a + 1] = c;
	         this.array[a + 2] = d;
	         this.array[a + 3] = e;
	         return this
	      },
	      onUpload: function(a) {
	         this.onUploadCallback = a;
	         return this
	      },
	      clone: function() {
	         return new this.constructor(this.array, this.itemSize).copy(this)
	      }
	   });
	   rc.prototype = Object.create(L.prototype);
	   rc.prototype.constructor = rc;
	   sc.prototype = Object.create(L.prototype);
	   sc.prototype.constructor = sc;
	   tc.prototype = Object.create(L.prototype);
	   tc.prototype.constructor = tc;
	   uc.prototype = Object.create(L.prototype);
	   uc.prototype.constructor = uc;
	   ib.prototype = Object.create(L.prototype);
	   ib.prototype.constructor = ib;
	   vc.prototype = Object.create(L.prototype);
	   vc.prototype.constructor = vc;
	   jb.prototype = Object.create(L.prototype);
	   jb.prototype.constructor = jb;
	   C.prototype = Object.create(L.prototype);
	   C.prototype.constructor = C;
	   wc.prototype = Object.create(L.prototype);
	   wc.prototype.constructor = wc;
	   Object.assign(Ke.prototype, {
	      computeGroups: function(a) {
	         var b, c = [],
	            d = void 0;
	         a = a.faces;
	         for (var e = 0; e < a.length; e++) {
	            var f = a[e];
	            f.materialIndex !== d && (d = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), b = {
	               start: 3 * e,
	               materialIndex: d
	            })
	         }
	         void 0 !== b && (b.count = 3 * e - b.start, c.push(b));
	         this.groups = c
	      },
	      fromGeometry: function(a) {
	         var b = a.faces,
	            c = a.vertices,
	            d = a.faceVertexUvs,
	            e = d[0] && 0 < d[0].length,
	            f = d[1] && 0 < d[1].length,
	            g = a.morphTargets,
	            h = g.length,
	            k;
	         if (0 < h) {
	            k = [];
	            for (var m = 0; m < h; m++) k[m] = [];
	            this.morphTargets.position = k
	         }
	         var l = a.morphNormals,
	            q = l.length,
	            n;
	         if (0 < q) {
	            n = [];
	            for (m = 0; m < q; m++) n[m] = [];
	            this.morphTargets.normal = n
	         }
	         for (var r = a.skinIndices, p = a.skinWeights, t = r.length === c.length, y = p.length === c.length, m = 0; m < b.length; m++) {
	            var x = b[m];
	            this.vertices.push(c[x.a], c[x.b], c[x.c]);
	            var v = x.vertexNormals;
	            3 === v.length ? this.normals.push(v[0], v[1], v[2]) : (v = x.normal, this.normals.push(v, v, v));
	            v = x.vertexColors;
	            3 === v.length ? this.colors.push(v[0], v[1], v[2]) : (v = x.color, this.colors.push(v, v, v));
	            !0 === e && (v = d[0][m], void 0 !== v ? this.uvs.push(v[0], v[1], v[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", m), this.uvs.push(new D, new D, new D)));
	            !0 === f && (v = d[1][m], void 0 !== v ? this.uvs2.push(v[0], v[1], v[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", m), this.uvs2.push(new D, new D, new D)));
	            for (v = 0; v < h; v++) {
	               var G = g[v].vertices;
	               k[v].push(G[x.a], G[x.b], G[x.c])
	            }
	            for (v = 0; v < q; v++) G = l[v].vertexNormals[m], n[v].push(G.a, G.b, G.c);
	            t && this.skinIndices.push(r[x.a], r[x.b], r[x.c]);
	            y && this.skinWeights.push(p[x.a], p[x.b], p[x.c])
	         }
	         this.computeGroups(a);
	         this.verticesNeedUpdate = a.verticesNeedUpdate;
	         this.normalsNeedUpdate = a.normalsNeedUpdate;
	         this.colorsNeedUpdate = a.colorsNeedUpdate;
	         this.uvsNeedUpdate = a.uvsNeedUpdate;
	         this.groupsNeedUpdate = a.groupsNeedUpdate;
	         return this
	      }
	   });
	   var Td = 0;
	   Object.assign(M.prototype, sa.prototype, {
	      isGeometry: !0,
	      applyMatrix: function(a) {
	         for (var b = (new Ka).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
	         c = 0;
	         for (d = this.faces.length; c < d; c++) {
	            a = this.faces[c];
	            a.normal.applyMatrix3(b).normalize();
	            for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
	         }
	         null !== this.boundingBox && this.computeBoundingBox();
	         null !== this.boundingSphere && this.computeBoundingSphere();
	         this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
	         return this
	      },
	      rotateX: function() {
	         var a = new J;
	         return function(b) {
	            a.makeRotationX(b);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      rotateY: function() {
	         var a = new J;
	         return function(b) {
	            a.makeRotationY(b);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      rotateZ: function() {
	         var a = new J;
	         return function(b) {
	            a.makeRotationZ(b);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      translate: function() {
	         var a = new J;
	         return function(b, c, d) {
	            a.makeTranslation(b, c, d);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      scale: function() {
	         var a = new J;
	         return function(b, c, d) {
	            a.makeScale(b, c, d);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      lookAt: function() {
	         var a = new B;
	         return function(b) {
	            a.lookAt(b);
	            a.updateMatrix();
	            this.applyMatrix(a.matrix)
	         }
	      }(),
	      fromBufferGeometry: function(a) {
	         function b(a, b, d, e) {
	            var f = void 0 !== g ? [l[a].clone(), l[b].clone(), l[d].clone()] : [],
	               r = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : [];
	            e = new Va(a, b, d, f, r, e);
	            c.faces.push(e);
	            void 0 !== k && c.faceVertexUvs[0].push([q[a].clone(), q[b].clone(), q[d].clone()]);
	            void 0 !== m && c.faceVertexUvs[1].push([n[a].clone(), n[b].clone(), n[d].clone()])
	         }
	         var c = this,
	            d = null !== a.index ? a.index.array : void 0,
	            e = a.attributes,
	            f = e.position.array,
	            g = void 0 !== e.normal ? e.normal.array : void 0,
	            h = void 0 !== e.color ? e.color.array : void 0,
	            k = void 0 !== e.uv ? e.uv.array : void 0,
	            m = void 0 !== e.uv2 ? e.uv2.array : void 0;
	         void 0 !== m && (this.faceVertexUvs[1] = []);
	         for (var l = [], q = [], n = [], r = e = 0; e < f.length; e += 3, r += 2) c.vertices.push(new p(f[e], f[e + 1], f[e + 2])), void 0 !== g && l.push(new p(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new H(h[e], h[e + 1], h[e + 2])), void 0 !== k && q.push(new D(k[r], k[r + 1])), void 0 !== m && n.push(new D(m[r], m[r + 1]));
	         var z = a.groups;
	         if (0 < z.length) for (e = 0; e < z.length; e++) for (var f = z[e], t = f.start, y = f.count, r = t, t = t + y; r < t; r += 3) void 0 !== d ? b(d[r], d[r + 1], d[r + 2], f.materialIndex) : b(r, r + 1, r + 2, f.materialIndex);
	         else if (void 0 !== d) for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
	         else for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
	         this.computeFaceNormals();
	         null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
	         null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
	         return this
	      },
	      center: function() {
	         this.computeBoundingBox();
	         var a = this.boundingBox.getCenter().negate();
	         this.translate(a.x, a.y, a.z);
	         return a
	      },
	      normalize: function() {
	         this.computeBoundingSphere();
	         var a = this.boundingSphere.center,
	            b = this.boundingSphere.radius,
	            b = 0 === b ? 1 : 1 / b,
	            c = new J;
	         c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
	         this.applyMatrix(c);
	         return this
	      },
	      computeFaceNormals: function() {
	         for (var a = new p, b = new p, c = 0, d = this.faces.length; c < d; c++) {
	            var e = this.faces[c],
	               f = this.vertices[e.a],
	               g = this.vertices[e.b];
	            a.subVectors(this.vertices[e.c], g);
	            b.subVectors(f, g);
	            a.cross(b);
	            a.normalize();
	            e.normal.copy(a)
	         }
	      },
	      computeVertexNormals: function(a) {
	         void 0 === a && (a = !0);
	         var b, c, d;
	         d = Array(this.vertices.length);
	         b = 0;
	         for (c = this.vertices.length; b < c; b++) d[b] = new p;
	         if (a) {
	            var e, f, g, h = new p,
	               k = new p;
	            a = 0;
	            for (b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
	         } else for (this.computeFaceNormals(), a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
	         b = 0;
	         for (c = this.vertices.length; b < c; b++) d[b].normalize();
	         a = 0;
	         for (b = this.faces.length; a < b; a++) c = this.faces[a], e = c.vertexNormals, 3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
	         0 < this.faces.length && (this.normalsNeedUpdate = !0)
	      },
	      computeFlatVertexNormals: function() {
	         var a, b, c;
	         this.computeFaceNormals();
	         a = 0;
	         for (b = this.faces.length; a < b; a++) {
	            c = this.faces[a];
	            var d = c.vertexNormals;
	            3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
	         }
	         0 < this.faces.length && (this.normalsNeedUpdate = !0)
	      },
	      computeMorphNormals: function() {
	         var a, b, c, d, e;
	         c = 0;
	         for (d = this.faces.length; c < d; c++) for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
	         var f = new M;
	         f.faces = this.faces;
	         a = 0;
	         for (b = this.morphTargets.length; a < b; a++) {
	            if (!this.morphNormals[a]) {
	               this.morphNormals[a] = {};
	               this.morphNormals[a].faceNormals = [];
	               this.morphNormals[a].vertexNormals = [];
	               e = this.morphNormals[a].faceNormals;
	               var g = this.morphNormals[a].vertexNormals,
	                  h, k;
	               c = 0;
	               for (d = this.faces.length; c < d; c++) h = new p, k = {
	                  a: new p,
	                  b: new p,
	                  c: new p
	               }, e.push(h), g.push(k)
	            }
	            g = this.morphNormals[a];
	            f.vertices = this.morphTargets[a].vertices;
	            f.computeFaceNormals();
	            f.computeVertexNormals();
	            c = 0;
	            for (d = this.faces.length; c < d; c++) e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2])
	         }
	         c = 0;
	         for (d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
	      },
	      computeLineDistances: function() {
	         for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
	      },
	      computeBoundingBox: function() {
	         null === this.boundingBox && (this.boundingBox = new Ta);
	         this.boundingBox.setFromPoints(this.vertices)
	      },
	      computeBoundingSphere: function() {
	         null === this.boundingSphere && (this.boundingSphere = new Ga);
	         this.boundingSphere.setFromPoints(this.vertices)
	      },
	      merge: function(a, b, c) {
	         if (!1 === (a && a.isGeometry)) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
	         else {
	            var d, e = this.vertices.length,
	               f = this.vertices,
	               g = a.vertices,
	               h = this.faces,
	               k = a.faces,
	               m = this.faceVertexUvs[0],
	               l = a.faceVertexUvs[0],
	               q = this.colors,
	               n = a.colors;
	            void 0 === c && (c = 0);
	            void 0 !== b && (d = (new Ka).getNormalMatrix(b));
	            a = 0;
	            for (var r = g.length; a < r; a++) {
	               var p = g[a].clone();
	               void 0 !== b && p.applyMatrix4(b);
	               f.push(p)
	            }
	            a = 0;
	            for (r = n.length; a < r; a++) q.push(n[a].clone());
	            a = 0;
	            for (r = k.length; a < r; a++) {
	               var g = k[a],
	                  t = g.vertexNormals,
	                  n = g.vertexColors,
	                  q = new Va(g.a + e, g.b + e, g.c + e);
	               q.normal.copy(g.normal);
	               void 0 !== d && q.normal.applyMatrix3(d).normalize();
	               b = 0;
	               for (f = t.length; b < f; b++) p = t[b].clone(), void 0 !== d && p.applyMatrix3(d).normalize(), q.vertexNormals.push(p);
	               q.color.copy(g.color);
	               b = 0;
	               for (f = n.length; b < f; b++) p = n[b], q.vertexColors.push(p.clone());
	               q.materialIndex = g.materialIndex + c;
	               h.push(q)
	            }
	            a = 0;
	            for (r = l.length; a < r; a++) if (c = l[a], d = [], void 0 !== c) {
	               b = 0;
	               for (f = c.length; b < f; b++) d.push(c[b].clone());
	               m.push(d)
	            }
	         }
	      },
	      mergeMesh: function(a) {
	         !1 === (a && a.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix))
	      },
	      mergeVertices: function() {
	         var a = {},
	            b = [],
	            c = [],
	            d, e = Math.pow(10, 4),
	            f, g;
	         f = 0;
	         for (g = this.vertices.length; f < g; f++) d = this.vertices[f], d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
	         a = [];
	         f = 0;
	         for (g = this.faces.length; f < g; f++) for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = 0; 3 > d; d++) if (e[d] === e[(d + 1) % 3]) {
	            a.push(f);
	            break
	         }
	         for (f = a.length - 1; 0 <= f; f--) for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++) this.faceVertexUvs[c].splice(e, 1);
	         f = this.vertices.length - b.length;
	         this.vertices = b;
	         return f
	      },
	      sortFacesByMaterialIndex: function() {
	         for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
	         a.sort(function(a, b) {
	            return a.materialIndex - b.materialIndex
	         });
	         var d = this.faceVertexUvs[0],
	            e = this.faceVertexUvs[1],
	            f, g;
	         d && d.length === b && (f = []);
	         e && e.length === b && (g = []);
	         for (c = 0; c < b; c++) {
	            var h = a[c]._id;
	            f && f.push(d[h]);
	            g && g.push(e[h])
	         }
	         f && (this.faceVertexUvs[0] = f);
	         g && (this.faceVertexUvs[1] = g)
	      },
	      toJSON: function() {
	         function a(a, b, c) {
	            return c ? a | 1 << b : a & ~ (1 << b)
	         }
	         function b(a) {
	            var b = a.x.toString() + a.y.toString() + a.z.toString();
	            if (void 0 !== m[b]) return m[b];
	            m[b] = k.length / 3;
	            k.push(a.x, a.y, a.z);
	            return m[b]
	         }
	         function c(a) {
	            var b = a.r.toString() + a.g.toString() + a.b.toString();
	            if (void 0 !== q[b]) return q[b];
	            q[b] = l.length;
	            l.push(a.getHex());
	            return q[b]
	         }
	         function d(a) {
	            var b = a.x.toString() + a.y.toString();
	            if (void 0 !== r[b]) return r[b];
	            r[b] = n.length / 2;
	            n.push(a.x, a.y);
	            return r[b]
	         }
	         var e = {
	            metadata: {
	               version: 4.5,
	               type: "Geometry",
	               generator: "Geometry.toJSON"
	            }
	         };
	         e.uuid = this.uuid;
	         e.type = this.type;
	         "" !== this.name && (e.name = this.name);
	         if (void 0 !== this.parameters) {
	            var f = this.parameters,
	               g;
	            for (g in f) void 0 !== f[g] && (e[g] = f[g]);
	            return e
	         }
	         f = [];
	         for (g = 0; g < this.vertices.length; g++) {
	            var h = this.vertices[g];
	            f.push(h.x, h.y, h.z)
	         }
	         var h = [],
	            k = [],
	            m = {},
	            l = [],
	            q = {},
	            n = [],
	            r = {};
	         for (g = 0; g < this.faces.length; g++) {
	            var p = this.faces[g],
	               t = void 0 !== this.faceVertexUvs[0][g],
	               y = 0 < p.normal.length(),
	               x = 0 < p.vertexNormals.length,
	               v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
	               G = 0 < p.vertexColors.length,
	               w = 0,
	               w = a(w, 0, 0),
	               w = a(w, 1, !0),
	               w = a(w, 2, !1),
	               w = a(w, 3, t),
	               w = a(w, 4, y),
	               w = a(w, 5, x),
	               w = a(w, 6, v),
	               w = a(w, 7, G);
	            h.push(w);
	            h.push(p.a, p.b, p.c);
	            h.push(p.materialIndex);
	            t && (t = this.faceVertexUvs[0][g], h.push(d(t[0]), d(t[1]), d(t[2])));
	            y && h.push(b(p.normal));
	            x && (y = p.vertexNormals, h.push(b(y[0]), b(y[1]), b(y[2])));
	            v && h.push(c(p.color));
	            G && (p = p.vertexColors, h.push(c(p[0]), c(p[1]), c(p[2])))
	         }
	         e.data = {};
	         e.data.vertices = f;
	         e.data.normals = k;
	         0 < l.length && (e.data.colors = l);
	         0 < n.length && (e.data.uvs = [n]);
	         e.data.faces = h;
	         return e
	      },
	      clone: function() {
	         return (new M).copy(this)
	      },
	      copy: function(a) {
	         var b, c, d, e, f, g;
	         this.vertices = [];
	         this.colors = [];
	         this.faces = [];
	         this.faceVertexUvs = [
	            []
	         ];
	         this.morphTargets = [];
	         this.morphNormals = [];
	         this.skinWeights = [];
	         this.skinIndices = [];
	         this.lineDistances = [];
	         this.boundingSphere = this.boundingBox = null;
	         this.name = a.name;
	         d = a.vertices;
	         b = 0;
	         for (c = d.length; b < c; b++) this.vertices.push(d[b].clone());
	         d = a.colors;
	         b = 0;
	         for (c = d.length; b < c; b++) this.colors.push(d[b].clone());
	         d = a.faces;
	         b = 0;
	         for (c = d.length; b < c; b++) this.faces.push(d[b].clone());
	         b = 0;
	         for (c = a.faceVertexUvs.length; b < c; b++) {
	            var h = a.faceVertexUvs[b];
	            void 0 === this.faceVertexUvs[b] && (this.faceVertexUvs[b] = []);
	            d = 0;
	            for (e = h.length; d < e; d++) {
	               var k = h[d],
	                  m = [];
	               f = 0;
	               for (g = k.length; f < g; f++) m.push(k[f].clone());
	               this.faceVertexUvs[b].push(m)
	            }
	         }
	         f = a.morphTargets;
	         b = 0;
	         for (c = f.length; b < c; b++) {
	            g = {};
	            g.name = f[b].name;
	            if (void 0 !== f[b].vertices) for (g.vertices = [], d = 0, e = f[b].vertices.length; d < e; d++) g.vertices.push(f[b].vertices[d].clone());
	            if (void 0 !== f[b].normals) for (g.normals = [], d = 0, e = f[b].normals.length; d < e; d++) g.normals.push(f[b].normals[d].clone());
	            this.morphTargets.push(g)
	         }
	         f = a.morphNormals;
	         b = 0;
	         for (c = f.length; b < c; b++) {
	            g = {};
	            if (void 0 !== f[b].vertexNormals) for (g.vertexNormals = [], d = 0, e = f[b].vertexNormals.length; d < e; d++) h = f[b].vertexNormals[d], k = {}, k.a = h.a.clone(), k.b = h.b.clone(), k.c = h.c.clone(), g.vertexNormals.push(k);
	            if (void 0 !== f[b].faceNormals) for (g.faceNormals = [], d = 0, e = f[b].faceNormals.length; d < e; d++) g.faceNormals.push(f[b].faceNormals[d].clone());
	            this.morphNormals.push(g)
	         }
	         d = a.skinWeights;
	         b = 0;
	         for (c = d.length; b < c; b++) this.skinWeights.push(d[b].clone());
	         d = a.skinIndices;
	         b = 0;
	         for (c = d.length; b < c; b++) this.skinIndices.push(d[b].clone());
	         d = a.lineDistances;
	         b = 0;
	         for (c = d.length; b < c; b++) this.lineDistances.push(d[b]);
	         b = a.boundingBox;
	         null !== b && (this.boundingBox = b.clone());
	         b = a.boundingSphere;
	         null !== b && (this.boundingSphere = b.clone());
	         this.elementsNeedUpdate = a.elementsNeedUpdate;
	         this.verticesNeedUpdate = a.verticesNeedUpdate;
	         this.uvsNeedUpdate = a.uvsNeedUpdate;
	         this.normalsNeedUpdate = a.normalsNeedUpdate;
	         this.colorsNeedUpdate = a.colorsNeedUpdate;
	         this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
	         this.groupsNeedUpdate = a.groupsNeedUpdate;
	         return this
	      },
	      dispose: function() {
	         this.dispatchEvent({
	            type: "dispose"
	         })
	      }
	   });
	   I.MaxIndex = 65535;
	   Object.assign(I.prototype, sa.prototype, {
	      isBufferGeometry: !0,
	      getIndex: function() {
	         return this.index
	      },
	      setIndex: function(a) {
	         Array.isArray(a) ? this.index = new(65535 < Sd(a) ? jb : ib)(a, 1) : this.index = a
	      },
	      addAttribute: function(a, b, c) {
	         if (!1 === (b && b.isBufferAttribute) && !1 === (b && b.isInterleavedBufferAttribute)) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new L(b, c));
	         else if ("index" === a) console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b);
	         else return this.attributes[a] = b, this
	      },
	      getAttribute: function(a) {
	         return this.attributes[a]
	      },
	      removeAttribute: function(a) {
	         delete this.attributes[a];
	         return this
	      },
	      addGroup: function(a, b, c) {
	         this.groups.push({
	            start: a,
	            count: b,
	            materialIndex: void 0 !== c ? c : 0
	         })
	      },
	      clearGroups: function() {
	         this.groups = []
	      },
	      setDrawRange: function(a, b) {
	         this.drawRange.start = a;
	         this.drawRange.count = b
	      },
	      applyMatrix: function(a) {
	         var b = this.attributes.position;
	         void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0);
	         b = this.attributes.normal;
	         void 0 !== b && ((new Ka).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0);
	         null !== this.boundingBox && this.computeBoundingBox();
	         null !== this.boundingSphere && this.computeBoundingSphere();
	         return this
	      },
	      rotateX: function() {
	         var a = new J;
	         return function(b) {
	            a.makeRotationX(b);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      rotateY: function() {
	         var a = new J;
	         return function(b) {
	            a.makeRotationY(b);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      rotateZ: function() {
	         var a = new J;
	         return function(b) {
	            a.makeRotationZ(b);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      translate: function() {
	         var a = new J;
	         return function(b, c, d) {
	            a.makeTranslation(b, c, d);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      scale: function() {
	         var a = new J;
	         return function(b, c, d) {
	            a.makeScale(b, c, d);
	            this.applyMatrix(a);
	            return this
	         }
	      }(),
	      lookAt: function() {
	         var a = new B;
	         return function(b) {
	            a.lookAt(b);
	            a.updateMatrix();
	            this.applyMatrix(a.matrix)
	         }
	      }(),
	      center: function() {
	         this.computeBoundingBox();
	         var a = this.boundingBox.getCenter().negate();
	         this.translate(a.x, a.y, a.z);
	         return a
	      },
	      setFromObject: function(a) {
	         var b = a.geometry;
	         if (a.isPoints || a.isLine) {
	            a = new C(3 * b.vertices.length, 3);
	            var c = new C(3 * b.colors.length, 3);
	            this.addAttribute("position", a.copyVector3sArray(b.vertices));
	            this.addAttribute("color", c.copyColorsArray(b.colors));
	            b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new C(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
	            null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
	            null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
	         } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
	         return this
	      },
	      updateFromObject: function(a) {
	         var b = a.geometry;
	         if (a.isMesh) {
	            var c = b.__directGeometry;
	            !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
	            if (void 0 === c) return this.fromGeometry(b);
	            c.verticesNeedUpdate = b.verticesNeedUpdate;
	            c.normalsNeedUpdate = b.normalsNeedUpdate;
	            c.colorsNeedUpdate = b.colorsNeedUpdate;
	            c.uvsNeedUpdate = b.uvsNeedUpdate;
	            c.groupsNeedUpdate = b.groupsNeedUpdate;
	            b.verticesNeedUpdate = !1;
	            b.normalsNeedUpdate = !1;
	            b.colorsNeedUpdate = !1;
	            b.uvsNeedUpdate = !1;
	            b.groupsNeedUpdate = !1;
	            b = c
	         }!0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1);
	         !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1);
	         !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1);
	         b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
	         b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
	         b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
	         return this
	      },
	      fromGeometry: function(a) {
	         a.__directGeometry = (new Ke).fromGeometry(a);
	         return this.fromDirectGeometry(a.__directGeometry)
	      },
	      fromDirectGeometry: function(a) {
	         var b = new Float32Array(3 * a.vertices.length);
	         this.addAttribute("position", new L(b, 3).copyVector3sArray(a.vertices));
	         0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", new L(b, 3).copyVector3sArray(a.normals)));
	         0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", new L(b, 3).copyColorsArray(a.colors)));
	         0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", new L(b, 2).copyVector2sArray(a.uvs)));
	         0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", new L(b, 2).copyVector2sArray(a.uvs2)));
	         0 < a.indices.length && (b = new(65535 < Sd(a.indices) ? Uint32Array : Uint16Array)(3 * a.indices.length), this.setIndex(new L(b, 1).copyIndicesArray(a.indices)));
	         this.groups = a.groups;
	         for (var c in a.morphTargets) {
	            for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
	               var g = d[e],
	                  h = new C(3 * g.length, 3);
	               b.push(h.copyVector3sArray(g))
	            }
	            this.morphAttributes[c] = b
	         }
	         0 < a.skinIndices.length && (c = new C(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
	         0 < a.skinWeights.length && (c = new C(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
	         null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
	         null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
	         return this
	      },
	      computeBoundingBox: function() {
	         null === this.boundingBox && (this.boundingBox = new Ta);
	         var a = this.attributes.position;
	         void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) : this.boundingBox.makeEmpty();
	         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
	      },
	      computeBoundingSphere: function() {
	         var a = new Ta,
	            b = new p;
	         return function() {
	            null === this.boundingSphere && (this.boundingSphere = new Ga);
	            var c = this.attributes.position;
	            if (c) {
	               var d = this.boundingSphere.center;
	               a.setFromBufferAttribute(c);
	               a.getCenter(d);
	               for (var e = 0, f = 0, g = c.count; f < g; f++) b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b));
	               this.boundingSphere.radius = Math.sqrt(e);
	               isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
	            }
	         }
	      }(),
	      computeFaceNormals: function() {},
	      computeVertexNormals: function() {
	         var a = this.index,
	            b = this.attributes,
	            c = this.groups;
	         if (b.position) {
	            var d = b.position.array;
	            if (void 0 === b.normal) this.addAttribute("normal", new L(new Float32Array(d.length), 3));
	            else for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
	            var e = b.normal.array,
	               h, k, m, l = new p,
	               q = new p,
	               n = new p,
	               r = new p,
	               z = new p;
	            if (a) {
	               a = a.array;
	               0 === c.length && this.addGroup(0, a.length);
	               for (var t = 0, y = c.length; t < y; ++t) for (f = c[t], g = f.start, h = f.count, f = g, g += h; f < g; f += 3) h = 3 * a[f + 0], k = 3 * a[f + 1], m = 3 * a[f + 2], l.fromArray(d, h), q.fromArray(d, k), n.fromArray(d, m), r.subVectors(n, q), z.subVectors(l, q), r.cross(z), e[h] += r.x, e[h + 1] += r.y, e[h + 2] += r.z, e[k] += r.x, e[k + 1] += r.y, e[k + 2] += r.z, e[m] += r.x, e[m + 1] += r.y, e[m + 2] += r.z
	            } else for (f = 0, g = d.length; f < g; f += 9) l.fromArray(d, f), q.fromArray(d, f + 3), n.fromArray(d, f + 6), r.subVectors(n, q), z.subVectors(l, q), r.cross(z), e[f] = r.x, e[f + 1] = r.y, e[f + 2] = r.z, e[f + 3] = r.x, e[f + 4] = r.y, e[f + 5] = r.z, e[f + 6] = r.x, e[f + 7] = r.y, e[f + 8] = r.z;
	            this.normalizeNormals();
	            b.normal.needsUpdate = !0
	         }
	      },
	      merge: function(a, b) {
	         if (!1 === (a && a.isBufferGeometry)) console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
	         else {
	            void 0 === b && (b = 0);
	            var c = this.attributes,
	               d;
	            for (d in c) if (void 0 !== a.attributes[d]) for (var e = c[d].array, f = a.attributes[d], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h];
	            return this
	         }
	      },
	      normalizeNormals: function() {
	         for (var a = this.attributes.normal, b, c, d, e, f = 0, g = a.count; f < g; f++) b = a.getX(f), c = a.getY(f), d = a.getZ(f), e = 1 / Math.sqrt(b * b + c * c + d * d), a.setXYZ(f, b * e, c * e, d * e)
	      },
	      toNonIndexed: function() {
	         if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
	         var a = new I,
	            b = this.index.array,
	            c = this.attributes,
	            d;
	         for (d in c) {
	            for (var e = c[d], f = e.array, e = e.itemSize, g = new f.constructor(b.length * e), h, k = 0, m = 0, l = b.length; m < l; m++) {
	               h = b[m] * e;
	               for (var q = 0; q < e; q++) g[k++] = f[h++]
	            }
	            a.addAttribute(d, new L(g, e))
	         }
	         return a
	      },
	      toJSON: function() {
	         var a = {
	            metadata: {
	               version: 4.5,
	               type: "BufferGeometry",
	               generator: "BufferGeometry.toJSON"
	            }
	         };
	         a.uuid = this.uuid;
	         a.type = this.type;
	         "" !== this.name && (a.name = this.name);
	         if (void 0 !== this.parameters) {
	            var b = this.parameters,
	               c;
	            for (c in b) void 0 !== b[c] && (a[c] = b[c]);
	            return a
	         }
	         a.data = {
	            attributes: {}
	         };
	         var d = this.index;
	         null !== d && (b = Array.prototype.slice.call(d.array), a.data.index = {
	            type: d.array.constructor.name,
	            array: b
	         });
	         d = this.attributes;
	         for (c in d) {
	            var e = d[c],
	               b = Array.prototype.slice.call(e.array);
	            a.data.attributes[c] = {
	               itemSize: e.itemSize,
	               type: e.array.constructor.name,
	               array: b,
	               normalized: e.normalized
	            }
	         }
	         c = this.groups;
	         0 < c.length && (a.data.groups = JSON.parse(JSON.stringify(c)));
	         c = this.boundingSphere;
	         null !== c && (a.data.boundingSphere = {
	            center: c.center.toArray(),
	            radius: c.radius
	         });
	         return a
	      },
	      clone: function() {
	         return (new I).copy(this)
	      },
	      copy: function(a) {
	         var b, c, d;
	         this.index = null;
	         this.attributes = {};
	         this.morphAttributes = {};
	         this.groups = [];
	         this.boundingSphere = this.boundingBox = null;
	         this.name = a.name;
	         c = a.index;
	         null !== c && this.setIndex(c.clone());
	         c = a.attributes;
	         for (b in c) this.addAttribute(b, c[b].clone());
	         var e = a.morphAttributes;
	         for (b in e) {
	            var f = [],
	               g = e[b];
	            c = 0;
	            for (d = g.length; c < d; c++) f.push(g[c].clone());
	            this.morphAttributes[b] = f
	         }
	         b = a.groups;
	         c = 0;
	         for (d = b.length; c < d; c++) e = b[c], this.addGroup(e.start, e.count, e.materialIndex);
	         b = a.boundingBox;
	         null !== b && (this.boundingBox = b.clone());
	         b = a.boundingSphere;
	         null !== b && (this.boundingSphere = b.clone());
	         this.drawRange.start = a.drawRange.start;
	         this.drawRange.count = a.drawRange.count;
	         return this
	      },
	      dispose: function() {
	         this.dispatchEvent({
	            type: "dispose"
	         })
	      }
	   });
	   Ca.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Ca,
	      isMesh: !0,
	      setDrawMode: function(a) {
	         this.drawMode = a
	      },
	      copy: function(a) {
	         B.prototype.copy.call(this, a);
	         this.drawMode = a.drawMode;
	         return this
	      },
	      updateMorphTargets: function() {
	         var a = this.geometry.morphTargets;
	         if (void 0 !== a && 0 < a.length) {
	            this.morphTargetInfluences = [];
	            this.morphTargetDictionary = {};
	            for (var b = 0, c = a.length; b < c; b++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[a[b].name] = b
	         }
	      },
	      raycast: function() {
	         function a(a, b, c, d, e, f, g) {
	            Ua.barycoordFromPoint(a, b, c, d, t);
	            e.multiplyScalar(t.x);
	            f.multiplyScalar(t.y);
	            g.multiplyScalar(t.z);
	            e.add(f).add(g);
	            return e.clone()
	         }
	         function b(a, b, c, d, e, f, g) {
	            var h = a.material;
	            if (null === (1 === h.side ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, 2 !== h.side, g))) return null;
	            x.copy(g);
	            x.applyMatrix4(a.matrixWorld);
	            c = b.ray.origin.distanceTo(x);
	            return c < b.near || c > b.far ? null : {
	               distance: c,
	               point: x.clone(),
	               object: a
	            }
	         }
	         function c(c, d, e, f, m, l, u, q) {
	            g.fromBufferAttribute(f, l);
	            h.fromBufferAttribute(f, u);
	            k.fromBufferAttribute(f, q);
	            if (c = b(c, d, e, g, h, k, y)) m && (n.fromBufferAttribute(m, l), r.fromBufferAttribute(m, u), z.fromBufferAttribute(m, q), c.uv = a(y, g, h, k, n, r, z)), c.face = new Va(l, u, q, Ua.normal(g, h, k)), c.faceIndex = l;
	            return c
	         }
	         var d = new J,
	            e = new hb,
	            f = new Ga,
	            g = new p,
	            h = new p,
	            k = new p,
	            m = new p,
	            l = new p,
	            q = new p,
	            n = new D,
	            r = new D,
	            z = new D,
	            t = new p,
	            y = new p,
	            x = new p;
	         return function(p, t) {
	            var w = this.geometry,
	               x = this.material,
	               C = this.matrixWorld;
	            if (void 0 !== x && (null === w.boundingSphere && w.computeBoundingSphere(), f.copy(w.boundingSphere), f.applyMatrix4(C), !1 !== p.ray.intersectsSphere(f) && (d.getInverse(C), e.copy(p.ray).applyMatrix4(d), null === w.boundingBox || !1 !== e.intersectsBox(w.boundingBox)))) {
	               var E;
	               if (w.isBufferGeometry) {
	                  var F, D, x = w.index,
	                     B = w.attributes.position,
	                     C = w.attributes.uv,
	                     ca, I;
	                  if (null !== x) for (ca = 0, I = x.count; ca < I; ca += 3) {
	                     if (w = x.getX(ca), F = x.getX(ca + 1), D = x.getX(ca + 2), E = c(this, p, e, B, C, w, F, D)) E.faceIndex = Math.floor(ca / 3), t.push(E)
	                  } else for (ca = 0, I = B.count; ca < I; ca += 3) if (w = ca, F = ca + 1, D = ca + 2, E = c(this, p, e, B, C, w, F, D)) E.index = w, t.push(E)
	               } else if (w.isGeometry) {
	                  var H, C = Array.isArray(x);
	                  ca = w.vertices;
	                  I = w.faces;
	                  F = w.faceVertexUvs[0];
	                  0 < F.length && (B = F);
	                  for (var J = 0, M = I.length; J < M; J++) {
	                     var P = I[J];
	                     E = C ? x[P.materialIndex] : x;
	                     if (void 0 !== E) {
	                        F = ca[P.a];
	                        D = ca[P.b];
	                        H = ca[P.c];
	                        if (!0 === E.morphTargets) {
	                           E = w.morphTargets;
	                           var K = this.morphTargetInfluences;
	                           g.set(0, 0, 0);
	                           h.set(0, 0, 0);
	                           k.set(0, 0, 0);
	                           for (var W = 0, ba = E.length; W < ba; W++) {
	                              var T = K[W];
	                              if (0 !== T) {
	                                 var Q = E[W].vertices;
	                                 g.addScaledVector(m.subVectors(Q[P.a], F), T);
	                                 h.addScaledVector(l.subVectors(Q[P.b], D), T);
	                                 k.addScaledVector(q.subVectors(Q[P.c], H), T)
	                              }
	                           }
	                           g.add(F);
	                           h.add(D);
	                           k.add(H);
	                           F = g;
	                           D = h;
	                           H = k
	                        }
	                        if (E = b(this, p, e, F, D, H, y)) B && B[J] && (K = B[J], n.copy(K[0]), r.copy(K[1]), z.copy(K[2]), E.uv = a(y, F, D, H, n, r, z)), E.face = P, E.faceIndex = J, t.push(E)
	                     }
	                  }
	               }
	            }
	         }
	      }(),
	      clone: function() {
	         return new this.constructor(this.geometry, this.material).copy(this)
	      }
	   });
	   Ib.prototype = Object.create(M.prototype);
	   Ib.prototype.constructor = Ib;
	   kb.prototype = Object.create(I.prototype);
	   kb.prototype.constructor = kb;
	   xc.prototype = Object.create(M.prototype);
	   xc.prototype.constructor = xc;
	   lb.prototype = Object.create(I.prototype);
	   lb.prototype.constructor = lb;
	   Oa.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Oa,
	      isCamera: !0,
	      copy: function(a) {
	         B.prototype.copy.call(this, a);
	         this.matrixWorldInverse.copy(a.matrixWorldInverse);
	         this.projectionMatrix.copy(a.projectionMatrix);
	         return this
	      },
	      getWorldDirection: function() {
	         var a = new qa;
	         return function(b) {
	            b = b || new p;
	            this.getWorldQuaternion(a);
	            return b.set(0, 0, -1).applyQuaternion(a)
	         }
	      }(),
	      clone: function() {
	         return (new this.constructor).copy(this)
	      }
	   });
	   xa.prototype = Object.assign(Object.create(Oa.prototype), {
	      constructor: xa,
	      isPerspectiveCamera: !0,
	      copy: function(a) {
	         Oa.prototype.copy.call(this, a);
	         this.fov = a.fov;
	         this.zoom = a.zoom;
	         this.near = a.near;
	         this.far = a.far;
	         this.focus = a.focus;
	         this.aspect = a.aspect;
	         this.view = null === a.view ? null : Object.assign({}, a.view);
	         this.filmGauge = a.filmGauge;
	         this.filmOffset = a.filmOffset;
	         return this
	      },
	      setFocalLength: function(a) {
	         a = .5 * this.getFilmHeight() / a;
	         this.fov = 2 * Y.RAD2DEG * Math.atan(a);
	         this.updateProjectionMatrix()
	      },
	      getFocalLength: function() {
	         var a = Math.tan(.5 * Y.DEG2RAD * this.fov);
	         return .5 * this.getFilmHeight() / a
	      },
	      getEffectiveFOV: function() {
	         return 2 * Y.RAD2DEG * Math.atan(Math.tan(.5 * Y.DEG2RAD * this.fov) / this.zoom)
	      },
	      getFilmWidth: function() {
	         return this.filmGauge * Math.min(this.aspect, 1)
	      },
	      getFilmHeight: function() {
	         return this.filmGauge / Math.max(this.aspect, 1)
	      },
	      setViewOffset: function(a, b, c, d, e, f) {
	         this.aspect = a / b;
	         this.view = {
	            fullWidth: a,
	            fullHeight: b,
	            offsetX: c,
	            offsetY: d,
	            width: e,
	            height: f
	         };
	         this.updateProjectionMatrix()
	      },
	      clearViewOffset: function() {
	         this.view = null;
	         this.updateProjectionMatrix()
	      },
	      updateProjectionMatrix: function() {
	         var a = this.near,
	            b = a * Math.tan(.5 * Y.DEG2RAD * this.fov) / this.zoom,
	            c = 2 * b,
	            d = this.aspect * c,
	            e = -.5 * d,
	            f = this.view;
	         if (null !== f) var g = f.fullWidth,
	            h = f.fullHeight,
	            e = e + f.offsetX * d / g,
	            b = b - f.offsetY * c / h,
	            d = f.width / g * d,
	            c = f.height / h * c;
	         f = this.filmOffset;
	         0 !== f && (e += a * f / this.getFilmWidth());
	         this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far)
	      },
	      toJSON: function(a) {
	         a = B.prototype.toJSON.call(this, a);
	         a.object.fov = this.fov;
	         a.object.zoom = this.zoom;
	         a.object.near = this.near;
	         a.object.far = this.far;
	         a.object.focus = this.focus;
	         a.object.aspect = this.aspect;
	         null !== this.view && (a.object.view = Object.assign({}, this.view));
	         a.object.filmGauge = this.filmGauge;
	         a.object.filmOffset = this.filmOffset;
	         return a
	      }
	   });
	   Jb.prototype = Object.assign(Object.create(Oa.prototype), {
	      constructor: Jb,
	      isOrthographicCamera: !0,
	      copy: function(a) {
	         Oa.prototype.copy.call(this, a);
	         this.left = a.left;
	         this.right = a.right;
	         this.top = a.top;
	         this.bottom = a.bottom;
	         this.near = a.near;
	         this.far = a.far;
	         this.zoom = a.zoom;
	         this.view = null === a.view ? null : Object.assign({}, a.view);
	         return this
	      },
	      setViewOffset: function(a, b, c, d, e, f) {
	         this.view = {
	            fullWidth: a,
	            fullHeight: b,
	            offsetX: c,
	            offsetY: d,
	            width: e,
	            height: f
	         };
	         this.updateProjectionMatrix()
	      },
	      clearViewOffset: function() {
	         this.view = null;
	         this.updateProjectionMatrix()
	      },
	      updateProjectionMatrix: function() {
	         var a = (this.right - this.left) / (2 * this.zoom),
	            b = (this.top - this.bottom) / (2 * this.zoom),
	            c = (this.right + this.left) / 2,
	            d = (this.top + this.bottom) / 2,
	            e = c - a,
	            c = c + a,
	            a = d + b,
	            b = d - b;
	         if (null !== this.view) var c = this.zoom / (this.view.width / this.view.fullWidth),
	            b = this.zoom / (this.view.height / this.view.fullHeight),
	            f = (this.right - this.left) / this.view.width,
	            d = (this.top - this.bottom) / this.view.height,
	            e = e + this.view.offsetX / c * f,
	            c = e + this.view.width / c * f,
	            a = a - this.view.offsetY / b * d,
	            b = a - this.view.height / b * d;
	         this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
	      },
	      toJSON: function(a) {
	         a = B.prototype.toJSON.call(this, a);
	         a.object.zoom = this.zoom;
	         a.object.left = this.left;
	         a.object.right = this.right;
	         a.object.top = this.top;
	         a.object.bottom = this.bottom;
	         a.object.near = this.near;
	         a.object.far = this.far;
	         null !== this.view && (a.object.view = Object.assign({}, this.view));
	         return a
	      }
	   });
	   var bg = 0;
	   Kb.prototype.isFogExp2 = !0;
	   Kb.prototype.clone = function() {
	      return new Kb(this.color.getHex(), this.density)
	   };
	   Kb.prototype.toJSON = function(a) {
	      return {
	         type: "FogExp2",
	         color: this.color.getHex(),
	         density: this.density
	      }
	   };
	   Lb.prototype.isFog = !0;
	   Lb.prototype.clone = function() {
	      return new Lb(this.color.getHex(), this.near, this.far)
	   };
	   Lb.prototype.toJSON = function(a) {
	      return {
	         type: "Fog",
	         color: this.color.getHex(),
	         near: this.near,
	         far: this.far
	      }
	   };
	   md.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: md,
	      copy: function(a, b) {
	         B.prototype.copy.call(this, a, b);
	         null !== a.background && (this.background = a.background.clone());
	         null !== a.fog && (this.fog = a.fog.clone());
	         null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
	         this.autoUpdate = a.autoUpdate;
	         this.matrixAutoUpdate = a.matrixAutoUpdate;
	         return this
	      },
	      toJSON: function(a) {
	         var b = B.prototype.toJSON.call(this, a);
	         null !== this.background && (b.object.background = this.background.toJSON(a));
	         null !== this.fog && (b.object.fog = this.fog.toJSON());
	         return b
	      }
	   });
	   Yd.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Yd,
	      isLensFlare: !0,
	      copy: function(a) {
	         B.prototype.copy.call(this, a);
	         this.positionScreen.copy(a.positionScreen);
	         this.customUpdateCallback = a.customUpdateCallback;
	         for (var b = 0, c = a.lensFlares.length; b < c; b++) this.lensFlares.push(a.lensFlares[b]);
	         return this
	      },
	      add: function(a, b, c, d, e, f) {
	         void 0 === b && (b = -1);
	         void 0 === c && (c = 0);
	         void 0 === f && (f = 1);
	         void 0 === e && (e = new H(16777215));
	         void 0 === d && (d = 1);
	         c = Math.min(c, Math.max(0, c));
	         this.lensFlares.push({
	            texture: a,
	            size: b,
	            distance: c,
	            x: 0,
	            y: 0,
	            z: 0,
	            scale: 1,
	            rotation: 0,
	            opacity: f,
	            color: e,
	            blending: d
	         })
	      },
	      updateLensFlares: function() {
	         var a, b = this.lensFlares.length,
	            c, d = 2 * -this.positionScreen.x,
	            e = 2 * -this.positionScreen.y;
	         for (a = 0; a < b; a++) c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * .25, c.rotation += .25 * (c.wantedRotation - c.rotation)
	      }
	   });
	   cb.prototype = Object.create(Z.prototype);
	   cb.prototype.constructor = cb;
	   cb.prototype.isSpriteMaterial = !0;
	   cb.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.map = a.map;
	      this.rotation = a.rotation;
	      return this
	   };
	   Ac.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Ac,
	      isSprite: !0,
	      raycast: function() {
	         var a = new p,
	            b = new p,
	            c = new p;
	         return function(d, e) {
	            b.setFromMatrixPosition(this.matrixWorld);
	            d.ray.closestPointToPoint(b, a);
	            c.setFromMatrixScale(this.matrixWorld);
	            var f = c.x * c.y / 4;
	            b.distanceToSquared(a) > f || (f = d.ray.origin.distanceTo(a), f < d.near || f > d.far || e.push({
	               distance: f,
	               point: a.clone(),
	               face: null,
	               object: this
	            }))
	         }
	      }(),
	      clone: function() {
	         return new this.constructor(this.material).copy(this)
	      }
	   });
	   Bc.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Bc,
	      copy: function(a) {
	         B.prototype.copy.call(this, a, !1);
	         a = a.levels;
	         for (var b = 0, c = a.length; b < c; b++) {
	            var d = a[b];
	            this.addLevel(d.object.clone(), d.distance)
	         }
	         return this
	      },
	      addLevel: function(a, b) {
	         void 0 === b && (b = 0);
	         b = Math.abs(b);
	         for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
	         c.splice(d, 0, {
	            distance: b,
	            object: a
	         });
	         this.add(a)
	      },
	      getObjectForDistance: function(a) {
	         for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
	         return b[c - 1].object
	      },
	      raycast: function() {
	         var a = new p;
	         return function(b, c) {
	            a.setFromMatrixPosition(this.matrixWorld);
	            var d = b.ray.origin.distanceTo(a);
	            this.getObjectForDistance(d).raycast(b, c)
	         }
	      }(),
	      update: function() {
	         var a = new p,
	            b = new p;
	         return function(c) {
	            var d = this.levels;
	            if (1 < d.length) {
	               a.setFromMatrixPosition(c.matrixWorld);
	               b.setFromMatrixPosition(this.matrixWorld);
	               c = a.distanceTo(b);
	               d[0].object.visible = !0;
	               for (var e = 1, f = d.length; e < f; e++) if (c >= d[e].distance) d[e - 1].object.visible = !1, d[e].object.visible = !0;
	               else break;
	               for (; e < f; e++) d[e].object.visible = !1
	            }
	         }
	      }(),
	      toJSON: function(a) {
	         a = B.prototype.toJSON.call(this, a);
	         a.object.levels = [];
	         for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
	            var e = b[c];
	            a.object.levels.push({
	               object: e.object.uuid,
	               distance: e.distance
	            })
	         }
	         return a
	      }
	   });
	   Object.assign(Cc.prototype, {
	      calculateInverses: function() {
	         this.boneInverses = [];
	         for (var a = 0, b = this.bones.length; a < b; a++) {
	            var c = new J;
	            this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
	            this.boneInverses.push(c)
	         }
	      },
	      pose: function() {
	         var a, b, c;
	         b = 0;
	         for (c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
	         b = 0;
	         for (c = this.bones.length; b < c; b++) if (a = this.bones[b]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
	      },
	      update: function() {
	         var a = new J,
	            b = new J;
	         return function() {
	            for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++) a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 * g);
	            void 0 !== f && (f.needsUpdate = !0)
	         }
	      }(),
	      clone: function() {
	         return new Cc(this.bones, this.boneInverses)
	      }
	   });
	   nd.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: nd,
	      isBone: !0
	   });
	   od.prototype = Object.assign(Object.create(Ca.prototype), {
	      constructor: od,
	      isSkinnedMesh: !0,
	      initBones: function() {
	         var a = [],
	            b, c, d, e;
	         if (this.geometry && void 0 !== this.geometry.bones) {
	            d = 0;
	            for (e = this.geometry.bones.length; d < e; d++) c = this.geometry.bones[d], b = new nd, a.push(b), b.name = c.name, b.position.fromArray(c.pos), b.quaternion.fromArray(c.rotq), void 0 !== c.scl && b.scale.fromArray(c.scl);
	            d = 0;
	            for (e = this.geometry.bones.length; d < e; d++) c = this.geometry.bones[d], -1 !== c.parent && null !== c.parent && void 0 !== a[c.parent] ? a[c.parent].add(a[d]) : this.add(a[d])
	         }
	         this.updateMatrixWorld(!0);
	         return a
	      },
	      bind: function(a, b) {
	         this.skeleton = a;
	         void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
	         this.bindMatrix.copy(b);
	         this.bindMatrixInverse.getInverse(b)
	      },
	      pose: function() {
	         this.skeleton.pose()
	      },
	      normalizeSkinWeights: function() {
	         var a, b;
	         if (this.geometry && this.geometry.isGeometry) for (b = 0; b < this.geometry.skinWeights.length; b++) {
	            var c = this.geometry.skinWeights[b];
	            a = 1 / c.lengthManhattan();
	            Infinity !== a ? c.multiplyScalar(a) : c.set(1, 0, 0, 0)
	         } else if (this.geometry && this.geometry.isBufferGeometry) {
	            var c = new ga,
	               d = this.geometry.attributes.skinWeight;
	            for (b = 0; b < d.count; b++) c.x = d.getX(b), c.y = d.getY(b), c.z = d.getZ(b), c.w = d.getW(b), a = 1 / c.lengthManhattan(), Infinity !== a ? c.multiplyScalar(a) : c.set(1, 0, 0, 0), d.setXYZW(b, c.x, c.y, c.z, c.w)
	         }
	      },
	      updateMatrixWorld: function(a) {
	         Ca.prototype.updateMatrixWorld.call(this, a);
	         "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
	      },
	      clone: function() {
	         return new this.constructor(this.geometry, this.material).copy(this)
	      }
	   });
	   ha.prototype = Object.create(Z.prototype);
	   ha.prototype.constructor = ha;
	   ha.prototype.isLineBasicMaterial = !0;
	   ha.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.linewidth = a.linewidth;
	      this.linecap = a.linecap;
	      this.linejoin = a.linejoin;
	      return this
	   };
	   ya.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: ya,
	      isLine: !0,
	      raycast: function() {
	         var a = new J,
	            b = new hb,
	            c = new Ga;
	         return function(d, e) {
	            var f = d.linePrecision,
	               f = f * f,
	               g = this.geometry,
	               h = this.matrixWorld;
	            null === g.boundingSphere && g.computeBoundingSphere();
	            c.copy(g.boundingSphere);
	            c.applyMatrix4(h);
	            if (!1 !== d.ray.intersectsSphere(c)) {
	               a.getInverse(h);
	               b.copy(d.ray).applyMatrix4(a);
	               var k = new p,
	                  m = new p,
	                  h = new p,
	                  l = new p,
	                  q = this && this.isLineSegments ? 2 : 1;
	               if (g.isBufferGeometry) {
	                  var n = g.index,
	                     r = g.attributes.position.array;
	                  if (null !== n) for (var n = n.array, g = 0, z = n.length - 1; g < z; g += q) {
	                     var t = n[g + 1];
	                     k.fromArray(r, 3 * n[g]);
	                     m.fromArray(r, 3 * t);
	                     t = b.distanceSqToSegment(k, m, l, h);
	                     t > f || (l.applyMatrix4(this.matrixWorld), t = d.ray.origin.distanceTo(l), t < d.near || t > d.far || e.push({
	                        distance: t,
	                        point: h.clone().applyMatrix4(this.matrixWorld),
	                        index: g,
	                        face: null,
	                        faceIndex: null,
	                        object: this
	                     }))
	                  } else for (g = 0, z = r.length / 3 - 1; g < z; g += q) k.fromArray(r, 3 * g), m.fromArray(r, 3 * g + 3), t = b.distanceSqToSegment(k, m, l, h), t > f || (l.applyMatrix4(this.matrixWorld), t = d.ray.origin.distanceTo(l), t < d.near || t > d.far || e.push({
	                     distance: t,
	                     point: h.clone().applyMatrix4(this.matrixWorld),
	                     index: g,
	                     face: null,
	                     faceIndex: null,
	                     object: this
	                  }))
	               } else if (g.isGeometry) for (k = g.vertices, m = k.length, g = 0; g < m - 1; g += q) t = b.distanceSqToSegment(k[g], k[g + 1], l, h), t > f || (l.applyMatrix4(this.matrixWorld), t = d.ray.origin.distanceTo(l), t < d.near || t > d.far || e.push({
	                  distance: t,
	                  point: h.clone().applyMatrix4(this.matrixWorld),
	                  index: g,
	                  face: null,
	                  faceIndex: null,
	                  object: this
	               }))
	            }
	         }
	      }(),
	      clone: function() {
	         return new this.constructor(this.geometry, this.material).copy(this)
	      }
	   });
	   da.prototype = Object.assign(Object.create(ya.prototype), {
	      constructor: da,
	      isLineSegments: !0
	   });
	   pd.prototype = Object.assign(Object.create(ya.prototype), {
	      constructor: pd,
	      isLineLoop: !0
	   });
	   La.prototype = Object.create(Z.prototype);
	   La.prototype.constructor = La;
	   La.prototype.isPointsMaterial = !0;
	   La.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.map = a.map;
	      this.size = a.size;
	      this.sizeAttenuation = a.sizeAttenuation;
	      return this
	   };
	   Mb.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Mb,
	      isPoints: !0,
	      raycast: function() {
	         var a = new J,
	            b = new hb,
	            c = new Ga;
	         return function(d, e) {
	            function f(a, c) {
	               var f = b.distanceSqToPoint(a);
	               if (f < l) {
	                  var h = b.closestPointToPoint(a);
	                  h.applyMatrix4(k);
	                  var m = d.ray.origin.distanceTo(h);
	                  m < d.near || m > d.far || e.push({
	                     distance: m,
	                     distanceToRay: Math.sqrt(f),
	                     point: h.clone(),
	                     index: c,
	                     face: null,
	                     object: g
	                  })
	               }
	            }
	            var g = this,
	               h = this.geometry,
	               k = this.matrixWorld,
	               m = d.params.Points.threshold;
	            null === h.boundingSphere && h.computeBoundingSphere();
	            c.copy(h.boundingSphere);
	            c.applyMatrix4(k);
	            c.radius += m;
	            if (!1 !== d.ray.intersectsSphere(c)) {
	               a.getInverse(k);
	               b.copy(d.ray).applyMatrix4(a);
	               var m = m / ((this.scale.x + this.scale.y + this.scale.z) / 3),
	                  l = m * m,
	                  m = new p;
	               if (h.isBufferGeometry) {
	                  var q = h.index,
	                     h = h.attributes.position.array;
	                  if (null !== q) for (var n = q.array, q = 0, r = n.length; q < r; q++) {
	                     var z = n[q];
	                     m.fromArray(h, 3 * z);
	                     f(m, z)
	                  } else for (q = 0, n = h.length / 3; q < n; q++) m.fromArray(h, 3 * q), f(m, q)
	               } else for (m = h.vertices, q = 0, n = m.length; q < n; q++) f(m[q], q)
	            }
	         }
	      }(),
	      clone: function() {
	         return new this.constructor(this.geometry, this.material).copy(this)
	      }
	   });
	   Dc.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: Dc
	   });
	   qd.prototype = Object.create(X.prototype);
	   qd.prototype.constructor = qd;
	   Nb.prototype = Object.create(X.prototype);
	   Nb.prototype.constructor = Nb;
	   Nb.prototype.isCompressedTexture = !0;
	   rd.prototype = Object.create(X.prototype);
	   rd.prototype.constructor = rd;
	   Ec.prototype = Object.create(X.prototype);
	   Ec.prototype.constructor = Ec;
	   Ec.prototype.isDepthTexture = !0;
	   Ob.prototype = Object.create(I.prototype);
	   Ob.prototype.constructor = Ob;
	   Fc.prototype = Object.create(M.prototype);
	   Fc.prototype.constructor = Fc;
	   Pb.prototype = Object.create(I.prototype);
	   Pb.prototype.constructor = Pb;
	   Gc.prototype = Object.create(M.prototype);
	   Gc.prototype.constructor = Gc;
	   ia.prototype = Object.create(I.prototype);
	   ia.prototype.constructor = ia;
	   Hc.prototype = Object.create(M.prototype);
	   Hc.prototype.constructor = Hc;
	   Qb.prototype = Object.create(ia.prototype);
	   Qb.prototype.constructor = Qb;
	   Ic.prototype = Object.create(M.prototype);
	   Ic.prototype.constructor = Ic;
	   mb.prototype = Object.create(ia.prototype);
	   mb.prototype.constructor = mb;
	   Jc.prototype = Object.create(M.prototype);
	   Jc.prototype.constructor = Jc;
	   Rb.prototype = Object.create(ia.prototype);
	   Rb.prototype.constructor = Rb;
	   Kc.prototype = Object.create(M.prototype);
	   Kc.prototype.constructor = Kc;
	   Sb.prototype = Object.create(ia.prototype);
	   Sb.prototype.constructor = Sb;
	   Lc.prototype = Object.create(M.prototype);
	   Lc.prototype.constructor = Lc;
	   Tb.prototype = Object.create(I.prototype);
	   Tb.prototype.constructor = Tb;
	   Mc.prototype = Object.create(M.prototype);
	   Mc.prototype.constructor = Mc;
	   Ub.prototype = Object.create(I.prototype);
	   Ub.prototype.constructor = Ub;
	   Nc.prototype = Object.create(M.prototype);
	   Nc.prototype.constructor = Nc;
	   Vb.prototype = Object.create(I.prototype);
	   Vb.prototype.constructor = Vb;
	   var za = {
	      area: function(a) {
	         for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
	         return .5 * c
	      },
	      triangulate: function() {
	         return function(a, b) {
	            var c = a.length;
	            if (3 > c) return null;
	            var d = [],
	               e = [],
	               f = [],
	               g, h, k;
	            if (0 < za.area(a)) for (h = 0; h < c; h++) e[h] = h;
	            else for (h = 0; h < c; h++) e[h] = c - 1 - h;
	            var m = 2 * c;
	            for (h = c - 1; 2 < c;) {
	               if (0 >= m--) {
	                  console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
	                  break
	               }
	               g = h;
	               c <= g && (g = 0);
	               h = g + 1;
	               c <= h && (h = 0);
	               k = h + 1;
	               c <= k && (k = 0);
	               var l;
	               a: {
	                  var q, n, r, p, t, y, x, v;
	                  q = a[e[g]].x;
	                  n = a[e[g]].y;
	                  r = a[e[h]].x;
	                  p = a[e[h]].y;
	                  t = a[e[k]].x;
	                  y = a[e[k]].y;
	                  if (0 >= (r - q) * (y - n) - (p - n) * (t - q)) l = !1;
	                  else {
	                     var G, w, O, C, E, F, D, B, I, H;
	                     G = t - r;
	                     w = y - p;
	                     O = q - t;
	                     C = n - y;
	                     E = r - q;
	                     F = p - n;
	                     for (l = 0; l < c; l++) if (x = a[e[l]].x, v = a[e[l]].y, !(x === q && v === n || x === r && v === p || x === t && v === y) && (D = x - q, B = v - n, I = x - r, H = v - p, x -= t, v -= y, I = G * H - w * I, D = E * B - F * D, B = O * v - C * x, I >= -Number.EPSILON && B >= -Number.EPSILON && D >= -Number.EPSILON)) {
	                        l = !1;
	                        break a
	                     }
	                     l = !0
	                  }
	               }
	               if (l) {
	                  d.push([a[e[g]], a[e[h]], a[e[k]]]);
	                  f.push([e[g], e[h], e[k]]);
	                  g = h;
	                  for (k = h + 1; k < c; g++, k++) e[g] = e[k];
	                  c--;
	                  m = 2 * c
	               }
	            }
	            return b ? f : d
	         }
	      }(),
	      triangulateShape: function(a, b) {
	         function c(a) {
	            var b = a.length;
	            2 < b && a[b - 1].equals(a[0]) && a.pop()
	         }
	         function d(a, b, c) {
	            return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
	         }
	         function e(a, b, c, e, f) {
	            var g = b.x - a.x,
	               h = b.y - a.y,
	               k = e.x - c.x,
	               m = e.y - c.y,
	               l = a.x - c.x,
	               n = a.y - c.y,
	               q = h * k - g * m,
	               u = h * l - g * n;
	            if (Math.abs(q) > Number.EPSILON) {
	               if (0 < q) {
	                  if (0 > u || u > q) return [];
	                  k = m * l - k * n;
	                  if (0 > k || k > q) return []
	               } else {
	                  if (0 < u || u < q) return [];
	                  k = m * l - k * n;
	                  if (0 < k || k < q) return []
	               }
	               if (0 === k) return !f || 0 !== u && u !== q ? [a] : [];
	               if (k === q) return !f || 0 !== u && u !== q ? [b] : [];
	               if (0 === u) return [c];
	               if (u === q) return [e];
	               f = k / q;
	               return [{
	                  x: a.x + f * g,
	                  y: a.y + f * h
	               }]
	            }
	            if (0 !== u || m * l !== k * n) return [];
	            h = 0 === g && 0 === h;
	            k = 0 === k && 0 === m;
	            if (h && k) return a.x !== c.x || a.y !== c.y ? [] : [a];
	            if (h) return d(c, e, a) ? [a] : [];
	            if (k) return d(a, b, c) ? [c] : [];
	            0 !== g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), c.x < e.x ? (b = c, q = c.x, m = e, c = e.x) : (b = e, q = e.x, m = c, c = c.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), c.y < e.y ? (b = c, q = c.y, m = e, c = e.y) : (b = e, q = e.y, m = c, c = c.y));
	            return k <= q ? a < q ? [] : a === q ? f ? [] : [b] : a <= c ? [b, h] : [b, m] : k > c ? [] : k === c ? f ? [] : [g] : a <= c ? [g, h] : [g, m]
	         }
	         function f(a, b, c, d) {
	            var e = b.x - a.x,
	               f = b.y - a.y;
	            b = c.x - a.x;
	            c = c.y - a.y;
	            var g = d.x - a.x;
	            d = d.y - a.y;
	            a = e * c - f * b;
	            e = e * d - f * g;
	            return Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
	         }
	         c(a);
	         b.forEach(c);
	         var g, h, k, m, l, q = {};
	         k = a.concat();
	         g = 0;
	         for (h = b.length; g < h; g++) Array.prototype.push.apply(k, b[g]);
	         g = 0;
	         for (h = k.length; g < h; g++) l = k[g].x + ":" + k[g].y, void 0 !== q[l] && console.warn("THREE.ShapeUtils: Duplicate point", l, g), q[l] = g;
	         g = function(a, b) {
	            function c(a, b) {
	               var d = h.length - 1,
	                  e = a - 1;
	               0 > e && (e = d);
	               var g = a + 1;
	               g > d && (g = 0);
	               d = f(h[a], h[e], h[g], k[b]);
	               if (!d) return !1;
	               d = k.length - 1;
	               e = b - 1;
	               0 > e && (e = d);
	               g = b + 1;
	               g > d && (g = 0);
	               return (d = f(k[b], k[e], k[g], h[a])) ? !0 : !1
	            }
	            function d(a, b) {
	               var c, f;
	               for (c = 0; c < h.length; c++) if (f = c + 1, f %= h.length, f = e(a, b, h[c], h[f], !0), 0 < f.length) return !0;
	               return !1
	            }
	            function g(a, c) {
	               var d, f, h, k;
	               for (d = 0; d < m.length; d++) for (f = b[m[d]], h = 0; h < f.length; h++) if (k = h + 1, k %= f.length, k = e(a, c, f[h], f[k], !0), 0 < k.length) return !0;
	               return !1
	            }
	            var h = a.concat(),
	               k, m = [],
	               l, n, q, u, p, C = [],
	               D, B, I, H = 0;
	            for (l = b.length; H < l; H++) m.push(H);
	            D = 0;
	            for (var J = 2 * m.length; 0 < m.length;) {
	               J--;
	               if (0 > J) {
	                  console.log("Infinite Loop! Holes left:" + m.length + ", Probably Hole outside Shape!");
	                  break
	               }
	               for (n = D; n < h.length; n++) {
	                  q = h[n];
	                  l = -1;
	                  for (H = 0; H < m.length; H++) if (u = m[H], p = q.x + ":" + q.y + ":" + u, void 0 === C[p]) {
	                     k = b[u];
	                     for (B = 0; B < k.length; B++) if (u = k[B], c(n, B) && !d(q, u) && !g(q, u)) {
	                        l = B;
	                        m.splice(H, 1);
	                        D = h.slice(0, n + 1);
	                        u = h.slice(n);
	                        B = k.slice(l);
	                        I = k.slice(0, l + 1);
	                        h = D.concat(B).concat(I).concat(u);
	                        D = n;
	                        break
	                     }
	                     if (0 <= l) break;
	                     C[p] = !0
	                  }
	                  if (0 <= l) break
	               }
	            }
	            return h
	         }(a, b);
	         var n = za.triangulate(g, !1);
	         g = 0;
	         for (h = n.length; g < h; g++) for (m = n[g], k = 0; 3 > k; k++) l = m[k].x + ":" + m[k].y, l = q[l], void 0 !== l && (m[k] = l);
	         return n.concat()
	      },
	      isClockWise: function(a) {
	         return 0 > za.area(a)
	      }
	   };
	   db.prototype = Object.create(M.prototype);
	   db.prototype.constructor = db;
	   Fa.prototype = Object.create(I.prototype);
	   Fa.prototype.constructor = Fa;
	   Fa.prototype.getArrays = function() {
	      var a = this.getAttribute("position"),
	         a = a ? Array.prototype.slice.call(a.array) : [],
	         b = this.getAttribute("uv"),
	         b = b ? Array.prototype.slice.call(b.array) : [],
	         c = this.index,
	         c = c ? Array.prototype.slice.call(c.array) : [];
	      return {
	         position: a,
	         uv: b,
	         index: c
	      }
	   };
	   Fa.prototype.addShapeList = function(a, b) {
	      var c = a.length;
	      b.arrays = this.getArrays();
	      for (var d = 0; d < c; d++) this.addShape(a[d], b);
	      this.setIndex(b.arrays.index);
	      this.addAttribute("position", new C(b.arrays.position, 3));
	      this.addAttribute("uv", new C(b.arrays.uv, 2))
	   };
	   Fa.prototype.addShape = function(a, b) {
	      function c(a, b, c) {
	         b || console.error("THREE.ExtrudeGeometry: vec does not exist");
	         return b.clone().multiplyScalar(c).add(a)
	      }
	      function d(a, b, c) {
	         var d, e, f;
	         e = a.x - b.x;
	         f = a.y - b.y;
	         d = c.x - a.x;
	         var g = c.y - a.y,
	            h = e * e + f * f;
	         if (Math.abs(e * g - f * d) > Number.EPSILON) {
	            var k = Math.sqrt(h),
	               m = Math.sqrt(d * d + g * g),
	               h = b.x - f / k;
	            b = b.y + e / k;
	            g = ((c.x - g / m - h) * g - (c.y + d / m - b) * d) / (e * g - f * d);
	            d = h + e * g - a.x;
	            e = b + f * g - a.y;
	            f = d * d + e * e;
	            if (2 >= f) return new D(d, e);
	            f = Math.sqrt(f / 2)
	         } else a = !1, e > Number.EPSILON ? d > Number.EPSILON && (a = !0) : e < -Number.EPSILON ? d < -Number.EPSILON && (a = !0) : Math.sign(f) === Math.sign(g) && (a = !0), a ? (d = -f, f = Math.sqrt(h)) : (d = e, e = f, f = Math.sqrt(h / 2));
	         return new D(d / f, e / f)
	      }
	      function e(a, b) {
	         var c, d;
	         for (N = a.length; 0 <= --N;) {
	            c = N;
	            d = N - 1;
	            0 > d && (d = a.length - 1);
	            var e, f = G + 2 * y;
	            for (e = 0; e < f; e++) {
	               var g = da * e,
	                  m = da * (e + 1),
	                  n = b + d + g,
	                  q = b + d + m,
	                  m = b + c + m;
	               h(b + c + g);
	               h(n);
	               h(m);
	               h(n);
	               h(q);
	               h(m);
	               g = l.length / 3;
	               g = E.generateSideWallUV(Z, l, g - 6, g - 3, g - 2, g - 1);
	               k(g[0]);
	               k(g[1]);
	               k(g[3]);
	               k(g[1]);
	               k(g[2]);
	               k(g[3])
	            }
	         }
	      }
	      function f(a, b, c) {
	         r.push(a);
	         r.push(b);
	         r.push(c)
	      }
	      function g(a, b, c) {
	         h(a);
	         h(b);
	         h(c);
	         a = l.length / 3;
	         a = E.generateTopUV(Z, l, a - 3, a - 2, a - 1);
	         k(a[0]);
	         k(a[1]);
	         k(a[2])
	      }
	      function h(a) {
	         q.push(l.length / 3);
	         l.push(r[3 * a + 0]);
	         l.push(r[3 * a + 1]);
	         l.push(r[3 * a + 2])
	      }
	      function k(a) {
	         n.push(a.x);
	         n.push(a.y)
	      }
	      var m = b.arrays ? b.arrays : this.getArrays(),
	         l = m.position,
	         q = m.index,
	         n = m.uv,
	         r = [],
	         m = void 0 !== b.amount ? b.amount : 100,
	         z = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
	         t = void 0 !== b.bevelSize ? b.bevelSize : z - 2,
	         y = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
	         x = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
	         v = void 0 !== b.curveSegments ? b.curveSegments : 12,
	         G = void 0 !== b.steps ? b.steps : 1,
	         w = b.extrudePath,
	         B, I = !1,
	         E = void 0 !== b.UVGenerator ? b.UVGenerator : db.WorldUVGenerator,
	         F, H, R, J;
	      w && (B = w.getSpacedPoints(G), I = !0, x = !1, F = void 0 !== b.frames ? b.frames : w.computeFrenetFrames(G, !1), H = new p, R = new p, J = new p);
	      x || (t = z = y = 0);
	      var M, L, V, Z = this,
	         w = a.extractPoints(v),
	         v = w.shape,
	         P = w.holes;
	      if (w = !za.isClockWise(v)) {
	         v = v.reverse();
	         L = 0;
	         for (V = P.length; L < V; L++) M = P[L], za.isClockWise(M) && (P[L] = M.reverse());
	         w = !1
	      }
	      var K = za.triangulateShape(v, P),
	         W = v;
	      L = 0;
	      for (V = P.length; L < V; L++) M = P[L], v = v.concat(M);
	      var ba, T, Q, Y, U, da = v.length,
	         X, ga = K.length,
	         w = [],
	         N = 0;
	      Q = W.length;
	      ba = Q - 1;
	      for (T = N + 1; N < Q; N++, ba++, T++) ba === Q && (ba = 0), T === Q && (T = 0), w[N] = d(W[N], W[ba], W[T]);
	      var ia = [],
	         ka, ha = w.concat();
	      L = 0;
	      for (V = P.length; L < V; L++) {
	         M = P[L];
	         ka = [];
	         N = 0;
	         Q = M.length;
	         ba = Q - 1;
	         for (T = N + 1; N < Q; N++, ba++, T++) ba === Q && (ba = 0), T === Q && (T = 0), ka[N] = d(M[N], M[ba], M[T]);
	         ia.push(ka);
	         ha = ha.concat(ka)
	      }
	      for (ba = 0; ba < y; ba++) {
	         Q = ba / y;
	         Y = z * Math.cos(Q * Math.PI / 2);
	         T = t * Math.sin(Q * Math.PI / 2);
	         N = 0;
	         for (Q = W.length; N < Q; N++) U = c(W[N], w[N], T), f(U.x, U.y, -Y);
	         L = 0;
	         for (V = P.length; L < V; L++) for (M = P[L], ka = ia[L], N = 0, Q = M.length; N < Q; N++) U = c(M[N], ka[N], T), f(U.x, U.y, -Y)
	      }
	      T = t;
	      for (N = 0; N < da; N++) U = x ? c(v[N], ha[N], T) : v[N], I ? (R.copy(F.normals[0]).multiplyScalar(U.x), H.copy(F.binormals[0]).multiplyScalar(U.y), J.copy(B[0]).add(R).add(H), f(J.x, J.y, J.z)) : f(U.x, U.y, 0);
	      for (Q = 1; Q <= G; Q++) for (N = 0; N < da; N++) U = x ? c(v[N], ha[N], T) : v[N], I ? (R.copy(F.normals[Q]).multiplyScalar(U.x), H.copy(F.binormals[Q]).multiplyScalar(U.y), J.copy(B[Q]).add(R).add(H), f(J.x, J.y, J.z)) : f(U.x, U.y, m / G * Q);
	      for (ba = y - 1; 0 <= ba; ba--) {
	         Q = ba / y;
	         Y = z * Math.cos(Q * Math.PI / 2);
	         T = t * Math.sin(Q * Math.PI / 2);
	         N = 0;
	         for (Q = W.length; N < Q; N++) U = c(W[N], w[N], T), f(U.x, U.y, m + Y);
	         L = 0;
	         for (V = P.length; L < V; L++) for (M = P[L], ka = ia[L], N = 0, Q = M.length; N < Q; N++) U = c(M[N], ka[N], T), I ? f(U.x, U.y + B[G - 1].y, B[G - 1].x + Y) : f(U.x, U.y, m + Y)
	      }(function() {
	         var a = l.length / 3;
	         if (x) {
	            var c = 0 * da;
	            for (N = 0; N < ga; N++) X = K[N], g(X[2] + c, X[1] + c, X[0] + c);
	            c = da * (G + 2 * y);
	            for (N = 0; N < ga; N++) X = K[N], g(X[0] + c, X[1] + c, X[2] + c)
	         } else {
	            for (N = 0; N < ga; N++) X = K[N], g(X[2], X[1], X[0]);
	            for (N = 0; N < ga; N++) X = K[N], g(X[0] + da * G, X[1] + da * G, X[2] + da * G)
	         }
	         Z.addGroup(a, l.length / 3 - a, void 0 !== b.material ? b.material : 0)
	      })();
	      (function() {
	         var a = l.length / 3,
	            c = 0;
	         e(W, c);
	         c += W.length;
	         L = 0;
	         for (V = P.length; L < V; L++) M = P[L], e(M, c), c += M.length;
	         Z.addGroup(a, l.length / 3 - a, void 0 !== b.extrudeMaterial ? b.extrudeMaterial : 1)
	      })();
	      b.arrays || (this.setIndex(q), this.addAttribute("position", new C(l, 3)), this.addAttribute("uv", new C(b.arrays.uv, 2)))
	   };
	   db.WorldUVGenerator = {
	      generateTopUV: function(a, b, c, d, e) {
	         a = b[3 * d];
	         d = b[3 * d + 1];
	         var f = b[3 * e];
	         e = b[3 * e + 1];
	         return [new D(b[3 * c], b[3 * c + 1]), new D(a, d), new D(f, e)]
	      },
	      generateSideWallUV: function(a, b, c, d, e, f) {
	         a = b[3 * c];
	         var g = b[3 * c + 1];
	         c = b[3 * c + 2];
	         var h = b[3 * d],
	            k = b[3 * d + 1];
	         d = b[3 * d + 2];
	         var m = b[3 * e],
	            l = b[3 * e + 1];
	         e = b[3 * e + 2];
	         var q = b[3 * f],
	            n = b[3 * f + 1];
	         b = b[3 * f + 2];
	         return .01 > Math.abs(g - k) ? [new D(a, 1 - c), new D(h, 1 - d), new D(m, 1 - e), new D(q, 1 - b)] : [new D(g, 1 - c), new D(k, 1 - d), new D(l, 1 - e), new D(n, 1 - b)]
	      }
	   };
	   Oc.prototype = Object.create(M.prototype);
	   Oc.prototype.constructor = Oc;
	   Wb.prototype = Object.create(Fa.prototype);
	   Wb.prototype.constructor = Wb;
	   Pc.prototype = Object.create(M.prototype);
	   Pc.prototype.constructor = Pc;
	   nb.prototype = Object.create(I.prototype);
	   nb.prototype.constructor = nb;
	   Qc.prototype = Object.create(M.prototype);
	   Qc.prototype.constructor = Qc;
	   Xb.prototype = Object.create(I.prototype);
	   Xb.prototype.constructor = Xb;
	   Rc.prototype = Object.create(M.prototype);
	   Rc.prototype.constructor = Rc;
	   Yb.prototype = Object.create(I.prototype);
	   Yb.prototype.constructor = Yb;
	   Zb.prototype = Object.create(M.prototype);
	   Zb.prototype.constructor = Zb;
	   $b.prototype = Object.create(I.prototype);
	   $b.prototype.constructor = $b;
	   ac.prototype = Object.create(I.prototype);
	   ac.prototype.constructor = ac;
	   ob.prototype = Object.create(M.prototype);
	   ob.prototype.constructor = ob;
	   Wa.prototype = Object.create(I.prototype);
	   Wa.prototype.constructor = Wa;
	   Sc.prototype = Object.create(ob.prototype);
	   Sc.prototype.constructor = Sc;
	   Tc.prototype = Object.create(Wa.prototype);
	   Tc.prototype.constructor = Tc;
	   Uc.prototype = Object.create(M.prototype);
	   Uc.prototype.constructor = Uc;
	   bc.prototype = Object.create(I.prototype);
	   bc.prototype.constructor = bc;
	   var Ma = Object.freeze({
	      WireframeGeometry: Ob,
	      ParametricGeometry: Fc,
	      ParametricBufferGeometry: Pb,
	      TetrahedronGeometry: Hc,
	      TetrahedronBufferGeometry: Qb,
	      OctahedronGeometry: Ic,
	      OctahedronBufferGeometry: mb,
	      IcosahedronGeometry: Jc,
	      IcosahedronBufferGeometry: Rb,
	      DodecahedronGeometry: Kc,
	      DodecahedronBufferGeometry: Sb,
	      PolyhedronGeometry: Gc,
	      PolyhedronBufferGeometry: ia,
	      TubeGeometry: Lc,
	      TubeBufferGeometry: Tb,
	      TorusKnotGeometry: Mc,
	      TorusKnotBufferGeometry: Ub,
	      TorusGeometry: Nc,
	      TorusBufferGeometry: Vb,
	      TextGeometry: Oc,
	      TextBufferGeometry: Wb,
	      SphereGeometry: Pc,
	      SphereBufferGeometry: nb,
	      RingGeometry: Qc,
	      RingBufferGeometry: Xb,
	      PlaneGeometry: xc,
	      PlaneBufferGeometry: lb,
	      LatheGeometry: Rc,
	      LatheBufferGeometry: Yb,
	      ShapeGeometry: Zb,
	      ShapeBufferGeometry: $b,
	      ExtrudeGeometry: db,
	      ExtrudeBufferGeometry: Fa,
	      EdgesGeometry: ac,
	      ConeGeometry: Sc,
	      ConeBufferGeometry: Tc,
	      CylinderGeometry: ob,
	      CylinderBufferGeometry: Wa,
	      CircleGeometry: Uc,
	      CircleBufferGeometry: bc,
	      BoxGeometry: Ib,
	      BoxBufferGeometry: kb
	   });
	   cc.prototype = Object.create(Ea.prototype);
	   cc.prototype.constructor = cc;
	   cc.prototype.isShadowMaterial = !0;
	   dc.prototype = Object.create(Ea.prototype);
	   dc.prototype.constructor = dc;
	   dc.prototype.isRawShaderMaterial = !0;
	   Ra.prototype = Object.create(Z.prototype);
	   Ra.prototype.constructor = Ra;
	   Ra.prototype.isMeshStandardMaterial = !0;
	   Ra.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.defines = {
	         STANDARD: ""
	      };
	      this.color.copy(a.color);
	      this.roughness = a.roughness;
	      this.metalness = a.metalness;
	      this.map = a.map;
	      this.lightMap = a.lightMap;
	      this.lightMapIntensity = a.lightMapIntensity;
	      this.aoMap = a.aoMap;
	      this.aoMapIntensity = a.aoMapIntensity;
	      this.emissive.copy(a.emissive);
	      this.emissiveMap = a.emissiveMap;
	      this.emissiveIntensity = a.emissiveIntensity;
	      this.bumpMap = a.bumpMap;
	      this.bumpScale = a.bumpScale;
	      this.normalMap = a.normalMap;
	      this.normalScale.copy(a.normalScale);
	      this.displacementMap = a.displacementMap;
	      this.displacementScale = a.displacementScale;
	      this.displacementBias = a.displacementBias;
	      this.roughnessMap = a.roughnessMap;
	      this.metalnessMap = a.metalnessMap;
	      this.alphaMap = a.alphaMap;
	      this.envMap = a.envMap;
	      this.envMapIntensity = a.envMapIntensity;
	      this.refractionRatio = a.refractionRatio;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      this.wireframeLinecap = a.wireframeLinecap;
	      this.wireframeLinejoin = a.wireframeLinejoin;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      this.morphNormals = a.morphNormals;
	      return this
	   };
	   pb.prototype = Object.create(Ra.prototype);
	   pb.prototype.constructor = pb;
	   pb.prototype.isMeshPhysicalMaterial = !0;
	   pb.prototype.copy = function(a) {
	      Ra.prototype.copy.call(this, a);
	      this.defines = {
	         PHYSICAL: ""
	      };
	      this.reflectivity = a.reflectivity;
	      this.clearCoat = a.clearCoat;
	      this.clearCoatRoughness = a.clearCoatRoughness;
	      return this
	   };
	   ta.prototype = Object.create(Z.prototype);
	   ta.prototype.constructor = ta;
	   ta.prototype.isMeshPhongMaterial = !0;
	   ta.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.specular.copy(a.specular);
	      this.shininess = a.shininess;
	      this.map = a.map;
	      this.lightMap = a.lightMap;
	      this.lightMapIntensity = a.lightMapIntensity;
	      this.aoMap = a.aoMap;
	      this.aoMapIntensity = a.aoMapIntensity;
	      this.emissive.copy(a.emissive);
	      this.emissiveMap = a.emissiveMap;
	      this.emissiveIntensity = a.emissiveIntensity;
	      this.bumpMap = a.bumpMap;
	      this.bumpScale = a.bumpScale;
	      this.normalMap = a.normalMap;
	      this.normalScale.copy(a.normalScale);
	      this.displacementMap = a.displacementMap;
	      this.displacementScale = a.displacementScale;
	      this.displacementBias = a.displacementBias;
	      this.specularMap = a.specularMap;
	      this.alphaMap = a.alphaMap;
	      this.envMap = a.envMap;
	      this.combine = a.combine;
	      this.reflectivity = a.reflectivity;
	      this.refractionRatio = a.refractionRatio;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      this.wireframeLinecap = a.wireframeLinecap;
	      this.wireframeLinejoin = a.wireframeLinejoin;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      this.morphNormals = a.morphNormals;
	      return this
	   };
	   qb.prototype = Object.create(ta.prototype);
	   qb.prototype.constructor = qb;
	   qb.prototype.isMeshToonMaterial = !0;
	   qb.prototype.copy = function(a) {
	      ta.prototype.copy.call(this, a);
	      this.gradientMap = a.gradientMap;
	      return this
	   };
	   rb.prototype = Object.create(Z.prototype);
	   rb.prototype.constructor = rb;
	   rb.prototype.isMeshNormalMaterial = !0;
	   rb.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.bumpMap = a.bumpMap;
	      this.bumpScale = a.bumpScale;
	      this.normalMap = a.normalMap;
	      this.normalScale.copy(a.normalScale);
	      this.displacementMap = a.displacementMap;
	      this.displacementScale = a.displacementScale;
	      this.displacementBias = a.displacementBias;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      this.morphNormals = a.morphNormals;
	      return this
	   };
	   sb.prototype = Object.create(Z.prototype);
	   sb.prototype.constructor = sb;
	   sb.prototype.isMeshLambertMaterial = !0;
	   sb.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.map = a.map;
	      this.lightMap = a.lightMap;
	      this.lightMapIntensity = a.lightMapIntensity;
	      this.aoMap = a.aoMap;
	      this.aoMapIntensity = a.aoMapIntensity;
	      this.emissive.copy(a.emissive);
	      this.emissiveMap = a.emissiveMap;
	      this.emissiveIntensity = a.emissiveIntensity;
	      this.specularMap = a.specularMap;
	      this.alphaMap = a.alphaMap;
	      this.envMap = a.envMap;
	      this.combine = a.combine;
	      this.reflectivity = a.reflectivity;
	      this.refractionRatio = a.refractionRatio;
	      this.wireframe = a.wireframe;
	      this.wireframeLinewidth = a.wireframeLinewidth;
	      this.wireframeLinecap = a.wireframeLinecap;
	      this.wireframeLinejoin = a.wireframeLinejoin;
	      this.skinning = a.skinning;
	      this.morphTargets = a.morphTargets;
	      this.morphNormals = a.morphNormals;
	      return this
	   };
	   tb.prototype = Object.create(Z.prototype);
	   tb.prototype.constructor = tb;
	   tb.prototype.isLineDashedMaterial = !0;
	   tb.prototype.copy = function(a) {
	      Z.prototype.copy.call(this, a);
	      this.color.copy(a.color);
	      this.linewidth = a.linewidth;
	      this.scale = a.scale;
	      this.dashSize = a.dashSize;
	      this.gapSize = a.gapSize;
	      return this
	   };
	   var lg = Object.freeze({
	      ShadowMaterial: cc,
	      SpriteMaterial: cb,
	      RawShaderMaterial: dc,
	      ShaderMaterial: Ea,
	      PointsMaterial: La,
	      MeshPhysicalMaterial: pb,
	      MeshStandardMaterial: Ra,
	      MeshPhongMaterial: ta,
	      MeshToonMaterial: qb,
	      MeshNormalMaterial: rb,
	      MeshLambertMaterial: sb,
	      MeshDepthMaterial: $a,
	      MeshBasicMaterial: Na,
	      LineDashedMaterial: tb,
	      LineBasicMaterial: ha,
	      Material: Z
	   }),
	      hd = {
	         enabled: !1,
	         files: {},
	         add: function(a, b) {
	            !1 !== this.enabled && (this.files[a] = b)
	         },
	         get: function(a) {
	            if (!1 !== this.enabled) return this.files[a]
	         },
	         remove: function(a) {
	            delete this.files[a]
	         },
	         clear: function() {
	            this.files = {}
	         }
	      },
	      Aa = new Zd;
	   Object.assign(ua.prototype, {
	      load: function(a, b, c, d) {
	         void 0 === a && (a = "");
	         void 0 !== this.path && (a = this.path + a);
	         var e = this,
	            f = hd.get(a);
	         if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
	            b && b(f);
	            e.manager.itemEnd(a)
	         }, 0), f;
	         var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
	         if (g) {
	            var h = g[1],
	               k = !! g[2],
	               g = g[3],
	               g = window.decodeURIComponent(g);
	            k && (g = window.atob(g));
	            try {
	               var m, l = (this.responseType || "").toLowerCase();
	               switch (l) {
	               case "arraybuffer":
	               case "blob":
	                  m = new ArrayBuffer(g.length);
	                  for (var q = new Uint8Array(m), k = 0; k < g.length; k++) q[k] = g.charCodeAt(k);
	                  "blob" === l && (m = new Blob([m], {
	                     type: h
	                  }));
	                  break;
	               case "document":
	                  m = (new DOMParser).parseFromString(g, h);
	                  break;
	               case "json":
	                  m = JSON.parse(g);
	                  break;
	               default:
	                  m = g
	               }
	               window.setTimeout(function() {
	                  b && b(m);
	                  e.manager.itemEnd(a)
	               }, 0)
	            } catch (p) {
	               window.setTimeout(function() {
	                  d && d(p);
	                  e.manager.itemEnd(a);
	                  e.manager.itemError(a)
	               }, 0)
	            }
	         } else {
	            var n = new XMLHttpRequest;
	            n.open("GET", a, !0);
	            n.addEventListener("load", function(c) {
	               var f = c.target.response;
	               hd.add(a, f);
	               200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), b && b(f), e.manager.itemEnd(a)) : (d && d(c), e.manager.itemEnd(a), e.manager.itemError(a))
	            }, !1);
	            void 0 !== c && n.addEventListener("progress", function(a) {
	               c(a)
	            }, !1);
	            n.addEventListener("error", function(b) {
	               d && d(b);
	               e.manager.itemEnd(a);
	               e.manager.itemError(a)
	            }, !1);
	            void 0 !== this.responseType && (n.responseType = this.responseType);
	            void 0 !== this.withCredentials && (n.withCredentials = this.withCredentials);
	            n.overrideMimeType && n.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
	            for (h in this.requestHeader) n.setRequestHeader(h, this.requestHeader[h]);
	            n.send(null)
	         }
	         e.manager.itemStart(a);
	         return n
	      },
	      setPath: function(a) {
	         this.path = a;
	         return this
	      },
	      setResponseType: function(a) {
	         this.responseType = a;
	         return this
	      },
	      setWithCredentials: function(a) {
	         this.withCredentials = a;
	         return this
	      },
	      setMimeType: function(a) {
	         this.mimeType = a;
	         return this
	      },
	      setRequestHeader: function(a) {
	         this.requestHeader = a;
	         return this
	      }
	   });
	   Object.assign(Qe.prototype, {
	      load: function(a, b, c, d) {
	         function e(e) {
	            k.load(a[e], function(a) {
	               a = f._parser(a, !0);
	               g[e] = {
	                  width: a.width,
	                  height: a.height,
	                  format: a.format,
	                  mipmaps: a.mipmaps
	               };
	               m += 1;
	               6 === m && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h))
	            }, c, d)
	         }
	         var f = this,
	            g = [],
	            h = new Nb;
	         h.image = g;
	         var k = new ua(this.manager);
	         k.setPath(this.path);
	         k.setResponseType("arraybuffer");
	         if (Array.isArray(a)) for (var m = 0, l = 0, q = a.length; l < q; ++l) e(l);
	         else k.load(a, function(a) {
	            a = f._parser(a, !0);
	            if (a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
	               g[d] = {
	                  mipmaps: []
	               };
	               for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
	            } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
	            1 === a.mipmapCount && (h.minFilter = 1006);
	            h.format = a.format;
	            h.needsUpdate = !0;
	            b && b(h)
	         }, c, d);
	         return h
	      },
	      setPath: function(a) {
	         this.path = a;
	         return this
	      }
	   });
	   Object.assign($d.prototype, {
	      load: function(a, b, c, d) {
	         var e = this,
	            f = new eb,
	            g = new ua(this.manager);
	         g.setResponseType("arraybuffer");
	         g.load(a, function(a) {
	            if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a)
	         }, c, d);
	         return f
	      }
	   });
	   Object.assign(Vc.prototype, {
	      load: function(a, b, c, d) {
	         void 0 === a && (a = "");
	         void 0 !== this.path && (a = this.path + a);
	         var e = this,
	            f = hd.get(a);
	         if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
	            b && b(f);
	            e.manager.itemEnd(a)
	         }, 0), f;
	         c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
	         c.addEventListener("load", function() {
	            hd.add(a, this);
	            b && b(this);
	            e.manager.itemEnd(a)
	         }, !1);
	         c.addEventListener("error", function(b) {
	            d && d(b);
	            e.manager.itemEnd(a);
	            e.manager.itemError(a)
	         }, !1);
	         "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin);
	         e.manager.itemStart(a);
	         c.src = a;
	         return c
	      },
	      setCrossOrigin: function(a) {
	         this.crossOrigin = a;
	         return this
	      },
	      setPath: function(a) {
	         this.path = a;
	         return this
	      }
	   });
	   Object.assign(ae.prototype, {
	      load: function(a, b, c, d) {
	         function e(c) {
	            g.load(a[c], function(a) {
	               f.images[c] = a;
	               h++;
	               6 === h && (f.needsUpdate = !0, b && b(f))
	            }, void 0, d)
	         }
	         var f = new Za,
	            g = new Vc(this.manager);
	         g.setCrossOrigin(this.crossOrigin);
	         g.setPath(this.path);
	         var h = 0;
	         for (c = 0; c < a.length; ++c) e(c);
	         return f
	      },
	      setCrossOrigin: function(a) {
	         this.crossOrigin = a;
	         return this
	      },
	      setPath: function(a) {
	         this.path = a;
	         return this
	      }
	   });
	   Object.assign(sd.prototype, {
	      load: function(a, b, c, d) {
	         var e = new Vc(this.manager);
	         e.setCrossOrigin(this.crossOrigin);
	         e.setPath(this.path);
	         var f = new X;
	         f.image = e.load(a, function() {
	            var c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data\:image\/jpeg/);
	            f.format = c ? 1022 : 1023;
	            f.needsUpdate = !0;
	            void 0 !== b && b(f)
	         }, c, d);
	         return f
	      },
	      setCrossOrigin: function(a) {
	         this.crossOrigin = a;
	         return this
	      },
	      setPath: function(a) {
	         this.path = a;
	         return this
	      }
	   });
	   ma.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: ma,
	      isLight: !0,
	      copy: function(a) {
	         B.prototype.copy.call(this, a);
	         this.color.copy(a.color);
	         this.intensity = a.intensity;
	         return this
	      },
	      toJSON: function(a) {
	         a = B.prototype.toJSON.call(this, a);
	         a.object.color = this.color.getHex();
	         a.object.intensity = this.intensity;
	         void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
	         void 0 !== this.distance && (a.object.distance = this.distance);
	         void 0 !== this.angle && (a.object.angle = this.angle);
	         void 0 !== this.decay && (a.object.decay = this.decay);
	         void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
	         void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
	         return a
	      }
	   });
	   td.prototype = Object.assign(Object.create(ma.prototype), {
	      constructor: td,
	      isHemisphereLight: !0,
	      copy: function(a) {
	         ma.prototype.copy.call(this, a);
	         this.groundColor.copy(a.groundColor);
	         return this
	      }
	   });
	   Object.assign(ub.prototype, {
	      copy: function(a) {
	         this.camera = a.camera.clone();
	         this.bias = a.bias;
	         this.radius = a.radius;
	         this.mapSize.copy(a.mapSize);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      toJSON: function() {
	         var a = {};
	         0 !== this.bias && (a.bias = this.bias);
	         1 !== this.radius && (a.radius = this.radius);
	         if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
	         a.camera = this.camera.toJSON(!1).object;
	         delete a.camera.matrix;
	         return a
	      }
	   });
	   ud.prototype = Object.assign(Object.create(ub.prototype), {
	      constructor: ud,
	      isSpotLightShadow: !0,
	      update: function(a) {
	         var b = this.camera,
	            c = 2 * Y.RAD2DEG * a.angle,
	            d = this.mapSize.width / this.mapSize.height;
	         a = a.distance || b.far;
	         if (c !== b.fov || d !== b.aspect || a !== b.far) b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix()
	      }
	   });
	   vd.prototype = Object.assign(Object.create(ma.prototype), {
	      constructor: vd,
	      isSpotLight: !0,
	      copy: function(a) {
	         ma.prototype.copy.call(this, a);
	         this.distance = a.distance;
	         this.angle = a.angle;
	         this.penumbra = a.penumbra;
	         this.decay = a.decay;
	         this.target = a.target.clone();
	         this.shadow = a.shadow.clone();
	         return this
	      }
	   });
	   wd.prototype = Object.assign(Object.create(ma.prototype), {
	      constructor: wd,
	      isPointLight: !0,
	      copy: function(a) {
	         ma.prototype.copy.call(this, a);
	         this.distance = a.distance;
	         this.decay = a.decay;
	         this.shadow = a.shadow.clone();
	         return this
	      }
	   });
	   xd.prototype = Object.assign(Object.create(ub.prototype), {
	      constructor: xd
	   });
	   yd.prototype = Object.assign(Object.create(ma.prototype), {
	      constructor: yd,
	      isDirectionalLight: !0,
	      copy: function(a) {
	         ma.prototype.copy.call(this, a);
	         this.target = a.target.clone();
	         this.shadow = a.shadow.clone();
	         return this
	      }
	   });
	   zd.prototype = Object.assign(Object.create(ma.prototype), {
	      constructor: zd,
	      isAmbientLight: !0
	   });
	   Ad.prototype = Object.assign(Object.create(ma.prototype), {
	      constructor: Ad,
	      isRectAreaLight: !0,
	      copy: function(a) {
	         ma.prototype.copy.call(this, a);
	         this.width = a.width;
	         this.height = a.height;
	         return this
	      },
	      toJSON: function(a) {
	         a = ma.prototype.toJSON.call(this, a);
	         a.object.width = this.width;
	         a.object.height = this.height;
	         return a
	      }
	   });
	   var va = {
	      arraySlice: function(a, b, c) {
	         return va.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
	      },
	      convertArray: function(a, b, c) {
	         return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
	      },
	      isTypedArray: function(a) {
	         return ArrayBuffer.isView(a) && !(a instanceof DataView)
	      },
	      getKeyframeOrder: function(a) {
	         for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
	         c.sort(function(b, c) {
	            return a[b] - a[c]
	         });
	         return c
	      },
	      sortedArray: function(a, b, c) {
	         for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f) for (var h = c[f] * b, k = 0; k !== b; ++k) e[g++] = a[h + k];
	         return e
	      },
	      flattenJSON: function(a, b, c, d) {
	         for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
	         if (void 0 !== f) {
	            var g = f[d];
	            if (void 0 !== g) if (Array.isArray(g)) {
	               do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++];
	               while (void 0 !== f)
	            } else if (void 0 !== g.toArray) {
	               do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++];
	               while (void 0 !== f)
	            } else {
	               do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++];
	               while (void 0 !== f)
	            }
	         }
	      }
	   };
	   Object.assign(Da.prototype, {
	      evaluate: function(a) {
	         var b = this.parameterPositions,
	            c = this._cachedIndex,
	            d = b[c],
	            e = b[c - 1];
	         a: {
	            b: {
	               c: {
	                  d: if (!(a < d)) {
	                     for (var f = c + 2;;) {
	                        if (void 0 === d) {
	                           if (a < e) break d;
	                           this._cachedIndex = c = b.length;
	                           return this.afterEnd_(c - 1, a, e)
	                        }
	                        if (c === f) break;
	                        e = d;
	                        d = b[++c];
	                        if (a < d) break b
	                     }
	                     d = b.length;
	                     break c
	                  }
	                  if (a >= e) break a;
	                  else {
	                     f = b[1];
	                     a < f && (c = 2, e = f);
	                     for (f = c - 2;;) {
	                        if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
	                        if (c === f) break;
	                        d = e;
	                        e = b[--c - 1];
	                        if (a >= e) break b
	                     }
	                     d = c;
	                     c = 0
	                  }
	               }
	               for (; c < d;) e = c + d >>> 1,
	               a < b[e] ? d = e : c = e + 1;
	               d = b[c];
	               e = b[c - 1];
	               if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
	               if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
	            }
	            this._cachedIndex = c;
	            this.intervalChanged_(c, e, d)
	         }
	         return this.interpolate_(c, e, a, d)
	      },
	      settings: null,
	      DefaultSettings_: {},
	      getSettings_: function() {
	         return this.settings || this.DefaultSettings_
	      },
	      copySampleValue_: function(a) {
	         var b = this.resultBuffer,
	            c = this.sampleValues,
	            d = this.valueSize;
	         a *= d;
	         for (var e = 0; e !== d; ++e) b[e] = c[a + e];
	         return b
	      },
	      interpolate_: function(a, b, c, d) {
	         throw Error("call to abstract method")
	      },
	      intervalChanged_: function(a, b, c) {}
	   });
	   Object.assign(Da.prototype, {
	      beforeStart_: Da.prototype.copySampleValue_,
	      afterEnd_: Da.prototype.copySampleValue_
	   });
	   Bd.prototype = Object.assign(Object.create(Da.prototype), {
	      constructor: Bd,
	      DefaultSettings_: {
	         endingStart: 2400,
	         endingEnd: 2400
	      },
	      intervalChanged_: function(a, b, c) {
	         var d = this.parameterPositions,
	            e = a - 2,
	            f = a + 1,
	            g = d[e],
	            h = d[f];
	         if (void 0 === g) switch (this.getSettings_().endingStart) {
	         case 2401:
	            e = a;
	            g = 2 * b - c;
	            break;
	         case 2402:
	            e = d.length - 2;
	            g = b + d[e] - d[e + 1];
	            break;
	         default:
	            e = a, g = c
	         }
	         if (void 0 === h) switch (this.getSettings_().endingEnd) {
	         case 2401:
	            f = a;
	            h = 2 * c - b;
	            break;
	         case 2402:
	            f = 1;
	            h = c + d[1] - d[0];
	            break;
	         default:
	            f = a - 1, h = b
	         }
	         a = .5 * (c - b);
	         d = this.valueSize;
	         this._weightPrev = a / (b - g);
	         this._weightNext = a / (h - c);
	         this._offsetPrev = e * d;
	         this._offsetNext = f * d
	      },
	      interpolate_: function(a, b, c, d) {
	         var e = this.resultBuffer,
	            f = this.sampleValues,
	            g = this.valueSize;
	         a *= g;
	         var h = a - g,
	            k = this._offsetPrev,
	            m = this._offsetNext,
	            l = this._weightPrev,
	            q = this._weightNext,
	            n = (c - b) / (d - b);
	         c = n * n;
	         d = c * n;
	         b = -l * d + 2 * l * c - l * n;
	         l = (1 + l) * d + (-1.5 - 2 * l) * c + (-.5 + l) * n + 1;
	         n = (-1 - q) * d + (1.5 + q) * c + .5 * n;
	         q = q * d - q * c;
	         for (c = 0; c !== g; ++c) e[c] = b * f[k + c] + l * f[h + c] + n * f[a + c] + q * f[m + c];
	         return e
	      }
	   });
	   Wc.prototype = Object.assign(Object.create(Da.prototype), {
	      constructor: Wc,
	      interpolate_: function(a, b, c, d) {
	         var e = this.resultBuffer,
	            f = this.sampleValues,
	            g = this.valueSize;
	         a *= g;
	         var h = a - g;
	         b = (c - b) / (d - b);
	         c = 1 - b;
	         for (d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
	         return e
	      }
	   });
	   Cd.prototype = Object.assign(Object.create(Da.prototype), {
	      constructor: Cd,
	      interpolate_: function(a, b, c, d) {
	         return this.copySampleValue_(a - 1)
	      }
	   });
	   var Ya;
	   Ya = {
	      TimeBufferType: Float32Array,
	      ValueBufferType: Float32Array,
	      DefaultInterpolation: 2301,
	      InterpolantFactoryMethodDiscrete: function(a) {
	         return new Cd(this.times, this.values, this.getValueSize(), a)
	      },
	      InterpolantFactoryMethodLinear: function(a) {
	         return new Wc(this.times, this.values, this.getValueSize(), a)
	      },
	      InterpolantFactoryMethodSmooth: function(a) {
	         return new Bd(this.times, this.values, this.getValueSize(), a)
	      },
	      setInterpolation: function(a) {
	         var b;
	         switch (a) {
	         case 2300:
	            b = this.InterpolantFactoryMethodDiscrete;
	            break;
	         case 2301:
	            b = this.InterpolantFactoryMethodLinear;
	            break;
	         case 2302:
	            b = this.InterpolantFactoryMethodSmooth
	         }
	         if (void 0 === b) {
	            b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
	            if (void 0 === this.createInterpolant) if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
	            else throw Error(b);
	            console.warn(b)
	         } else this.createInterpolant = b
	      },
	      getInterpolation: function() {
	         switch (this.createInterpolant) {
	         case this.InterpolantFactoryMethodDiscrete:
	            return 2300;
	         case this.InterpolantFactoryMethodLinear:
	            return 2301;
	         case this.InterpolantFactoryMethodSmooth:
	            return 2302
	         }
	      },
	      getValueSize: function() {
	         return this.values.length / this.times.length
	      },
	      shift: function(a) {
	         if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
	         return this
	      },
	      scale: function(a) {
	         if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
	         return this
	      },
	      trim: function(a, b) {
	         for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;)++e;
	         for (; - 1 !== f && c[f] > b;)--f;
	         ++f;
	         if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), d = this.getValueSize(), this.times = va.arraySlice(c, e, f), this.values = va.arraySlice(this.values, e * d, f * d);
	         return this
	      },
	      validate: function() {
	         var a = !0,
	            b = this.getValueSize();
	         0 !== b - Math.floor(b) && (console.error("invalid value size in track", this), a = !1);
	         var c = this.times,
	            b = this.values,
	            d = c.length;
	         0 === d && (console.error("track is empty", this), a = !1);
	         for (var e = null, f = 0; f !== d; f++) {
	            var g = c[f];
	            if ("number" === typeof g && isNaN(g)) {
	               console.error("time is not a valid number", this, f, g);
	               a = !1;
	               break
	            }
	            if (null !== e && e > g) {
	               console.error("out of order keys", this, f, g, e);
	               a = !1;
	               break
	            }
	            e = g
	         }
	         if (void 0 !== b && va.isTypedArray(b)) for (f = 0, c = b.length; f !== c; ++f) if (d = b[f], isNaN(d)) {
	            console.error("value is not a valid number", this, f, d);
	            a = !1;
	            break
	         }
	         return a
	      },
	      optimize: function() {
	         for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) {
	            var h = !1,
	               k = a[g];
	            if (k !== a[g + 1] && (1 !== g || k !== k[0])) if (d) h = !0;
	            else for (var m = g * c, l = m - c, q = m + c, k = 0; k !== c; ++k) {
	               var n = b[m + k];
	               if (n !== b[l + k] || n !== b[q + k]) {
	                  h = !0;
	                  break
	               }
	            }
	            if (h) {
	               if (g !== e) for (a[e] = a[g], h = g * c, m = e * c, k = 0; k !== c; ++k) b[m + k] = b[h + k];
	               ++e
	            }
	         }
	         if (0 < f) {
	            a[e] = a[f];
	            h = f * c;
	            m = e * c;
	            for (k = 0; k !== c; ++k) b[m + k] = b[h + k];
	            ++e
	         }
	         e !== a.length && (this.times = va.arraySlice(a, 0, e), this.values = va.arraySlice(b, 0, e * c));
	         return this
	      }
	   };
	   ec.prototype = Object.assign(Object.create(Ya), {
	      constructor: ec,
	      ValueTypeName: "vector"
	   });
	   Dd.prototype = Object.assign(Object.create(Da.prototype), {
	      constructor: Dd,
	      interpolate_: function(a, b, c, d) {
	         var e = this.resultBuffer,
	            f = this.sampleValues,
	            g = this.valueSize;
	         a *= g;
	         b = (c - b) / (d - b);
	         for (c = a + g; a !== c; a += 4) qa.slerpFlat(e, 0, f, a - g, f, a, b);
	         return e
	      }
	   });
	   Xc.prototype = Object.assign(Object.create(Ya), {
	      constructor: Xc,
	      ValueTypeName: "quaternion",
	      DefaultInterpolation: 2301,
	      InterpolantFactoryMethodLinear: function(a) {
	         return new Dd(this.times, this.values, this.getValueSize(), a)
	      },
	      InterpolantFactoryMethodSmooth: void 0
	   });
	   fc.prototype = Object.assign(Object.create(Ya), {
	      constructor: fc,
	      ValueTypeName: "number"
	   });
	   Ed.prototype = Object.assign(Object.create(Ya), {
	      constructor: Ed,
	      ValueTypeName: "string",
	      ValueBufferType: Array,
	      DefaultInterpolation: 2300,
	      InterpolantFactoryMethodLinear: void 0,
	      InterpolantFactoryMethodSmooth: void 0
	   });
	   Fd.prototype = Object.assign(Object.create(Ya), {
	      constructor: Fd,
	      ValueTypeName: "bool",
	      ValueBufferType: Array,
	      DefaultInterpolation: 2300,
	      InterpolantFactoryMethodLinear: void 0,
	      InterpolantFactoryMethodSmooth: void 0
	   });
	   Gd.prototype = Object.assign(Object.create(Ya), {
	      constructor: Gd,
	      ValueTypeName: "color"
	   });
	   wb.prototype = Ya;
	   Ya.constructor = wb;
	   Object.assign(wb, {
	      parse: function(a) {
	         if (void 0 === a.type) throw Error("track type undefined, can not parse");
	         var b = wb._getTrackTypeForValueTypeName(a.type);
	         if (void 0 === a.times) {
	            var c = [],
	               d = [];
	            va.flattenJSON(a.keys, c, d, "value");
	            a.times = c;
	            a.values = d
	         }
	         return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
	      },
	      toJSON: function(a) {
	         var b = a.constructor;
	         if (void 0 !== b.toJSON) b = b.toJSON(a);
	         else {
	            var b = {
	               name: a.name,
	               times: va.convertArray(a.times, Array),
	               values: va.convertArray(a.values, Array)
	            },
	               c = a.getInterpolation();
	            c !== a.DefaultInterpolation && (b.interpolation = c)
	         }
	         b.type = a.ValueTypeName;
	         return b
	      },
	      _getTrackTypeForValueTypeName: function(a) {
	         switch (a.toLowerCase()) {
	         case "scalar":
	         case "double":
	         case "float":
	         case "number":
	         case "integer":
	            return fc;
	         case "vector":
	         case "vector2":
	         case "vector3":
	         case "vector4":
	            return ec;
	         case "color":
	            return Gd;
	         case "quaternion":
	            return Xc;
	         case "bool":
	         case "boolean":
	            return Fd;
	         case "string":
	            return Ed
	         }
	         throw Error("Unsupported typeName: " + a)
	      }
	   });
	   Object.assign(Ba, {
	      parse: function(a) {
	         for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(wb.parse(c[e]).scale(d));
	         return new Ba(a.name, a.duration, b)
	      },
	      toJSON: function(a) {
	         var b = [],
	            c = a.tracks;
	         a = {
	            name: a.name,
	            duration: a.duration,
	            tracks: b
	         };
	         for (var d = 0, e = c.length; d !== e; ++d) b.push(wb.toJSON(c[d]));
	         return a
	      },
	      CreateFromMorphTargetSequence: function(a, b, c, d) {
	         for (var e = b.length, f = [], g = 0; g < e; g++) {
	            var h = [],
	               k = [];
	            h.push((g + e - 1) % e, g, (g + 1) % e);
	            k.push(0, 1, 0);
	            var m = va.getKeyframeOrder(h),
	               h = va.sortedArray(h, 1, m),
	               k = va.sortedArray(k, 1, m);
	            d || 0 !== h[0] || (h.push(e), k.push(k[0]));
	            f.push(new fc(".morphTargetInfluences[" + b[g].name + "]", h, k).scale(1 / c))
	         }
	         return new Ba(a, -1, f)
	      },
	      findByName: function(a, b) {
	         var c = a;
	         Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
	         for (var d = 0; d < c.length; d++) if (c[d].name === b) return c[d];
	         return null
	      },
	      CreateClipsFromMorphTargetSequences: function(a, b, c) {
	         for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
	            var h = a[f],
	               k = h.name.match(e);
	            if (k && 1 < k.length) {
	               var m = k[1];
	               (k = d[m]) || (d[m] = k = []);
	               k.push(h)
	            }
	         }
	         a = [];
	         for (m in d) a.push(Ba.CreateFromMorphTargetSequence(m, d[m], b, c));
	         return a
	      },
	      parseAnimation: function(a, b) {
	         if (!a) return console.error("  no animation in JSONLoader data"), null;
	         for (var c = function(a, b, c, d, e) {
	               if (0 !== c.length) {
	                  var f = [],
	                     g = [];
	                  va.flattenJSON(c, f, g, d);
	                  0 !== f.length && e.push(new a(b, f, g))
	               }
	            }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30, h = a.hierarchy || [], k = 0; k < h.length; k++) {
	            var m = h[k].keys;
	            if (m && 0 !== m.length) if (m[0].morphTargets) {
	               for (var f = {}, l = 0; l < m.length; l++) if (m[l].morphTargets) for (var q = 0; q < m[l].morphTargets.length; q++) f[m[l].morphTargets[q]] = -1;
	               for (var n in f) {
	                  for (var p = [], z = [], q = 0; q !== m[l].morphTargets.length; ++q) {
	                     var t = m[l];
	                     p.push(t.time);
	                     z.push(t.morphTarget === n ? 1 : 0)
	                  }
	                  d.push(new fc(".morphTargetInfluence[" + n + "]", p, z))
	               }
	               f = f.length * (g || 1)
	            } else l = ".bones[" + b[k].name + "]", c(ec, l + ".position", m, "pos", d), c(Xc, l + ".quaternion", m, "rot", d), c(ec, l + ".scale", m, "scl", d)
	         }
	         return 0 === d.length ? null : new Ba(e, f, d)
	      }
	   });
	   Object.assign(Ba.prototype, {
	      resetDuration: function() {
	         for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) var d = this.tracks[b],
	            a = Math.max(a, d.times[d.times.length - 1]);
	         this.duration = a
	      },
	      trim: function() {
	         for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
	         return this
	      },
	      optimize: function() {
	         for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
	         return this
	      }
	   });
	   Object.assign(Hd.prototype, {
	      load: function(a, b, c, d) {
	         var e = this,
	            f = new ua(e.manager);
	         f.setResponseType("json");
	         f.load(a, function(a) {
	            b(e.parse(a))
	         }, c, d)
	      },
	      setTextures: function(a) {
	         this.textures = a
	      },
	      parse: function(a) {
	         function b(a) {
	            void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
	            return c[a]
	         }
	         var c = this.textures,
	            d = new lg[a.type];
	         void 0 !== a.uuid && (d.uuid = a.uuid);
	         void 0 !== a.name && (d.name = a.name);
	         void 0 !== a.color && d.color.setHex(a.color);
	         void 0 !== a.roughness && (d.roughness = a.roughness);
	         void 0 !== a.metalness && (d.metalness = a.metalness);
	         void 0 !== a.emissive && d.emissive.setHex(a.emissive);
	         void 0 !== a.specular && d.specular.setHex(a.specular);
	         void 0 !== a.shininess && (d.shininess = a.shininess);
	         void 0 !== a.clearCoat && (d.clearCoat = a.clearCoat);
	         void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness);
	         void 0 !== a.uniforms && (d.uniforms = a.uniforms);
	         void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
	         void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
	         void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
	         void 0 !== a.fog && (d.fog = a.fog);
	         void 0 !== a.shading && (d.shading = a.shading);
	         void 0 !== a.blending && (d.blending = a.blending);
	         void 0 !== a.side && (d.side = a.side);
	         void 0 !== a.opacity && (d.opacity = a.opacity);
	         void 0 !== a.transparent && (d.transparent = a.transparent);
	         void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
	         void 0 !== a.depthTest && (d.depthTest = a.depthTest);
	         void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
	         void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
	         void 0 !== a.wireframe && (d.wireframe = a.wireframe);
	         void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth);
	         void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap);
	         void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin);
	         void 0 !== a.skinning && (d.skinning = a.skinning);
	         void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets);
	         void 0 !== a.size && (d.size = a.size);
	         void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
	         void 0 !== a.map && (d.map = b(a.map));
	         void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0);
	         void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
	         void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
	         void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
	         if (void 0 !== a.normalScale) {
	            var e = a.normalScale;
	            !1 === Array.isArray(e) && (e = [e, e]);
	            d.normalScale = (new D).fromArray(e)
	         }
	         void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap));
	         void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale);
	         void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias);
	         void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
	         void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
	         void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap));
	         void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity);
	         void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
	         void 0 !== a.envMap && (d.envMap = b(a.envMap));
	         void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
	         void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
	         void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity);
	         void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
	         void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
	         void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap));
	         return d
	      }
	   });
	   Object.assign(be.prototype, {
	      load: function(a, b, c, d) {
	         var e = this,
	            f = new ua(e.manager);
	         f.setResponseType("json");
	         f.load(a, function(a) {
	            b(e.parse(a))
	         }, c, d)
	      },
	      parse: function(a) {
	         var b = new I,
	            c = a.data.index;
	         void 0 !== c && (c = new ff[c.type](c.array), b.setIndex(new L(c, 1)));
	         var d = a.data.attributes,
	            e;
	         for (e in d) {
	            var f = d[e],
	               c = new ff[f.type](f.array);
	            b.addAttribute(e, new L(c, f.itemSize, f.normalized))
	         }
	         e = a.data.groups || a.data.drawcalls || a.data.offsets;
	         if (void 0 !== e) for (c = 0, d = e.length; c !== d; ++c) f = e[c], b.addGroup(f.start, f.count, f.materialIndex);
	         a = a.data.boundingSphere;
	         void 0 !== a && (e = new p, void 0 !== a.center && e.fromArray(a.center), b.boundingSphere = new Ga(e, a.radius));
	         return b
	      }
	   });
	   var ff = {
	      Int8Array: Int8Array,
	      Uint8Array: Uint8Array,
	      Uint8ClampedArray: Uint8ClampedArray,
	      Int16Array: Int16Array,
	      Uint16Array: Uint16Array,
	      Int32Array: Int32Array,
	      Uint32Array: Uint32Array,
	      Float32Array: Float32Array,
	      Float64Array: Float64Array
	   };
	   gc.Handlers = {
	      handlers: [],
	      add: function(a, b) {
	         this.handlers.push(a, b)
	      },
	      get: function(a) {
	         for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
	            var e = b[c + 1];
	            if (b[c].test(a)) return e
	         }
	         return null
	      }
	   };
	   Object.assign(gc.prototype, {
	      crossOrigin: void 0,
	      extractUrlBase: function(a) {
	         a = a.split("/");
	         if (1 === a.length) return "./";
	         a.pop();
	         return a.join("/") + "/"
	      },
	      initMaterials: function(a, b, c) {
	         for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
	         return d
	      },
	      createMaterial: function() {
	         var a = {
	            NoBlending: 0,
	            NormalBlending: 1,
	            AdditiveBlending: 2,
	            SubtractiveBlending: 3,
	            MultiplyBlending: 4,
	            CustomBlending: 5
	         },
	            b = new H,
	            c = new sd,
	            d = new Hd;
	         return function(e, f, g) {
	            function h(a, b, d, e, h) {
	               a = f + a;
	               var m = gc.Handlers.get(a);
	               null !== m ? a = m.load(a) : (c.setCrossOrigin(g), a = c.load(a));
	               void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1e3), 1 !== b[1] && (a.wrapT = 1e3));
	               void 0 !== d && a.offset.fromArray(d);
	               void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1e3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1e3), "mirror" === e[1] && (a.wrapT = 1002));
	               void 0 !== h && (a.anisotropy = h);
	               b = Y.generateUUID();
	               k[b] = a;
	               return b
	            }
	            var k = {},
	               m = {
	                  uuid: Y.generateUUID(),
	                  type: "MeshLambertMaterial"
	               },
	               l;
	            for (l in e) {
	               var q = e[l];
	               switch (l) {
	               case "DbgColor":
	               case "DbgIndex":
	               case "opticalDensity":
	               case "illumination":
	                  break;
	               case "DbgName":
	                  m.name = q;
	                  break;
	               case "blending":
	                  m.blending = a[q];
	                  break;
	               case "colorAmbient":
	               case "mapAmbient":
	                  console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
	                  break;
	               case "colorDiffuse":
	                  m.color = b.fromArray(q).getHex();
	                  break;
	               case "colorSpecular":
	                  m.specular = b.fromArray(q).getHex();
	                  break;
	               case "colorEmissive":
	                  m.emissive = b.fromArray(q).getHex();
	                  break;
	               case "specularCoef":
	                  m.shininess = q;
	                  break;
	               case "shading":
	                  "basic" === q.toLowerCase() && (m.type = "MeshBasicMaterial");
	                  "phong" === q.toLowerCase() && (m.type = "MeshPhongMaterial");
	                  "standard" === q.toLowerCase() && (m.type = "MeshStandardMaterial");
	                  break;
	               case "mapDiffuse":
	                  m.map = h(q, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
	                  break;
	               case "mapDiffuseRepeat":
	               case "mapDiffuseOffset":
	               case "mapDiffuseWrap":
	               case "mapDiffuseAnisotropy":
	                  break;
	               case "mapEmissive":
	                  m.emissiveMap = h(q, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
	                  break;
	               case "mapEmissiveRepeat":
	               case "mapEmissiveOffset":
	               case "mapEmissiveWrap":
	               case "mapEmissiveAnisotropy":
	                  break;
	               case "mapLight":
	                  m.lightMap = h(q, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
	                  break;
	               case "mapLightRepeat":
	               case "mapLightOffset":
	               case "mapLightWrap":
	               case "mapLightAnisotropy":
	                  break;
	               case "mapAO":
	                  m.aoMap = h(q, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
	                  break;
	               case "mapAORepeat":
	               case "mapAOOffset":
	               case "mapAOWrap":
	               case "mapAOAnisotropy":
	                  break;
	               case "mapBump":
	                  m.bumpMap = h(q, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
	                  break;
	               case "mapBumpScale":
	                  m.bumpScale = q;
	                  break;
	               case "mapBumpRepeat":
	               case "mapBumpOffset":
	               case "mapBumpWrap":
	               case "mapBumpAnisotropy":
	                  break;
	               case "mapNormal":
	                  m.normalMap = h(q, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
	                  break;
	               case "mapNormalFactor":
	                  m.normalScale = [q, q];
	                  break;
	               case "mapNormalRepeat":
	               case "mapNormalOffset":
	               case "mapNormalWrap":
	               case "mapNormalAnisotropy":
	                  break;
	               case "mapSpecular":
	                  m.specularMap = h(q, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
	                  break;
	               case "mapSpecularRepeat":
	               case "mapSpecularOffset":
	               case "mapSpecularWrap":
	               case "mapSpecularAnisotropy":
	                  break;
	               case "mapMetalness":
	                  m.metalnessMap = h(q, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
	                  break;
	               case "mapMetalnessRepeat":
	               case "mapMetalnessOffset":
	               case "mapMetalnessWrap":
	               case "mapMetalnessAnisotropy":
	                  break;
	               case "mapRoughness":
	                  m.roughnessMap = h(q, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
	                  break;
	               case "mapRoughnessRepeat":
	               case "mapRoughnessOffset":
	               case "mapRoughnessWrap":
	               case "mapRoughnessAnisotropy":
	                  break;
	               case "mapAlpha":
	                  m.alphaMap = h(q, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
	                  break;
	               case "mapAlphaRepeat":
	               case "mapAlphaOffset":
	               case "mapAlphaWrap":
	               case "mapAlphaAnisotropy":
	                  break;
	               case "flipSided":
	                  m.side = 1;
	                  break;
	               case "doubleSided":
	                  m.side = 2;
	                  break;
	               case "transparency":
	                  console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
	                  m.opacity = q;
	                  break;
	               case "depthTest":
	               case "depthWrite":
	               case "colorWrite":
	               case "opacity":
	               case "reflectivity":
	               case "transparent":
	               case "visible":
	               case "wireframe":
	                  m[l] = q;
	                  break;
	               case "vertexColors":
	                  !0 === q && (m.vertexColors = 2);
	                  "face" === q && (m.vertexColors = 1);
	                  break;
	               default:
	                  console.error("THREE.Loader.createMaterial: Unsupported", l, q)
	               }
	            }
	            "MeshBasicMaterial" === m.type && delete m.emissive;
	            "MeshPhongMaterial" !== m.type && delete m.specular;
	            1 > m.opacity && (m.transparent = !0);
	            d.setTextures(k);
	            return d.parse(m)
	         }
	      }()
	   });
	   Object.assign(ce.prototype, {
	      load: function(a, b, c, d) {
	         var e = this,
	            f = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : gc.prototype.extractUrlBase(a),
	            g = new ua(this.manager);
	         g.setResponseType("json");
	         g.setWithCredentials(this.withCredentials);
	         g.load(a, function(c) {
	            var d = c.metadata;
	            if (void 0 !== d && (d = d.type, void 0 !== d)) {
	               if ("object" === d.toLowerCase()) {
	                  console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
	                  return
	               }
	               if ("scene" === d.toLowerCase()) {
	                  console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.");
	                  return
	               }
	            }
	            c = e.parse(c, f);
	            b(c.geometry, c.materials)
	         }, c, d)
	      },
	      setTexturePath: function(a) {
	         this.texturePath = a
	      },
	      parse: function() {
	         return function(a, b) {
	            void 0 !== a.data && (a = a.data);
	            a.scale = void 0 !== a.scale ? 1 / a.scale : 1;
	            var c = new M,
	               d = a,
	               e, f, g, h, k, m, l, q, n, r, z, t, y, x, v = d.faces;
	            n = d.vertices;
	            var G = d.normals,
	               w = d.colors;
	            m = d.scale;
	            var B = 0;
	            if (void 0 !== d.uvs) {
	               for (e = 0; e < d.uvs.length; e++) d.uvs[e].length && B++;
	               for (e = 0; e < B; e++) c.faceVertexUvs[e] = []
	            }
	            h = 0;
	            for (k = n.length; h < k;) e = new p, e.x = n[h++] * m, e.y = n[h++] * m, e.z = n[h++] * m, c.vertices.push(e);
	            h = 0;
	            for (k = v.length; h < k;) if (n = v[h++], r = n & 1, g = n & 2, e = n & 8, l = n & 16, z = n & 32, m = n & 64, n &= 128, r) {
	               r = new Va;
	               r.a = v[h];
	               r.b = v[h + 1];
	               r.c = v[h + 3];
	               t = new Va;
	               t.a = v[h + 1];
	               t.b = v[h + 2];
	               t.c = v[h + 3];
	               h += 4;
	               g && (g = v[h++], r.materialIndex = g, t.materialIndex = g);
	               g = c.faces.length;
	               if (e) for (e = 0; e < B; e++) for (y = d.uvs[e], c.faceVertexUvs[e][g] = [], c.faceVertexUvs[e][g + 1] = [], f = 0; 4 > f; f++) q = v[h++], x = y[2 * q], q = y[2 * q + 1], x = new D(x, q), 2 !== f && c.faceVertexUvs[e][g].push(x), 0 !== f && c.faceVertexUvs[e][g + 1].push(x);
	               l && (l = 3 * v[h++], r.normal.set(G[l++], G[l++], G[l]), t.normal.copy(r.normal));
	               if (z) for (e = 0; 4 > e; e++) l = 3 * v[h++], z = new p(G[l++], G[l++], G[l]), 2 !== e && r.vertexNormals.push(z), 0 !== e && t.vertexNormals.push(z);
	               m && (m = v[h++], m = w[m], r.color.setHex(m), t.color.setHex(m));
	               if (n) for (e = 0; 4 > e; e++) m = v[h++], m = w[m], 2 !== e && r.vertexColors.push(new H(m)), 0 !== e && t.vertexColors.push(new H(m));
	               c.faces.push(r);
	               c.faces.push(t)
	            } else {
	               r = new Va;
	               r.a = v[h++];
	               r.b = v[h++];
	               r.c = v[h++];
	               g && (g = v[h++], r.materialIndex = g);
	               g = c.faces.length;
	               if (e) for (e = 0; e < B; e++) for (y = d.uvs[e], c.faceVertexUvs[e][g] = [], f = 0; 3 > f; f++) q = v[h++], x = y[2 * q], q = y[2 * q + 1], x = new D(x, q), c.faceVertexUvs[e][g].push(x);
	               l && (l = 3 * v[h++], r.normal.set(G[l++], G[l++], G[l]));
	               if (z) for (e = 0; 3 > e; e++) l = 3 * v[h++], z = new p(G[l++], G[l++], G[l]), r.vertexNormals.push(z);
	               m && (m = v[h++], r.color.setHex(w[m]));
	               if (n) for (e = 0; 3 > e; e++) m = v[h++], r.vertexColors.push(new H(w[m]));
	               c.faces.push(r)
	            }
	            d = a;
	            h = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2;
	            if (d.skinWeights) for (k = 0, v = d.skinWeights.length; k < v; k += h) c.skinWeights.push(new ga(d.skinWeights[k], 1 < h ? d.skinWeights[k + 1] : 0, 2 < h ? d.skinWeights[k + 2] : 0, 3 < h ? d.skinWeights[k + 3] : 0));
	            if (d.skinIndices) for (k = 0, v = d.skinIndices.length; k < v; k += h) c.skinIndices.push(new ga(d.skinIndices[k], 1 < h ? d.skinIndices[k + 1] : 0, 2 < h ? d.skinIndices[k + 2] : 0, 3 < h ? d.skinIndices[k + 3] : 0));
	            c.bones = d.bones;
	            c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match.");
	            k = a;
	            v = k.scale;
	            if (void 0 !== k.morphTargets) for (d = 0, h = k.morphTargets.length; d < h; d++) for (c.morphTargets[d] = {}, c.morphTargets[d].name = k.morphTargets[d].name, c.morphTargets[d].vertices = [], G = c.morphTargets[d].vertices, w = k.morphTargets[d].vertices, B = 0, n = w.length; B < n; B += 3) m = new p, m.x = w[B] * v, m.y = w[B + 1] * v, m.z = w[B + 2] * v, G.push(m);
	            if (void 0 !== k.morphColors && 0 < k.morphColors.length) for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), v = c.faces, k = k.morphColors[0].colors, d = 0, h = v.length; d < h; d++) v[d].color.fromArray(k, 3 * d);
	            k = a;
	            d = [];
	            h = [];
	            void 0 !== k.animation && h.push(k.animation);
	            void 0 !== k.animations && (k.animations.length ? h = h.concat(k.animations) : h.push(k.animations));
	            for (k = 0; k < h.length; k++)(v = Ba.parseAnimation(h[k], c.bones)) && d.push(v);
	            c.morphTargets && (h = Ba.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), d = d.concat(h));
	            0 < d.length && (c.animations = d);
	            c.computeFaceNormals();
	            c.computeBoundingSphere();
	            if (void 0 === a.materials || 0 === a.materials.length) return {
	               geometry: c
	            };
	            d = gc.prototype.initMaterials(a.materials, b, this.crossOrigin);
	            return {
	               geometry: c,
	               materials: d
	            }
	         }
	      }()
	   });
	   Object.assign(Re.prototype, {
	      load: function(a, b, c, d) {
	         "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
	         var e = this;
	         new ua(e.manager).load(a, function(c) {
	            var g = null;
	            try {
	               g = JSON.parse(c)
	            } catch (h) {
	               void 0 !== d && d(h);
	               console.error("THREE:ObjectLoader: Can't parse " + a + ".", h.message);
	               return
	            }
	            c = g.metadata;
	            void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(g, b)
	         }, c, d)
	      },
	      setTexturePath: function(a) {
	         this.texturePath = a
	      },
	      setCrossOrigin: function(a) {
	         this.crossOrigin = a
	      },
	      parse: function(a, b) {
	         var c = this.parseGeometries(a.geometries),
	            d = this.parseImages(a.images, function() {
	               void 0 !== b && b(e)
	            }),
	            d = this.parseTextures(a.textures, d),
	            d = this.parseMaterials(a.materials, d),
	            e = this.parseObject(a.object, c, d);
	         a.animations && (e.animations = this.parseAnimations(a.animations));
	         void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
	         return e
	      },
	      parseGeometries: function(a) {
	         var b = {};
	         if (void 0 !== a) for (var c = new ce, d = new be, e = 0, f = a.length; e < f; e++) {
	            var g, h = a[e];
	            switch (h.type) {
	            case "PlaneGeometry":
	            case "PlaneBufferGeometry":
	               g = new Ma[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
	               break;
	            case "BoxGeometry":
	            case "BoxBufferGeometry":
	            case "CubeGeometry":
	               g = new Ma[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
	               break;
	            case "CircleGeometry":
	            case "CircleBufferGeometry":
	               g = new Ma[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
	               break;
	            case "CylinderGeometry":
	            case "CylinderBufferGeometry":
	               g = new Ma[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
	               break;
	            case "ConeGeometry":
	            case "ConeBufferGeometry":
	               g = new Ma[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
	               break;
	            case "SphereGeometry":
	            case "SphereBufferGeometry":
	               g = new Ma[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
	               break;
	            case "DodecahedronGeometry":
	            case "IcosahedronGeometry":
	            case "OctahedronGeometry":
	            case "TetrahedronGeometry":
	               g = new Ma[h.type](h.radius, h.detail);
	               break;
	            case "RingGeometry":
	            case "RingBufferGeometry":
	               g = new Ma[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
	               break;
	            case "TorusGeometry":
	            case "TorusBufferGeometry":
	               g = new Ma[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
	               break;
	            case "TorusKnotGeometry":
	            case "TorusKnotBufferGeometry":
	               g = new Ma[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
	               break;
	            case "LatheGeometry":
	            case "LatheBufferGeometry":
	               g = new Ma[h.type](h.points, h.segments, h.phiStart, h.phiLength);
	               break;
	            case "BufferGeometry":
	               g = d.parse(h);
	               break;
	            case "Geometry":
	               g = c.parse(h, this.texturePath).geometry;
	               break;
	            default:
	               console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
	               continue
	            }
	            g.uuid = h.uuid;
	            void 0 !== h.name && (g.name = h.name);
	            b[h.uuid] = g
	         }
	         return b
	      },
	      parseMaterials: function(a, b) {
	         var c = {};
	         if (void 0 !== a) {
	            var d = new Hd;
	            d.setTextures(b);
	            for (var e = 0, f = a.length; e < f; e++) {
	               var g = a[e];
	               if ("MultiMaterial" === g.type) {
	                  for (var h = [], k = 0; k < g.materials.length; k++) h.push(d.parse(g.materials[k]));
	                  c[g.uuid] = h
	               } else c[g.uuid] = d.parse(g)
	            }
	         }
	         return c
	      },
	      parseAnimations: function(a) {
	         for (var b = [], c = 0; c < a.length; c++) {
	            var d = Ba.parse(a[c]);
	            b.push(d)
	         }
	         return b
	      },
	      parseImages: function(a, b) {
	         function c(a) {
	            d.manager.itemStart(a);
	            return g.load(a, function() {
	               d.manager.itemEnd(a)
	            }, void 0, function() {
	               d.manager.itemEnd(a);
	               d.manager.itemError(a)
	            })
	         }
	         var d = this,
	            e = {};
	         if (void 0 !== a && 0 < a.length) {
	            var f = new Zd(b),
	               g = new Vc(f);
	            g.setCrossOrigin(this.crossOrigin);
	            for (var f = 0, h = a.length; f < h; f++) {
	               var k = a[f],
	                  l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(k.url) ? k.url : d.texturePath + k.url;
	               e[k.uuid] = c(l)
	            }
	         }
	         return e
	      },
	      parseTextures: function(a, b) {
	         function c(a, b) {
	            if ("number" === typeof a) return a;
	            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
	            return b[a]
	         }
	         var d = {};
	         if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) {
	            var g = a[e];
	            void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid);
	            void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
	            var h = new X(b[g.image]);
	            h.needsUpdate = !0;
	            h.uuid = g.uuid;
	            void 0 !== g.name && (h.name = g.name);
	            void 0 !== g.mapping && (h.mapping = c(g.mapping, mg));
	            void 0 !== g.offset && h.offset.fromArray(g.offset);
	            void 0 !== g.repeat && h.repeat.fromArray(g.repeat);
	            void 0 !== g.wrap && (h.wrapS = c(g.wrap[0], gf), h.wrapT = c(g.wrap[1], gf));
	            void 0 !== g.minFilter && (h.minFilter = c(g.minFilter, hf));
	            void 0 !== g.magFilter && (h.magFilter = c(g.magFilter, hf));
	            void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy);
	            void 0 !== g.flipY && (h.flipY = g.flipY);
	            d[g.uuid] = h
	         }
	         return d
	      },
	      parseObject: function() {
	         var a = new J;
	         return function(b, c, d) {
	            function e(a) {
	               void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
	               return c[a]
	            }
	            function f(a) {
	               if (void 0 !== a) {
	                  if (Array.isArray(a)) {
	                     for (var b = [], c = 0, e = a.length; c < e; c++) {
	                        var f = a[c];
	                        void 0 === d[f] && console.warn("THREE.ObjectLoader: Undefined material", f);
	                        b.push(d[f])
	                     }
	                     return b
	                  }
	                  void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
	                  return d[a]
	               }
	            }
	            var g;
	            switch (b.type) {
	            case "Scene":
	               g = new md;
	               void 0 !== b.background && Number.isInteger(b.background) && (g.background = new H(b.background));
	               void 0 !== b.fog && ("Fog" === b.fog.type ? g.fog = new Lb(b.fog.color, b.fog.near, b.fog.far) : "FogExp2" === b.fog.type && (g.fog = new Kb(b.fog.color, b.fog.density)));
	               break;
	            case "PerspectiveCamera":
	               g = new xa(b.fov, b.aspect, b.near, b.far);
	               void 0 !== b.focus && (g.focus = b.focus);
	               void 0 !== b.zoom && (g.zoom = b.zoom);
	               void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge);
	               void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset);
	               void 0 !== b.view && (g.view = Object.assign({}, b.view));
	               break;
	            case "OrthographicCamera":
	               g = new Jb(b.left, b.right, b.top, b.bottom, b.near, b.far);
	               break;
	            case "AmbientLight":
	               g = new zd(b.color, b.intensity);
	               break;
	            case "DirectionalLight":
	               g = new yd(b.color, b.intensity);
	               break;
	            case "PointLight":
	               g = new wd(b.color, b.intensity, b.distance, b.decay);
	               break;
	            case "RectAreaLight":
	               g = new Ad(b.color, b.intensity, b.width, b.height);
	               break;
	            case "SpotLight":
	               g = new vd(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
	               break;
	            case "HemisphereLight":
	               g = new td(b.color, b.groundColor, b.intensity);
	               break;
	            case "SkinnedMesh":
	               console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
	            case "Mesh":
	               g = e(b.geometry);
	               var h = f(b.material);
	               g = g.bones && 0 < g.bones.length ? new od(g, h) : new Ca(g, h);
	               break;
	            case "LOD":
	               g = new Bc;
	               break;
	            case "Line":
	               g = new ya(e(b.geometry), f(b.material), b.mode);
	               break;
	            case "LineLoop":
	               g = new pd(e(b.geometry), f(b.material));
	               break;
	            case "LineSegments":
	               g = new da(e(b.geometry), f(b.material));
	               break;
	            case "PointCloud":
	            case "Points":
	               g = new Mb(e(b.geometry), f(b.material));
	               break;
	            case "Sprite":
	               g = new Ac(f(b.material));
	               break;
	            case "Group":
	               g = new Dc;
	               break;
	            default:
	               g = new B
	            }
	            g.uuid = b.uuid;
	            void 0 !== b.name && (g.name = b.name);
	            void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.quaternion && g.quaternion.fromArray(b.quaternion), void 0 !== b.scale && g.scale.fromArray(b.scale));
	            void 0 !== b.castShadow && (g.castShadow = b.castShadow);
	            void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow);
	            b.shadow && (void 0 !== b.shadow.bias && (g.shadow.bias = b.shadow.bias), void 0 !== b.shadow.radius && (g.shadow.radius = b.shadow.radius), void 0 !== b.shadow.mapSize && g.shadow.mapSize.fromArray(b.shadow.mapSize), void 0 !== b.shadow.camera && (g.shadow.camera = this.parseObject(b.shadow.camera)));
	            void 0 !== b.visible && (g.visible = b.visible);
	            void 0 !== b.userData && (g.userData = b.userData);
	            if (void 0 !== b.children) for (var k in b.children) g.add(this.parseObject(b.children[k], c, d));
	            if ("LOD" === b.type) for (b = b.levels, h = 0; h < b.length; h++) {
	               var l = b[h];
	               k = g.getObjectByProperty("uuid", l.object);
	               void 0 !== k && g.addLevel(k, l.distance)
	            }
	            return g
	         }
	      }()
	   });
	   var mg = {
	      UVMapping: 300,
	      CubeReflectionMapping: 301,
	      CubeRefractionMapping: 302,
	      EquirectangularReflectionMapping: 303,
	      EquirectangularRefractionMapping: 304,
	      SphericalReflectionMapping: 305,
	      CubeUVReflectionMapping: 306,
	      CubeUVRefractionMapping: 307
	   },
	      gf = {
	         RepeatWrapping: 1e3,
	         ClampToEdgeWrapping: 1001,
	         MirroredRepeatWrapping: 1002
	      },
	      hf = {
	         NearestFilter: 1003,
	         NearestMipMapNearestFilter: 1004,
	         NearestMipMapLinearFilter: 1005,
	         LinearFilter: 1006,
	         LinearMipMapNearestFilter: 1007,
	         LinearMipMapLinearFilter: 1008
	      };
	   Object.assign(na.prototype, {
	      getPoint: function() {
	         console.warn("THREE.Curve: .getPoint() not implemented.");
	         return null
	      },
	      getPointAt: function(a) {
	         a = this.getUtoTmapping(a);
	         return this.getPoint(a)
	      },
	      getPoints: function(a) {
	         void 0 === a && (a = 5);
	         for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
	         return b
	      },
	      getSpacedPoints: function(a) {
	         void 0 === a && (a = 5);
	         for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
	         return b
	      },
	      getLength: function() {
	         var a = this.getLengths();
	         return a[a.length - 1]
	      },
	      getLengths: function(a) {
	         void 0 === a && (a = this.arcLengthDivisions);
	         if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
	         this.needsUpdate = !1;
	         var b = [],
	            c, d = this.getPoint(0),
	            e, f = 0;
	         b.push(0);
	         for (e = 1; e <= a; e++) c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
	         return this.cacheArcLengths = b
	      },
	      updateArcLengths: function() {
	         this.needsUpdate = !0;
	         this.getLengths()
	      },
	      getUtoTmapping: function(a, b) {
	         var c = this.getLengths(),
	            d, e = c.length,
	            f;
	         f = b ? b : a * c[e - 1];
	         for (var g = 0, h = e - 1, k; g <= h;) if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k) g = d + 1;
	         else if (0 < k) h = d - 1;
	         else {
	            h = d;
	            break
	         }
	         d = h;
	         if (c[d] === f) return d / (e - 1);
	         g = c[d];
	         return (d + (f - g) / (c[d + 1] - g)) / (e - 1)
	      },
	      getTangent: function(a) {
	         var b = a - 1e-4;
	         a += 1e-4;
	         0 > b && (b = 0);
	         1 < a && (a = 1);
	         b = this.getPoint(b);
	         return this.getPoint(a).clone().sub(b).normalize()
	      },
	      getTangentAt: function(a) {
	         a = this.getUtoTmapping(a);
	         return this.getTangent(a)
	      },
	      computeFrenetFrames: function(a, b) {
	         var c = new p,
	            d = [],
	            e = [],
	            f = [],
	            g = new p,
	            h = new J,
	            k, l;
	         for (k = 0; k <= a; k++) l = k / a, d[k] = this.getTangentAt(l), d[k].normalize();
	         e[0] = new p;
	         f[0] = new p;
	         k = Number.MAX_VALUE;
	         l = Math.abs(d[0].x);
	         var u = Math.abs(d[0].y),
	            q = Math.abs(d[0].z);
	         l <= k && (k = l, c.set(1, 0, 0));
	         u <= k && (k = u, c.set(0, 1, 0));
	         q <= k && c.set(0, 0, 1);
	         g.crossVectors(d[0], c).normalize();
	         e[0].crossVectors(d[0], g);
	         f[0].crossVectors(d[0], e[0]);
	         for (k = 1; k <= a; k++) e[k] = e[k - 1].clone(), f[k] = f[k - 1].clone(), g.crossVectors(d[k - 1], d[k]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(Y.clamp(d[k - 1].dot(d[k]), -1, 1)), e[k].applyMatrix4(h.makeRotationAxis(g, c))), f[k].crossVectors(d[k], e[k]);
	         if (!0 === b) for (c = Math.acos(Y.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), k = 1; k <= a; k++) e[k].applyMatrix4(h.makeRotationAxis(d[k], c * k)), f[k].crossVectors(d[k], e[k]);
	         return {
	            tangents: d,
	            normals: e,
	            binormals: f
	         }
	      }
	   });
	   Sa.prototype = Object.create(na.prototype);
	   Sa.prototype.constructor = Sa;
	   Sa.prototype.isLineCurve = !0;
	   Sa.prototype.getPoint = function(a) {
	      if (1 === a) return this.v2.clone();
	      var b = this.v2.clone().sub(this.v1);
	      b.multiplyScalar(a).add(this.v1);
	      return b
	   };
	   Sa.prototype.getPointAt = function(a) {
	      return this.getPoint(a)
	   };
	   Sa.prototype.getTangent = function(a) {
	      return this.v2.clone().sub(this.v1).normalize()
	   };
	   Yc.prototype = Object.assign(Object.create(na.prototype), {
	      constructor: Yc,
	      add: function(a) {
	         this.curves.push(a)
	      },
	      closePath: function() {
	         var a = this.curves[0].getPoint(0),
	            b = this.curves[this.curves.length - 1].getPoint(1);
	         a.equals(b) || this.curves.push(new Sa(b, a))
	      },
	      getPoint: function(a) {
	         var b = a * this.getLength(),
	            c = this.getCurveLengths();
	         for (a = 0; a < c.length;) {
	            if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
	            a++
	         }
	         return null
	      },
	      getLength: function() {
	         var a = this.getCurveLengths();
	         return a[a.length - 1]
	      },
	      updateArcLengths: function() {
	         this.needsUpdate = !0;
	         this.cacheLengths = null;
	         this.getCurveLengths()
	      },
	      getCurveLengths: function() {
	         if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
	         for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
	         return this.cacheLengths = a
	      },
	      getSpacedPoints: function(a) {
	         void 0 === a && (a = 40);
	         for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
	         this.autoClose && b.push(b[0]);
	         return b
	      },
	      getPoints: function(a) {
	         a = a || 12;
	         for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) for (var f = e[d], f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a), g = 0; g < f.length; g++) {
	            var h = f[g];
	            c && c.equals(h) || (b.push(h), c = h)
	         }
	         this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
	         return b
	      },
	      createPointsGeometry: function(a) {
	         a = this.getPoints(a);
	         return this.createGeometry(a)
	      },
	      createSpacedPointsGeometry: function(a) {
	         a = this.getSpacedPoints(a);
	         return this.createGeometry(a)
	      },
	      createGeometry: function(a) {
	         for (var b = new M, c = 0, d = a.length; c < d; c++) {
	            var e = a[c];
	            b.vertices.push(new p(e.x, e.y, e.z || 0))
	         }
	         return b
	      }
	   });
	   Xa.prototype = Object.create(na.prototype);
	   Xa.prototype.constructor = Xa;
	   Xa.prototype.isEllipseCurve = !0;
	   Xa.prototype.getPoint = function(a) {
	      for (var b = 2 * Math.PI, c = this.aEndAngle - this.aStartAngle, d = Math.abs(c) < Number.EPSILON; 0 > c;) c += b;
	      for (; c > b;) c -= b;
	      c < Number.EPSILON && (c = d ? 0 : b);
	      !0 !== this.aClockwise || d || (c = c === b ? -b : c - b);
	      b = this.aStartAngle + a * c;
	      a = this.aX + this.xRadius * Math.cos(b);
	      var e = this.aY + this.yRadius * Math.sin(b);
	      0 !== this.aRotation && (b = Math.cos(this.aRotation), c = Math.sin(this.aRotation), d = a - this.aX, e -= this.aY, a = d * b - e * c + this.aX, e = d * c + e * b + this.aY);
	      return new D(a, e)
	   };
	   zb.prototype = Object.create(na.prototype);
	   zb.prototype.constructor = zb;
	   zb.prototype.isSplineCurve = !0;
	   zb.prototype.getPoint = function(a) {
	      var b = this.points,
	         c = (b.length - 1) * a;
	      a = Math.floor(c);
	      var c = c - a,
	         d = b[0 === a ? a : a - 1],
	         e = b[a],
	         f = b[a > b.length - 2 ? b.length - 1 : a + 1],
	         b = b[a > b.length - 3 ? b.length - 1 : a + 2];
	      return new D(Se(c, d.x, e.x, f.x, b.x), Se(c, d.y, e.y, f.y, b.y))
	   };
	   hc.prototype = Object.create(na.prototype);
	   hc.prototype.constructor = hc;
	   hc.prototype.getPoint = function(a) {
	      var b = this.v0,
	         c = this.v1,
	         d = this.v2,
	         e = this.v3;
	      return new D(yb(a, b.x, c.x, d.x, e.x), yb(a, b.y, c.y, d.y, e.y))
	   };
	   ic.prototype = Object.create(na.prototype);
	   ic.prototype.constructor = ic;
	   ic.prototype.getPoint = function(a) {
	      var b = this.v0,
	         c = this.v1,
	         d = this.v2;
	      return new D(xb(a, b.x, c.x, d.x), xb(a, b.y, c.y, d.y))
	   };
	   var ue = Object.assign(Object.create(Yc.prototype), {
	      fromPoints: function(a) {
	         this.moveTo(a[0].x, a[0].y);
	         for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
	      },
	      moveTo: function(a, b) {
	         this.currentPoint.set(a, b)
	      },
	      lineTo: function(a, b) {
	         var c = new Sa(this.currentPoint.clone(), new D(a, b));
	         this.curves.push(c);
	         this.currentPoint.set(a, b)
	      },
	      quadraticCurveTo: function(a, b, c, d) {
	         a = new ic(this.currentPoint.clone(), new D(a, b), new D(c, d));
	         this.curves.push(a);
	         this.currentPoint.set(c, d)
	      },
	      bezierCurveTo: function(a, b, c, d, e, f) {
	         a = new hc(this.currentPoint.clone(), new D(a, b), new D(c, d), new D(e, f));
	         this.curves.push(a);
	         this.currentPoint.set(e, f)
	      },
	      splineThru: function(a) {
	         var b = [this.currentPoint.clone()].concat(a),
	            b = new zb(b);
	         this.curves.push(b);
	         this.currentPoint.copy(a[a.length - 1])
	      },
	      arc: function(a, b, c, d, e, f) {
	         this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
	      },
	      absarc: function(a, b, c, d, e, f) {
	         this.absellipse(a, b, c, c, d, e, f)
	      },
	      ellipse: function(a, b, c, d, e, f, g, h) {
	         this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
	      },
	      absellipse: function(a, b, c, d, e, f, g, h) {
	         a = new Xa(a, b, c, d, e, f, g, h);
	         0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
	         this.curves.push(a);
	         a = a.getPoint(1);
	         this.currentPoint.copy(a)
	      }
	   });
	   Zc.prototype = ue;
	   ue.constructor = Zc;
	   Ab.prototype = Object.assign(Object.create(ue), {
	      constructor: Ab,
	      getPointsHoles: function(a) {
	         for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
	         return b
	      },
	      extractAllPoints: function(a) {
	         return {
	            shape: this.getPoints(a),
	            holes: this.getPointsHoles(a)
	         }
	      },
	      extractPoints: function(a) {
	         return this.extractAllPoints(a)
	      }
	   });
	   Object.assign(de.prototype, {
	      moveTo: function(a, b) {
	         this.currentPath = new Zc;
	         this.subPaths.push(this.currentPath);
	         this.currentPath.moveTo(a, b)
	      },
	      lineTo: function(a, b) {
	         this.currentPath.lineTo(a, b)
	      },
	      quadraticCurveTo: function(a, b, c, d) {
	         this.currentPath.quadraticCurveTo(a, b, c, d)
	      },
	      bezierCurveTo: function(a, b, c, d, e, f) {
	         this.currentPath.bezierCurveTo(a, b, c, d, e, f)
	      },
	      splineThru: function(a) {
	         this.currentPath.splineThru(a)
	      },
	      toShapes: function(a, b) {
	         function c(a) {
	            for (var b = [], c = 0, d = a.length; c < d; c++) {
	               var e = a[c],
	                  f = new Ab;
	               f.curves = e.curves;
	               b.push(f)
	            }
	            return b
	         }
	         function d(a, b) {
	            for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
	               var g = b[e],
	                  h = b[f],
	                  k = h.x - g.x,
	                  l = h.y - g.y;
	               if (Math.abs(l) > Number.EPSILON) {
	                  if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y)) if (a.y === g.y) {
	                     if (a.x === g.x) return !0
	                  } else {
	                     e = l * (a.x - g.x) - k * (a.y - g.y);
	                     if (0 === e) return !0;
	                     0 > e || (d = !d)
	                  }
	               } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0
	            }
	            return d
	         }
	         var e = za.isClockWise,
	            f = this.subPaths;
	         if (0 === f.length) return [];
	         if (!0 === b) return c(f);
	         var g, h, k, l = [];
	         if (1 === f.length) return h = f[0], k = new Ab, k.curves = h.curves, l.push(k), l;
	         var p = !e(f[0].getPoints()),
	            p = a ? !p : p;
	         k = [];
	         var q = [],
	            n = [],
	            r = 0,
	            z;
	         q[r] = void 0;
	         n[r] = [];
	         for (var t = 0, y = f.length; t < y; t++) h = f[t], z = h.getPoints(), g = e(z), (g = a ? !g : g) ? (!p && q[r] && r++, q[r] = {
	            s: new Ab,
	            p: z
	         }, q[r].s.curves = h.curves, p && r++, n[r] = []) : n[r].push({
	            h: h,
	            p: z[0]
	         });
	         if (!q[0]) return c(f);
	         if (1 < q.length) {
	            t = !1;
	            h = [];
	            e = 0;
	            for (f = q.length; e < f; e++) k[e] = [];
	            e = 0;
	            for (f = q.length; e < f; e++) for (g = n[e], p = 0; p < g.length; p++) {
	               r = g[p];
	               z = !0;
	               for (y = 0; y < q.length; y++) d(r.p, q[y].p) && (e !== y && h.push({
	                  froms: e,
	                  tos: y,
	                  hole: p
	               }), z ? (z = !1, k[y].push(r)) : t = !0);
	               z && k[e].push(r)
	            }
	            0 < h.length && (t || (n = k))
	         }
	         t = 0;
	         for (e = q.length; t < e; t++) for (k = q[t].s, l.push(k), h = n[t], f = 0, g = h.length; f < g; f++) k.holes.push(h[f].h);
	         return l
	      }
	   });
	   Object.assign(ee.prototype, {
	      isFont: !0,
	      generateShapes: function(a, b, c) {
	         void 0 === b && (b = 100);
	         void 0 === c && (c = 4);
	         var d = this.data;
	         a = String(a).split("");
	         var e = b / d.resolution,
	            f = (d.boundingBox.yMax - d.boundingBox.yMin + d.underlineThickness) * e,
	            g = 0,
	            h = 0;
	         b = [];
	         for (var k = 0; k < a.length; k++) {
	            var l = a[k];
	            if ("\n" === l) g = 0, h -= f;
	            else {
	               var p;
	               p = e;
	               var q = g,
	                  n = h;
	               if (l = d.glyphs[l] || d.glyphs["?"]) {
	                  var r = new de,
	                     z = [],
	                     t, y, x, v, B, w, C, D;
	                  if (l.o) for (var E = l._cachedOutline || (l._cachedOutline = l.o.split(" ")), F = 0, I = E.length; F < I;) switch (E[F++]) {
	                  case "m":
	                     t = E[F++] * p + q;
	                     y = E[F++] * p + n;
	                     r.moveTo(t, y);
	                     break;
	                  case "l":
	                     t = E[F++] * p + q;
	                     y = E[F++] * p + n;
	                     r.lineTo(t, y);
	                     break;
	                  case "q":
	                     t = E[F++] * p + q;
	                     y = E[F++] * p + n;
	                     B = E[F++] * p + q;
	                     w = E[F++] * p + n;
	                     r.quadraticCurveTo(B, w, t, y);
	                     if (v = z[z.length - 1]) {
	                        x = v.x;
	                        v = v.y;
	                        for (var H = 1; H <= c; H++) {
	                           var J = H / c;
	                           xb(J, x, B, t);
	                           xb(J, v, w, y)
	                        }
	                     }
	                     break;
	                  case "b":
	                     if (t = E[F++] * p + q, y = E[F++] * p + n, B = E[F++] * p + q, w = E[F++] * p + n, C = E[F++] * p + q, D = E[F++] * p + n, r.bezierCurveTo(B, w, C, D, t, y), v = z[z.length - 1]) for (x = v.x, v = v.y, H = 1; H <= c; H++) J = H / c, yb(J, x, B, C, t), yb(J, v, w, D, y)
	                  }
	                  p = {
	                     offsetX: l.ha * p,
	                     path: r
	                  }
	               } else p = void 0;
	               g += p.offsetX;
	               b.push(p.path)
	            }
	         }
	         c = [];
	         d = 0;
	         for (a = b.length; d < a; d++) Array.prototype.push.apply(c, b[d].toShapes());
	         return c
	      }
	   });
	   Object.assign(Te.prototype, {
	      load: function(a, b, c, d) {
	         var e = this;
	         new ua(this.manager).load(a, function(a) {
	            var c;
	            try {
	               c = JSON.parse(a)
	            } catch (d) {
	               console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
	            }
	            a = e.parse(c);
	            b && b(a)
	         }, c, d)
	      },
	      parse: function(a) {
	         return new ee(a)
	      }
	   });
	   var Od, ie = {
	      getContext: function() {
	         void 0 === Od && (Od = new(window.AudioContext || window.webkitAudioContext));
	         return Od
	      },
	      setContext: function(a) {
	         Od = a
	      }
	   };
	   Object.assign(fe.prototype, {
	      load: function(a, b, c, d) {
	         var e = new ua(this.manager);
	         e.setResponseType("arraybuffer");
	         e.load(a, function(a) {
	            ie.getContext().decodeAudioData(a, function(a) {
	               b(a)
	            })
	         }, c, d)
	      }
	   });
	   Object.assign(Ue.prototype, {
	      update: function() {
	         var a, b, c, d, e, f, g, h, k = new J,
	            l = new J;
	         return function(p) {
	            if (a !== this || b !== p.focus || c !== p.fov || d !== p.aspect * this.aspect || e !== p.near || f !== p.far || g !== p.zoom || h !== this.eyeSep) {
	               a = this;
	               b = p.focus;
	               c = p.fov;
	               d = p.aspect * this.aspect;
	               e = p.near;
	               f = p.far;
	               g = p.zoom;
	               var q = p.projectionMatrix.clone();
	               h = this.eyeSep / 2;
	               var n = h * e / b,
	                  r = e * Math.tan(Y.DEG2RAD * c * .5) / g,
	                  z, t;
	               l.elements[12] = -h;
	               k.elements[12] = h;
	               z = -r * d + n;
	               t = r * d + n;
	               q.elements[0] = 2 * e / (t - z);
	               q.elements[8] = (t + z) / (t - z);
	               this.cameraL.projectionMatrix.copy(q);
	               z = -r * d - n;
	               t = r * d - n;
	               q.elements[0] = 2 * e / (t - z);
	               q.elements[8] = (t + z) / (t - z);
	               this.cameraR.projectionMatrix.copy(q)
	            }
	            this.cameraL.matrixWorld.copy(p.matrixWorld).multiply(l);
	            this.cameraR.matrixWorld.copy(p.matrixWorld).multiply(k)
	         }
	      }()
	   });
	   Id.prototype = Object.create(B.prototype);
	   Id.prototype.constructor = Id;
	   ge.prototype = Object.assign(Object.create(xa.prototype), {
	      constructor: ge,
	      isArrayCamera: !0
	   });
	   he.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: he,
	      getInput: function() {
	         return this.gain
	      },
	      removeFilter: function() {
	         null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
	      },
	      getFilter: function() {
	         return this.filter
	      },
	      setFilter: function(a) {
	         null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
	         this.filter = a;
	         this.gain.connect(this.filter);
	         this.filter.connect(this.context.destination)
	      },
	      getMasterVolume: function() {
	         return this.gain.gain.value
	      },
	      setMasterVolume: function(a) {
	         this.gain.gain.value = a
	      },
	      updateMatrixWorld: function() {
	         var a = new p,
	            b = new qa,
	            c = new p,
	            d = new p;
	         return function(e) {
	            B.prototype.updateMatrixWorld.call(this, e);
	            e = this.context.listener;
	            var f = this.up;
	            this.matrixWorld.decompose(a, b, c);
	            d.set(0, 0, -1).applyQuaternion(b);
	            e.positionX ? (e.positionX.setValueAtTime(a.x, this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z))
	         }
	      }()
	   });
	   jc.prototype = Object.assign(Object.create(B.prototype), {
	      constructor: jc,
	      getOutput: function() {
	         return this.gain
	      },
	      setNodeSource: function(a) {
	         this.hasPlaybackControl = !1;
	         this.sourceType = "audioNode";
	         this.source = a;
	         this.connect();
	         return this
	      },
	      setBuffer: function(a) {
	         this.buffer = a;
	         this.sourceType = "buffer";
	         this.autoplay && this.play();
	         return this
	      },
	      play: function() {
	         if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
	         else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
	         else {
	            var a = this.context.createBufferSource();
	            a.buffer = this.buffer;
	            a.loop = this.loop;
	            a.onended = this.onEnded.bind(this);
	            a.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
	            a.start(0, this.startTime);
	            this.isPlaying = !0;
	            this.source = a;
	            return this.connect()
	         }
	      },
	      pause: function() {
	         if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
	         else return this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this
	      },
	      stop: function() {
	         if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
	         else return this.source.stop(), this.startTime = 0, this.isPlaying = !1, this
	      },
	      connect: function() {
	         if (0 < this.filters.length) {
	            this.source.connect(this.filters[0]);
	            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
	            this.filters[this.filters.length - 1].connect(this.getOutput())
	         } else this.source.connect(this.getOutput());
	         return this
	      },
	      disconnect: function() {
	         if (0 < this.filters.length) {
	            this.source.disconnect(this.filters[0]);
	            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
	            this.filters[this.filters.length - 1].disconnect(this.getOutput())
	         } else this.source.disconnect(this.getOutput());
	         return this
	      },
	      getFilters: function() {
	         return this.filters
	      },
	      setFilters: function(a) {
	         a || (a = []);
	         !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
	         return this
	      },
	      getFilter: function() {
	         return this.getFilters()[0]
	      },
	      setFilter: function(a) {
	         return this.setFilters(a ? [a] : [])
	      },
	      setPlaybackRate: function(a) {
	         if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
	         else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this
	      },
	      getPlaybackRate: function() {
	         return this.playbackRate
	      },
	      onEnded: function() {
	         this.isPlaying = !1
	      },
	      getLoop: function() {
	         return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
	      },
	      setLoop: function(a) {
	         if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
	         else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this
	      },
	      getVolume: function() {
	         return this.gain.gain.value
	      },
	      setVolume: function(a) {
	         this.gain.gain.value = a;
	         return this
	      }
	   });
	   je.prototype = Object.assign(Object.create(jc.prototype), {
	      constructor: je,
	      getOutput: function() {
	         return this.panner
	      },
	      getRefDistance: function() {
	         return this.panner.refDistance
	      },
	      setRefDistance: function(a) {
	         this.panner.refDistance = a
	      },
	      getRolloffFactor: function() {
	         return this.panner.rolloffFactor
	      },
	      setRolloffFactor: function(a) {
	         this.panner.rolloffFactor = a
	      },
	      getDistanceModel: function() {
	         return this.panner.distanceModel
	      },
	      setDistanceModel: function(a) {
	         this.panner.distanceModel = a
	      },
	      getMaxDistance: function() {
	         return this.panner.maxDistance
	      },
	      setMaxDistance: function(a) {
	         this.panner.maxDistance = a
	      },
	      updateMatrixWorld: function() {
	         var a = new p;
	         return function(b) {
	            B.prototype.updateMatrixWorld.call(this, b);
	            a.setFromMatrixPosition(this.matrixWorld);
	            this.panner.setPosition(a.x, a.y, a.z)
	         }
	      }()
	   });
	   Object.assign(ke.prototype, {
	      getFrequencyData: function() {
	         this.analyser.getByteFrequencyData(this.data);
	         return this.data
	      },
	      getAverageFrequency: function() {
	         for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
	         return a / b.length
	      }
	   });
	   Object.assign(le.prototype, {
	      accumulate: function(a, b) {
	         var c = this.buffer,
	            d = this.valueSize,
	            e = a * d + d,
	            f = this.cumulativeWeight;
	         if (0 === f) {
	            for (f = 0; f !== d; ++f) c[e + f] = c[f];
	            f = b
	         } else f += b, this._mixBufferRegion(c, e, 0, b / f, d);
	         this.cumulativeWeight = f
	      },
	      apply: function(a) {
	         var b = this.valueSize,
	            c = this.buffer;
	         a = a * b + b;
	         var d = this.cumulativeWeight,
	            e = this.binding;
	         this.cumulativeWeight = 0;
	         1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
	         for (var d = b, f = b + b; d !== f; ++d) if (c[d] !== c[d + b]) {
	            e.setValue(c, a);
	            break
	         }
	      },
	      saveOriginalState: function() {
	         var a = this.buffer,
	            b = this.valueSize,
	            c = 3 * b;
	         this.binding.getValue(a, c);
	         for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
	         this.cumulativeWeight = 0
	      },
	      restoreOriginalState: function() {
	         this.binding.setValue(this.buffer, 3 * this.valueSize)
	      },
	      _select: function(a, b, c, d, e) {
	         if (.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
	      },
	      _slerp: function(a, b, c, d) {
	         qa.slerpFlat(a, b, a, b, a, c, d)
	      },
	      _lerp: function(a, b, c, d, e) {
	         for (var f = 1 - d, g = 0; g !== e; ++g) {
	            var h = b + g;
	            a[h] = a[h] * f + a[c + g] * d
	         }
	      }
	   });
	   Object.assign(Ve.prototype, {
	      getValue: function(a, b) {
	         this.bind();
	         var c = this._bindings[this._targetGroup.nCachedObjects_];
	         void 0 !== c && c.getValue(a, b)
	      },
	      setValue: function(a, b) {
	         for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
	      },
	      bind: function() {
	         for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
	      },
	      unbind: function() {
	         for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
	      }
	   });
	   Object.assign(oa, {
	      Composite: Ve,
	      create: function(a, b, c) {
	         return a && a.isAnimationObjectGroup ? new oa.Composite(a, b, c) : new oa(a, b, c)
	      },
	      parseTrackName: function() {
	         var a = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source + "$"),
	            b = ["material", "materials", "bones"];
	         return function(c) {
	            var d = a.exec(c);
	            if (!d) throw Error("PropertyBinding: Cannot parse trackName: " + c);
	            var d = {
	               nodeName: d[2],
	               objectName: d[3],
	               objectIndex: d[4],
	               propertyName: d[5],
	               propertyIndex: d[6]
	            },
	               e = d.nodeName && d.nodeName.lastIndexOf(".");
	            if (void 0 !== e && -1 !== e) {
	               var f = d.nodeName.substring(e + 1); - 1 !== b.indexOf(f) && (d.nodeName = d.nodeName.substring(0, e), d.objectName = f)
	            }
	            if (null === d.propertyName || 0 === d.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + c);
	            return d
	         }
	      }(),
	      findNode: function(a, b) {
	         if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
	         if (a.skeleton) {
	            var c = function(a) {
	                  for (var c = 0; c < a.bones.length; c++) {
	                     var d = a.bones[c];
	                     if (d.name === b) return d
	                  }
	                  return null
	               }(a.skeleton);
	            if (c) return c
	         }
	         if (a.children) {
	            var d = function(a) {
	                  for (var c = 0; c < a.length; c++) {
	                     var g = a[c];
	                     if (g.name === b || g.uuid === b || (g = d(g.children))) return g
	                  }
	                  return null
	               };
	            if (c = d(a.children)) return c
	         }
	         return null
	      }
	   });
	   Object.assign(oa.prototype, {
	      _getValue_unavailable: function() {},
	      _setValue_unavailable: function() {},
	      BindingType: {
	         Direct: 0,
	         EntireArray: 1,
	         ArrayElement: 2,
	         HasFromToArray: 3
	      },
	      Versioning: {
	         None: 0,
	         NeedsUpdate: 1,
	         MatrixWorldNeedsUpdate: 2
	      },
	      GetterByBindingType: [function(a, b) {
	         a[b] = this.node[this.propertyName]
	      }, function(a, b) {
	         for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
	      }, function(a, b) {
	         a[b] = this.resolvedProperty[this.propertyIndex]
	      }, function(a, b) {
	         this.resolvedProperty.toArray(a, b)
	      }],
	      SetterByBindingTypeAndVersioning: [
	         [function(a, b) {
	            this.node[this.propertyName] = a[b]
	         }, function(a, b) {
	            this.node[this.propertyName] = a[b];
	            this.targetObject.needsUpdate = !0
	         }, function(a, b) {
	            this.node[this.propertyName] = a[b];
	            this.targetObject.matrixWorldNeedsUpdate = !0
	         }],
	         [function(a, b) {
	            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
	         }, function(a, b) {
	            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
	            this.targetObject.needsUpdate = !0
	         }, function(a, b) {
	            for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
	            this.targetObject.matrixWorldNeedsUpdate = !0
	         }],
	         [function(a, b) {
	            this.resolvedProperty[this.propertyIndex] = a[b]
	         }, function(a, b) {
	            this.resolvedProperty[this.propertyIndex] = a[b];
	            this.targetObject.needsUpdate = !0
	         }, function(a, b) {
	            this.resolvedProperty[this.propertyIndex] = a[b];
	            this.targetObject.matrixWorldNeedsUpdate = !0
	         }],
	         [function(a, b) {
	            this.resolvedProperty.fromArray(a, b)
	         }, function(a, b) {
	            this.resolvedProperty.fromArray(a, b);
	            this.targetObject.needsUpdate = !0
	         }, function(a, b) {
	            this.resolvedProperty.fromArray(a, b);
	            this.targetObject.matrixWorldNeedsUpdate = !0
	         }]
	      ],
	      getValue: function(a, b) {
	         this.bind();
	         this.getValue(a, b)
	      },
	      setValue: function(a, b) {
	         this.bind();
	         this.setValue(a, b)
	      },
	      bind: function() {
	         var a = this.node,
	            b = this.parsedPath,
	            c = b.objectName,
	            d = b.propertyName,
	            e = b.propertyIndex;
	         a || (this.node = a = oa.findNode(this.rootNode, b.nodeName) || this.rootNode);
	         this.getValue = this._getValue_unavailable;
	         this.setValue = this._setValue_unavailable;
	         if (a) {
	            if (c) {
	               var f = b.objectIndex;
	               switch (c) {
	               case "materials":
	                  if (!a.material) {
	                     console.error("  can not bind to material as node does not have a material", this);
	                     return
	                  }
	                  if (!a.material.materials) {
	                     console.error("  can not bind to material.materials as node.material does not have a materials array", this);
	                     return
	                  }
	                  a = a.material.materials;
	                  break;
	               case "bones":
	                  if (!a.skeleton) {
	                     console.error("  can not bind to bones as node does not have a skeleton", this);
	                     return
	                  }
	                  a = a.skeleton.bones;
	                  for (c = 0; c < a.length; c++) if (a[c].name === f) {
	                     f = c;
	                     break
	                  }
	                  break;
	               default:
	                  if (void 0 === a[c]) {
	                     console.error("  can not bind to objectName of node, undefined", this);
	                     return
	                  }
	                  a = a[c]
	               }
	               if (void 0 !== f) {
	                  if (void 0 === a[f]) {
	                     console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
	                     return
	                  }
	                  a = a[f]
	               }
	            }
	            f = a[d];
	            if (void 0 === f) console.error("  trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
	            else {
	               b = this.Versioning.None;
	               void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
	               c = this.BindingType.Direct;
	               if (void 0 !== e) {
	                  if ("morphTargetInfluences" === d) {
	                     if (!a.geometry) {
	                        console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
	                        return
	                     }
	                     if (!a.geometry.morphTargets) {
	                        console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
	                        return
	                     }
	                     for (c = 0; c < this.node.geometry.morphTargets.length; c++) if (a.geometry.morphTargets[c].name === e) {
	                        e = c;
	                        break
	                     }
	                  }
	                  c = this.BindingType.ArrayElement;
	                  this.resolvedProperty = f;
	                  this.propertyIndex = e
	               } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
	               this.getValue = this.GetterByBindingType[c];
	               this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
	            }
	         } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
	      },
	      unbind: function() {
	         this.node = null;
	         this.getValue = this._getValue_unbound;
	         this.setValue = this._setValue_unbound
	      }
	   });
	   Object.assign(oa.prototype, {
	      _getValue_unbound: oa.prototype.getValue,
	      _setValue_unbound: oa.prototype.setValue
	   });
	   Object.assign(We.prototype, {
	      isAnimationObjectGroup: !0,
	      add: function(a) {
	         for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, k = h.length, l = 0, p = arguments.length; l !== p; ++l) {
	            var q = arguments[l],
	               n = q.uuid,
	               r = e[n];
	            if (void 0 === r) {
	               r = c++;
	               e[n] = r;
	               b.push(q);
	               for (var n = 0, z = k; n !== z; ++n) h[n].push(new oa(q, f[n], g[n]))
	            } else if (r < d) {
	               var t = --d,
	                  z = b[t];
	               e[z.uuid] = r;
	               b[r] = z;
	               e[n] = t;
	               b[t] = q;
	               n = 0;
	               for (z = k; n !== z; ++n) {
	                  var y = h[n],
	                     x = y[r];
	                  y[r] = y[t];
	                  void 0 === x && (x = new oa(q, f[n], g[n]));
	                  y[t] = x
	               }
	            } else void 0 !== b[r] && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
	         }
	         this.nCachedObjects_ = d
	      },
	      remove: function(a) {
	         for (var b = this._objects, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
	            var k = arguments[g],
	               l = k.uuid,
	               p = d[l];
	            if (void 0 !== p && p >= c) {
	               var q = c++,
	                  n = b[q];
	               d[n.uuid] = p;
	               b[p] = n;
	               d[l] = q;
	               b[q] = k;
	               k = 0;
	               for (l = f; k !== l; ++k) {
	                  var n = e[k],
	                     r = n[p];
	                  n[p] = n[q];
	                  n[q] = r
	               }
	            }
	         }
	         this.nCachedObjects_ = c
	      },
	      uncache: function(a) {
	         for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, k = arguments.length; h !== k; ++h) {
	            var l = arguments[h].uuid,
	               p = e[l];
	            if (void 0 !== p) if (delete e[l], p < d) {
	               var l = --d,
	                  q = b[l],
	                  n = --c,
	                  r = b[n];
	               e[q.uuid] = p;
	               b[p] = q;
	               e[r.uuid] = l;
	               b[l] = r;
	               b.pop();
	               q = 0;
	               for (r = g; q !== r; ++q) {
	                  var z = f[q],
	                     t = z[n];
	                  z[p] = z[l];
	                  z[l] = t;
	                  z.pop()
	               }
	            } else for (n = --c, r = b[n], e[r.uuid] = p, b[p] = r, b.pop(), q = 0, r = g; q !== r; ++q) z = f[q], z[p] = z[n], z.pop()
	         }
	         this.nCachedObjects_ = d
	      },
	      subscribe_: function(a, b) {
	         var c = this._bindingsIndicesByPath,
	            d = c[a],
	            e = this._bindings;
	         if (void 0 !== d) return e[d];
	         var f = this._paths,
	            g = this._parsedPaths,
	            h = this._objects,
	            k = this.nCachedObjects_,
	            l = Array(h.length),
	            d = e.length;
	         c[a] = d;
	         f.push(a);
	         g.push(b);
	         e.push(l);
	         c = k;
	         for (d = h.length; c !== d; ++c) l[c] = new oa(h[c], a, b);
	         return l
	      },
	      unsubscribe_: function(a) {
	         var b = this._bindingsIndicesByPath,
	            c = b[a];
	         if (void 0 !== c) {
	            var d = this._paths,
	               e = this._parsedPaths,
	               f = this._bindings,
	               g = f.length - 1,
	               h = f[g];
	            b[a[g]] = c;
	            f[c] = h;
	            f.pop();
	            e[c] = e[g];
	            e.pop();
	            d[c] = d[g];
	            d.pop()
	         }
	      }
	   });
	   Object.assign(Xe.prototype, {
	      play: function() {
	         this._mixer._activateAction(this);
	         return this
	      },
	      stop: function() {
	         this._mixer._deactivateAction(this);
	         return this.reset()
	      },
	      reset: function() {
	         this.paused = !1;
	         this.enabled = !0;
	         this.time = 0;
	         this._loopCount = -1;
	         this._startTime = null;
	         return this.stopFading().stopWarping()
	      },
	      isRunning: function() {
	         return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
	      },
	      isScheduled: function() {
	         return this._mixer._isActiveAction(this)
	      },
	      startAt: function(a) {
	         this._startTime = a;
	         return this
	      },
	      setLoop: function(a, b) {
	         this.loop = a;
	         this.repetitions = b;
	         return this
	      },
	      setEffectiveWeight: function(a) {
	         this.weight = a;
	         this._effectiveWeight = this.enabled ? a : 0;
	         return this.stopFading()
	      },
	      getEffectiveWeight: function() {
	         return this._effectiveWeight
	      },
	      fadeIn: function(a) {
	         return this._scheduleFading(a, 0, 1)
	      },
	      fadeOut: function(a) {
	         return this._scheduleFading(a, 1, 0)
	      },
	      crossFadeFrom: function(a, b, c) {
	         a.fadeOut(b);
	         this.fadeIn(b);
	         if (c) {
	            c = this._clip.duration;
	            var d = a._clip.duration,
	               e = c / d;
	            a.warp(1, d / c, b);
	            this.warp(e, 1, b)
	         }
	         return this
	      },
	      crossFadeTo: function(a, b, c) {
	         return a.crossFadeFrom(this, b, c)
	      },
	      stopFading: function() {
	         var a = this._weightInterpolant;
	         null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
	         return this
	      },
	      setEffectiveTimeScale: function(a) {
	         this.timeScale = a;
	         this._effectiveTimeScale = this.paused ? 0 : a;
	         return this.stopWarping()
	      },
	      getEffectiveTimeScale: function() {
	         return this._effectiveTimeScale
	      },
	      setDuration: function(a) {
	         this.timeScale = this._clip.duration / a;
	         return this.stopWarping()
	      },
	      syncWith: function(a) {
	         this.time = a.time;
	         this.timeScale = a.timeScale;
	         return this.stopWarping()
	      },
	      halt: function(a) {
	         return this.warp(this._effectiveTimeScale, 0, a)
	      },
	      warp: function(a, b, c) {
	         var d = this._mixer,
	            e = d.time,
	            f = this._timeScaleInterpolant,
	            g = this.timeScale;
	         null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
	         d = f.parameterPositions;
	         f = f.sampleValues;
	         d[0] = e;
	         d[1] = e + c;
	         f[0] = a / g;
	         f[1] = b / g;
	         return this
	      },
	      stopWarping: function() {
	         var a = this._timeScaleInterpolant;
	         null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
	         return this
	      },
	      getMixer: function() {
	         return this._mixer
	      },
	      getClip: function() {
	         return this._clip
	      },
	      getRoot: function() {
	         return this._localRoot || this._mixer._root
	      },
	      _update: function(a, b, c, d) {
	         if (this.enabled) {
	            var e = this._startTime;
	            if (null !== e) {
	               b = (a - e) * c;
	               if (0 > b || 0 === c) return;
	               this._startTime = null;
	               b *= c
	            }
	            b *= this._updateTimeScale(a);
	            c = this._updateTime(b);
	            a = this._updateWeight(a);
	            if (0 < a) {
	               b = this._interpolants;
	               for (var e = this._propertyBindings, f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
	            }
	         } else this._updateWeight(a)
	      },
	      _updateWeight: function(a) {
	         var b = 0;
	         if (this.enabled) {
	            var b = this.weight,
	               c = this._weightInterpolant;
	            if (null !== c) {
	               var d = c.evaluate(a)[0],
	                  b = b * d;
	               a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
	            }
	         }
	         return this._effectiveWeight = b
	      },
	      _updateTimeScale: function(a) {
	         var b = 0;
	         if (!this.paused) {
	            var b = this.timeScale,
	               c = this._timeScaleInterpolant;
	            if (null !== c) {
	               var d = c.evaluate(a)[0],
	                  b = b * d;
	               a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
	            }
	         }
	         return this._effectiveTimeScale = b
	      },
	      _updateTime: function(a) {
	         var b = this.time + a;
	         if (0 === a) return b;
	         var c = this._clip.duration,
	            d = this.loop,
	            e = this._loopCount;
	         if (2200 === d) a: {
	            if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
	            else if (0 > b) b = 0;
	            else break a;
	            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;
	            this._mixer.dispatchEvent({
	               type: "finished",
	               action: this,
	               direction: 0 > a ? -1 : 1
	            })
	         } else {
	            d = 2202 === d; - 1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d));
	            if (b >= c || 0 > b) {
	               var f = Math.floor(b / c),
	                  b = b - c * f,
	                  e = e + Math.abs(f),
	                  g = this.repetitions - e;
	               0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
	                  type: "finished",
	                  action: this,
	                  direction: 0 < a ? 1 : -1
	               })) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({
	                  type: "loop",
	                  action: this,
	                  loopDelta: f
	               }))
	            }
	            if (d && 1 === (e & 1)) return this.time = b, c - b
	         }
	         return this.time = b
	      },
	      _setEndings: function(a, b, c) {
	         var d = this._interpolantSettings;
	         c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
	      },
	      _scheduleFading: function(a, b, c) {
	         var d = this._mixer,
	            e = d.time,
	            f = this._weightInterpolant;
	         null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
	         d = f.parameterPositions;
	         f = f.sampleValues;
	         d[0] = e;
	         f[0] = b;
	         d[1] = e + a;
	         f[1] = c;
	         return this
	      }
	   });
	   Object.assign(Ye.prototype, sa.prototype, {
	      _bindAction: function(a, b) {
	         var c = a._localRoot || this._root,
	            d = a._clip.tracks,
	            e = d.length,
	            f = a._propertyBindings,
	            g = a._interpolants,
	            h = c.uuid,
	            k = this._bindingsByRootAndName,
	            l = k[h];
	         void 0 === l && (l = {}, k[h] = l);
	         for (k = 0; k !== e; ++k) {
	            var p = d[k],
	               q = p.name,
	               n = l[q];
	            if (void 0 === n) {
	               n = f[k];
	               if (void 0 !== n) {
	                  null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, h, q));
	                  continue
	               }
	               n = new le(oa.create(c, q, b && b._propertyBindings[k].binding.parsedPath), p.ValueTypeName, p.getValueSize());
	               ++n.referenceCount;
	               this._addInactiveBinding(n, h, q)
	            }
	            f[k] = n;
	            g[k].resultBuffer = n.buffer
	         }
	      },
	      _activateAction: function(a) {
	         if (!this._isActiveAction(a)) {
	            if (null === a._cacheIndex) {
	               var b = (a._localRoot || this._root).uuid,
	                  c = a._clip.uuid,
	                  d = this._actionsByClip[c];
	               this._bindAction(a, d && d.knownActions[0]);
	               this._addInactiveAction(a, c, b)
	            }
	            b = a._propertyBindings;
	            c = 0;
	            for (d = b.length; c !== d; ++c) {
	               var e = b[c];
	               0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
	            }
	            this._lendAction(a)
	         }
	      },
	      _deactivateAction: function(a) {
	         if (this._isActiveAction(a)) {
	            for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
	               var e = b[c];
	               0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
	            }
	            this._takeBackAction(a)
	         }
	      },
	      _initMemoryManager: function() {
	         this._actions = [];
	         this._nActiveActions = 0;
	         this._actionsByClip = {};
	         this._bindings = [];
	         this._nActiveBindings = 0;
	         this._bindingsByRootAndName = {};
	         this._controlInterpolants = [];
	         this._nActiveControlInterpolants = 0;
	         var a = this;
	         this.stats = {
	            actions: {
	               get total() {
	                  return a._actions.length
	               }, get inUse() {
	                  return a._nActiveActions
	               }
	            },
	            bindings: {
	               get total() {
	                  return a._bindings.length
	               }, get inUse() {
	                  return a._nActiveBindings
	               }
	            },
	            controlInterpolants: {
	               get total() {
	                  return a._controlInterpolants.length
	               }, get inUse() {
	                  return a._nActiveControlInterpolants
	               }
	            }
	         }
	      },
	      _isActiveAction: function(a) {
	         a = a._cacheIndex;
	         return null !== a && a < this._nActiveActions
	      },
	      _addInactiveAction: function(a, b, c) {
	         var d = this._actions,
	            e = this._actionsByClip,
	            f = e[b];
	         void 0 === f ? (f = {
	            knownActions: [a],
	            actionByRoot: {}
	         }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
	         a._cacheIndex = d.length;
	         d.push(a);
	         f.actionByRoot[c] = a
	      },
	      _removeInactiveAction: function(a) {
	         var b = this._actions,
	            c = b[b.length - 1],
	            d = a._cacheIndex;
	         c._cacheIndex = d;
	         b[d] = c;
	         b.pop();
	         a._cacheIndex = null;
	         var b = a._clip.uuid,
	            c = this._actionsByClip,
	            d = c[b],
	            e = d.knownActions,
	            f = e[e.length - 1],
	            g = a._byClipCacheIndex;
	         f._byClipCacheIndex = g;
	         e[g] = f;
	         e.pop();
	         a._byClipCacheIndex = null;
	         delete d.actionByRoot[(a._localRoot || this._root).uuid];
	         0 === e.length && delete c[b];
	         this._removeInactiveBindingsForAction(a)
	      },
	      _removeInactiveBindingsForAction: function(a) {
	         a = a._propertyBindings;
	         for (var b = 0, c = a.length; b !== c; ++b) {
	            var d = a[b];
	            0 === --d.referenceCount && this._removeInactiveBinding(d)
	         }
	      },
	      _lendAction: function(a) {
	         var b = this._actions,
	            c = a._cacheIndex,
	            d = this._nActiveActions++,
	            e = b[d];
	         a._cacheIndex = d;
	         b[d] = a;
	         e._cacheIndex = c;
	         b[c] = e
	      },
	      _takeBackAction: function(a) {
	         var b = this._actions,
	            c = a._cacheIndex,
	            d = --this._nActiveActions,
	            e = b[d];
	         a._cacheIndex = d;
	         b[d] = a;
	         e._cacheIndex = c;
	         b[c] = e
	      },
	      _addInactiveBinding: function(a, b, c) {
	         var d = this._bindingsByRootAndName,
	            e = d[b],
	            f = this._bindings;
	         void 0 === e && (e = {}, d[b] = e);
	         e[c] = a;
	         a._cacheIndex = f.length;
	         f.push(a)
	      },
	      _removeInactiveBinding: function(a) {
	         var b = this._bindings,
	            c = a.binding,
	            d = c.rootNode.uuid,
	            c = c.path,
	            e = this._bindingsByRootAndName,
	            f = e[d],
	            g = b[b.length - 1];
	         a = a._cacheIndex;
	         g._cacheIndex = a;
	         b[a] = g;
	         b.pop();
	         delete f[c];
	         a: {
	            for (var h in f) break a;
	            delete e[d]
	         }
	      },
	      _lendBinding: function(a) {
	         var b = this._bindings,
	            c = a._cacheIndex,
	            d = this._nActiveBindings++,
	            e = b[d];
	         a._cacheIndex = d;
	         b[d] = a;
	         e._cacheIndex = c;
	         b[c] = e
	      },
	      _takeBackBinding: function(a) {
	         var b = this._bindings,
	            c = a._cacheIndex,
	            d = --this._nActiveBindings,
	            e = b[d];
	         a._cacheIndex = d;
	         b[d] = a;
	         e._cacheIndex = c;
	         b[c] = e
	      },
	      _lendControlInterpolant: function() {
	         var a = this._controlInterpolants,
	            b = this._nActiveControlInterpolants++,
	            c = a[b];
	         void 0 === c && (c = new Wc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
	         return c
	      },
	      _takeBackControlInterpolant: function(a) {
	         var b = this._controlInterpolants,
	            c = a.__cacheIndex,
	            d = --this._nActiveControlInterpolants,
	            e = b[d];
	         a.__cacheIndex = d;
	         b[d] = a;
	         e.__cacheIndex = c;
	         b[c] = e
	      },
	      _controlInterpolantsResultBuffer: new Float32Array(1),
	      clipAction: function(a, b) {
	         var c = b || this._root,
	            d = c.uuid,
	            e = "string" === typeof a ? Ba.findByName(c, a) : a,
	            c = null !== e ? e.uuid : a,
	            f = this._actionsByClip[c],
	            g = null;
	         if (void 0 !== f) {
	            g = f.actionByRoot[d];
	            if (void 0 !== g) return g;
	            g = f.knownActions[0];
	            null === e && (e = g._clip)
	         }
	         if (null === e) return null;
	         e = new Xe(this, e, b);
	         this._bindAction(e, g);
	         this._addInactiveAction(e, c, d);
	         return e
	      },
	      existingAction: function(a, b) {
	         var c = b || this._root,
	            d = c.uuid,
	            c = "string" === typeof a ? Ba.findByName(c, a) : a,
	            c = this._actionsByClip[c ? c.uuid : a];
	         return void 0 !== c ? c.actionByRoot[d] || null : null
	      },
	      stopAllAction: function() {
	         for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
	         for (e = 0; e !== d; ++e) c[e].useCount = 0;
	         return this
	      },
	      update: function(a) {
	         a *= this.timeScale;
	         for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(d, a, e, f);
	         a = this._bindings;
	         b = this._nActiveBindings;
	         for (g = 0; g !== b; ++g) a[g].apply(f);
	         return this
	      },
	      getRoot: function() {
	         return this._root
	      },
	      uncacheClip: function(a) {
	         var b = this._actions;
	         a = a.uuid;
	         var c = this._actionsByClip,
	            d = c[a];
	         if (void 0 !== d) {
	            for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
	               var g = d[e];
	               this._deactivateAction(g);
	               var h = g._cacheIndex,
	                  k = b[b.length - 1];
	               g._cacheIndex = null;
	               g._byClipCacheIndex = null;
	               k._cacheIndex = h;
	               b[h] = k;
	               b.pop();
	               this._removeInactiveBindingsForAction(g)
	            }
	            delete c[a]
	         }
	      },
	      uncacheRoot: function(a) {
	         a = a.uuid;
	         var b = this._actionsByClip,
	            c;
	         for (c in b) {
	            var d = b[c].actionByRoot[a];
	            void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d))
	         }
	         c = this._bindingsByRootAndName[a];
	         if (void 0 !== c) for (var e in c) a = c[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
	      },
	      uncacheAction: function(a, b) {
	         var c = this.existingAction(a, b);
	         null !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
	      }
	   });
	   Jd.prototype.clone = function() {
	      return new Jd(void 0 === this.value.clone ? this.value : this.value.clone())
	   };
	   me.prototype = Object.assign(Object.create(I.prototype), {
	      constructor: me,
	      isInstancedBufferGeometry: !0,
	      addGroup: function(a, b, c) {
	         this.groups.push({
	            start: a,
	            count: b,
	            materialIndex: c
	         })
	      },
	      copy: function(a) {
	         var b = a.index;
	         null !== b && this.setIndex(b.clone());
	         var b = a.attributes,
	            c;
	         for (c in b) this.addAttribute(c, b[c].clone());
	         a = a.groups;
	         c = 0;
	         for (b = a.length; c < b; c++) {
	            var d = a[c];
	            this.addGroup(d.start, d.count, d.materialIndex)
	         }
	         return this
	      }
	   });
	   Object.defineProperties(ne.prototype, {
	      count: {
	         get: function() {
	            return this.data.count
	         }
	      },
	      array: {
	         get: function() {
	            return this.data.array
	         }
	      }
	   });
	   Object.assign(ne.prototype, {
	      isInterleavedBufferAttribute: !0,
	      setX: function(a, b) {
	         this.data.array[a * this.data.stride + this.offset] = b;
	         return this
	      },
	      setY: function(a, b) {
	         this.data.array[a * this.data.stride + this.offset + 1] = b;
	         return this
	      },
	      setZ: function(a, b) {
	         this.data.array[a * this.data.stride + this.offset + 2] = b;
	         return this
	      },
	      setW: function(a, b) {
	         this.data.array[a * this.data.stride + this.offset + 3] = b;
	         return this
	      },
	      getX: function(a) {
	         return this.data.array[a * this.data.stride + this.offset]
	      },
	      getY: function(a) {
	         return this.data.array[a * this.data.stride + this.offset + 1]
	      },
	      getZ: function(a) {
	         return this.data.array[a * this.data.stride + this.offset + 2]
	      },
	      getW: function(a) {
	         return this.data.array[a * this.data.stride + this.offset + 3]
	      },
	      setXY: function(a, b, c) {
	         a = a * this.data.stride + this.offset;
	         this.data.array[a + 0] = b;
	         this.data.array[a + 1] = c;
	         return this
	      },
	      setXYZ: function(a, b, c, d) {
	         a = a * this.data.stride + this.offset;
	         this.data.array[a + 0] = b;
	         this.data.array[a + 1] = c;
	         this.data.array[a + 2] = d;
	         return this
	      },
	      setXYZW: function(a, b, c, d, e) {
	         a = a * this.data.stride + this.offset;
	         this.data.array[a + 0] = b;
	         this.data.array[a + 1] = c;
	         this.data.array[a + 2] = d;
	         this.data.array[a + 3] = e;
	         return this
	      }
	   });
	   Object.defineProperty(kc.prototype, "needsUpdate", {
	      set: function(a) {
	         !0 === a && this.version++
	      }
	   });
	   Object.assign(kc.prototype, {
	      isInterleavedBuffer: !0,
	      setArray: function(a) {
	         if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
	         this.count = void 0 !== a ? a.length / this.stride : 0;
	         this.array = a
	      },
	      setDynamic: function(a) {
	         this.dynamic = a;
	         return this
	      },
	      copy: function(a) {
	         this.array = new a.array.constructor(a.array);
	         this.count = a.count;
	         this.stride = a.stride;
	         this.dynamic = a.dynamic;
	         return this
	      },
	      copyAt: function(a, b, c) {
	         a *= this.stride;
	         c *= b.stride;
	         for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
	         return this
	      },
	      set: function(a, b) {
	         void 0 === b && (b = 0);
	         this.array.set(a, b);
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      onUpload: function(a) {
	         this.onUploadCallback = a;
	         return this
	      }
	   });
	   oe.prototype = Object.assign(Object.create(kc.prototype), {
	      constructor: oe,
	      isInstancedInterleavedBuffer: !0,
	      copy: function(a) {
	         kc.prototype.copy.call(this, a);
	         this.meshPerAttribute = a.meshPerAttribute;
	         return this
	      }
	   });
	   pe.prototype = Object.assign(Object.create(L.prototype), {
	      constructor: pe,
	      isInstancedBufferAttribute: !0,
	      copy: function(a) {
	         L.prototype.copy.call(this, a);
	         this.meshPerAttribute = a.meshPerAttribute;
	         return this
	      }
	   });
	   Object.assign(Ze.prototype, {
	      linePrecision: 1,
	      set: function(a, b) {
	         this.ray.set(a, b)
	      },
	      setFromCamera: function(a, b) {
	         b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
	      },
	      intersectObject: function(a, b) {
	         var c = [];
	         qe(a, this, c, b);
	         c.sort($e);
	         return c
	      },
	      intersectObjects: function(a, b) {
	         var c = [];
	         if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
	         for (var d = 0, e = a.length; d < e; d++) qe(a[d], this, c, b);
	         c.sort($e);
	         return c
	      }
	   });
	   Object.assign(af.prototype, {
	      start: function() {
	         this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
	         this.elapsedTime = 0;
	         this.running = !0
	      },
	      stop: function() {
	         this.getElapsedTime();
	         this.running = !1
	      },
	      getElapsedTime: function() {
	         this.getDelta();
	         return this.elapsedTime
	      },
	      getDelta: function() {
	         var a = 0;
	         if (this.autoStart && !this.running) return this.start(), 0;
	         if (this.running) {
	            var b = ("undefined" === typeof performance ? Date : performance).now(),
	               a = (b - this.oldTime) / 1e3;
	            this.oldTime = b;
	            this.elapsedTime += a
	         }
	         return a
	      }
	   });
	   Object.assign(bf.prototype, {
	      set: function(a, b, c) {
	         this.radius = a;
	         this.phi = b;
	         this.theta = c;
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.radius = a.radius;
	         this.phi = a.phi;
	         this.theta = a.theta;
	         return this
	      },
	      makeSafe: function() {
	         this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));
	         return this
	      },
	      setFromVector3: function(a) {
	         this.radius = a.length();
	         0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(Y.clamp(a.y / this.radius, -1, 1)));
	         return this
	      }
	   });
	   Object.assign(cf.prototype, {
	      set: function(a, b, c) {
	         this.radius = a;
	         this.theta = b;
	         this.y = c;
	         return this
	      },
	      clone: function() {
	         return (new this.constructor).copy(this)
	      },
	      copy: function(a) {
	         this.radius = a.radius;
	         this.theta = a.theta;
	         this.y = a.y;
	         return this
	      },
	      setFromVector3: function(a) {
	         this.radius = Math.sqrt(a.x * a.x + a.z * a.z);
	         this.theta = Math.atan2(a.x, a.z);
	         this.y = a.y;
	         return this
	      }
	   });
	   ra.prototype = Object.create(Ca.prototype);
	   ra.prototype.constructor = ra;
	   ra.prototype.createAnimation = function(a, b, c, d) {
	      b = {
	         start: b,
	         end: c,
	         length: c - b + 1,
	         fps: d,
	         duration: (c - b) / d,
	         lastFrame: 0,
	         currentFrame: 0,
	         active: !1,
	         time: 0,
	         direction: 1,
	         weight: 1,
	         directionBackwards: !1,
	         mirroredLoop: !1
	      };
	      this.animationsMap[a] = b;
	      this.animationsList.push(b)
	   };
	   ra.prototype.autoCreateAnimations = function(a) {
	      for (var b = /([a-z]+)_?(\d+)/i, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
	         var h = e.morphTargets[f].name.match(b);
	         if (h && 1 < h.length) {
	            var k = h[1];
	            d[k] || (d[k] = {
	               start: Infinity,
	               end: -Infinity
	            });
	            h = d[k];
	            f < h.start && (h.start = f);
	            f > h.end && (h.end = f);
	            c || (c = k)
	         }
	      }
	      for (k in d) h = d[k], this.createAnimation(k, h.start, h.end, a);
	      this.firstAnimation = c
	   };
	   ra.prototype.setAnimationDirectionForward = function(a) {
	      if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1
	   };
	   ra.prototype.setAnimationDirectionBackward = function(a) {
	      if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0
	   };
	   ra.prototype.setAnimationFPS = function(a, b) {
	      var c = this.animationsMap[a];
	      c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
	   };
	   ra.prototype.setAnimationDuration = function(a, b) {
	      var c = this.animationsMap[a];
	      c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
	   };
	   ra.prototype.setAnimationWeight = function(a, b) {
	      var c = this.animationsMap[a];
	      c && (c.weight = b)
	   };
	   ra.prototype.setAnimationTime = function(a, b) {
	      var c = this.animationsMap[a];
	      c && (c.time = b)
	   };
	   ra.prototype.getAnimationTime = function(a) {
	      var b = 0;
	      if (a = this.animationsMap[a]) b = a.time;
	      return b
	   };
	   ra.prototype.getAnimationDuration = function(a) {
	      var b = -1;
	      if (a = this.animationsMap[a]) b = a.duration;
	      return b
	   };
	   ra.prototype.playAnimation = function(a) {
	      var b = this.animationsMap[a];
	      b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
	   };
	   ra.prototype.stopAnimation = function(a) {
	      if (a = this.animationsMap[a]) a.active = !1
	   };
	   ra.prototype.update = function(a) {
	      for (var b = 0, c = this.animationsList.length; b < c; b++) {
	         var d = this.animationsList[b];
	         if (d.active) {
	            var e = d.duration / d.length;
	            d.time += d.direction * a;
	            if (d.mirroredLoop) {
	               if (d.time > d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)
	            } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);
	            var f = d.start + Y.clamp(Math.floor(d.time / e), 0, d.length - 1),
	               g = d.weight;
	            f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
	            e = d.time % e / e;
	            d.directionBackwards && (e = 1 - e);
	            d.currentFrame !== d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = e * g, this.morphTargetInfluences[d.lastFrame] = (1 - e) * g) : this.morphTargetInfluences[d.currentFrame] = g
	         }
	      }
	   };
	   $c.prototype = Object.create(B.prototype);
	   $c.prototype.constructor = $c;
	   $c.prototype.isImmediateRenderObject = !0;
	   ad.prototype = Object.create(da.prototype);
	   ad.prototype.constructor = ad;
	   ad.prototype.update = function() {
	      var a = new p,
	         b = new p,
	         c = new Ka;
	      return function() {
	         var d = ["a", "b", "c"];
	         this.object.updateMatrixWorld(!0);
	         c.getNormalMatrix(this.object.matrixWorld);
	         var e = this.object.matrixWorld,
	            f = this.geometry.attributes.position,
	            g = this.object.geometry;
	         if (g && g.isGeometry) for (var h = g.vertices, k = g.faces, l = g = 0, p = k.length; l < p; l++) for (var q = k[l], n = 0, r = q.vertexNormals.length; n < r; n++) {
	            var z = q.vertexNormals[n];
	            a.copy(h[q[d[n]]]).applyMatrix4(e);
	            b.copy(z).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
	            f.setXYZ(g, a.x, a.y, a.z);
	            g += 1;
	            f.setXYZ(g, b.x, b.y, b.z);
	            g += 1
	         } else if (g && g.isBufferGeometry) for (d = g.attributes.position, h = g.attributes.normal, n = g = 0, r = d.count; n < r; n++) a.set(d.getX(n), d.getY(n), d.getZ(n)).applyMatrix4(e), b.set(h.getX(n), h.getY(n), h.getZ(n)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
	         f.needsUpdate = !0
	      }
	   }();
	   lc.prototype = Object.create(B.prototype);
	   lc.prototype.constructor = lc;
	   lc.prototype.dispose = function() {
	      this.cone.geometry.dispose();
	      this.cone.material.dispose()
	   };
	   lc.prototype.update = function() {
	      var a = new p,
	         b = new p;
	      return function() {
	         var c = this.light.distance ? this.light.distance : 1e3,
	            d = c * Math.tan(this.light.angle);
	         this.cone.scale.set(d, d, c);
	         a.setFromMatrixPosition(this.light.matrixWorld);
	         b.setFromMatrixPosition(this.light.target.matrixWorld);
	         this.cone.lookAt(b.sub(a));
	         this.cone.material.color.copy(this.light.color)
	      }
	   }();
	   mc.prototype = Object.create(da.prototype);
	   mc.prototype.constructor = mc;
	   mc.prototype.getBoneList = function(a) {
	      var b = [];
	      a && a.isBone && b.push(a);
	      for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
	      return b
	   };
	   mc.prototype.update = function() {
	      var a = new p,
	         b = new J,
	         c = new J;
	      return function() {
	         var d = this.geometry,
	            e = d.getAttribute("position");
	         c.getInverse(this.root.matrixWorld);
	         for (var f = 0, g = 0; f < this.bones.length; f++) {
	            var h = this.bones[f];
	            h.parent && h.parent.isBone && (b.multiplyMatrices(c, h.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g, a.x, a.y, a.z), b.multiplyMatrices(c, h.parent.matrixWorld), a.setFromMatrixPosition(b), e.setXYZ(g + 1, a.x, a.y, a.z), g += 2)
	         }
	         d.getAttribute("position").needsUpdate = !0
	      }
	   }();
	   nc.prototype = Object.create(Ca.prototype);
	   nc.prototype.constructor = nc;
	   nc.prototype.dispose = function() {
	      this.geometry.dispose();
	      this.material.dispose()
	   };
	   nc.prototype.update = function() {
	      this.material.color.copy(this.light.color)
	   };
	   oc.prototype = Object.create(B.prototype);
	   oc.prototype.constructor = oc;
	   oc.prototype.dispose = function() {
	      this.children[0].geometry.dispose();
	      this.children[0].material.dispose()
	   };
	   oc.prototype.update = function() {
	      var a = this.children[0];
	      a.material.color.copy(this.light.color);
	      var b = .5 * this.light.width,
	         c = .5 * this.light.height,
	         a = a.geometry.attributes.position,
	         d = a.array;
	      d[0] = b;
	      d[1] = -c;
	      d[2] = 0;
	      d[3] = b;
	      d[4] = c;
	      d[5] = 0;
	      d[6] = -b;
	      d[7] = c;
	      d[8] = 0;
	      d[9] = -b;
	      d[10] = -c;
	      d[11] = 0;
	      d[12] = b;
	      d[13] = -c;
	      d[14] = 0;
	      a.needsUpdate = !0
	   };
	   pc.prototype = Object.create(B.prototype);
	   pc.prototype.constructor = pc;
	   pc.prototype.dispose = function() {
	      this.children[0].geometry.dispose();
	      this.children[0].material.dispose()
	   };
	   pc.prototype.update = function() {
	      var a = new p,
	         b = new H,
	         c = new H;
	      return function() {
	         var d = this.children[0],
	            e = d.geometry.getAttribute("color");
	         b.copy(this.light.color);
	         c.copy(this.light.groundColor);
	         for (var f = 0, g = e.count; f < g; f++) {
	            var h = f < g / 2 ? b : c;
	            e.setXYZ(f, h.r, h.g, h.b)
	         }
	         d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
	         e.needsUpdate = !0
	      }
	   }();
	   bd.prototype = Object.create(da.prototype);
	   bd.prototype.constructor = bd;
	   Kd.prototype = Object.create(da.prototype);
	   Kd.prototype.constructor = Kd;
	   cd.prototype = Object.create(da.prototype);
	   cd.prototype.constructor = cd;
	   cd.prototype.update = function() {
	      var a = new p,
	         b = new p,
	         c = new Ka;
	      return function() {
	         this.object.updateMatrixWorld(!0);
	         c.getNormalMatrix(this.object.matrixWorld);
	         for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, f = f.faces, h = 0, k = 0, l = f.length; k < l; k++) {
	            var p = f[k],
	               q = p.normal;
	            a.copy(g[p.a]).add(g[p.b]).add(g[p.c]).divideScalar(3).applyMatrix4(d);
	            b.copy(q).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
	            e.setXYZ(h, a.x, a.y, a.z);
	            h += 1;
	            e.setXYZ(h, b.x, b.y, b.z);
	            h += 1
	         }
	         e.needsUpdate = !0
	      }
	   }();
	   qc.prototype = Object.create(B.prototype);
	   qc.prototype.constructor = qc;
	   qc.prototype.dispose = function() {
	      var a = this.children[0],
	         b = this.children[1];
	      a.geometry.dispose();
	      a.material.dispose();
	      b.geometry.dispose();
	      b.material.dispose()
	   };
	   qc.prototype.update = function() {
	      var a = new p,
	         b = new p,
	         c = new p;
	      return function() {
	         a.setFromMatrixPosition(this.light.matrixWorld);
	         b.setFromMatrixPosition(this.light.target.matrixWorld);
	         c.subVectors(b, a);
	         var d = this.children[0],
	            e = this.children[1];
	         d.lookAt(c);
	         d.material.color.copy(this.light.color);
	         e.lookAt(c);
	         e.scale.z = c.length()
	      }
	   }();
	   dd.prototype = Object.create(da.prototype);
	   dd.prototype.constructor = dd;
	   dd.prototype.update = function() {
	      function a(a, g, h, k) {
	         d.set(g, h, k).unproject(e);
	         a = c[a];
	         if (void 0 !== a) for (g = b.getAttribute("position"), h = 0, k = a.length; h < k; h++) g.setXYZ(a[h], d.x, d.y, d.z)
	      }
	      var b, c, d = new p,
	         e = new Oa;
	      return function() {
	         b = this.geometry;
	         c = this.pointMap;
	         e.projectionMatrix.copy(this.camera.projectionMatrix);
	         a("c", 0, 0, -1);
	         a("t", 0, 0, 1);
	         a("n1", -1, -1, -1);
	         a("n2", 1, -1, -1);
	         a("n3", -1, 1, -1);
	         a("n4", 1, 1, -1);
	         a("f1", -1, -1, 1);
	         a("f2", 1, -1, 1);
	         a("f3", -1, 1, 1);
	         a("f4", 1, 1, 1);
	         a("u1", .7, 1.1, -1);
	         a("u2", -.7, 1.1, -1);
	         a("u3", 0, 2, -1);
	         a("cf1", -1, 0, 1);
	         a("cf2", 1, 0, 1);
	         a("cf3", 0, -1, 1);
	         a("cf4", 0, 1, 1);
	         a("cn1", -1, 0, -1);
	         a("cn2", 1, 0, -1);
	         a("cn3", 0, -1, -1);
	         a("cn4", 0, 1, -1);
	         b.getAttribute("position").needsUpdate = !0
	      }
	   }();
	   Bb.prototype = Object.create(da.prototype);
	   Bb.prototype.constructor = Bb;
	   Bb.prototype.update = function() {
	      var a = new Ta;
	      return function(b) {
	         void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
	         void 0 !== this.object && a.setFromObject(this.object);
	         if (!a.isEmpty()) {
	            b = a.min;
	            var c = a.max,
	               d = this.geometry.attributes.position,
	               e = d.array;
	            e[0] = c.x;
	            e[1] = c.y;
	            e[2] = c.z;
	            e[3] = b.x;
	            e[4] = c.y;
	            e[5] = c.z;
	            e[6] = b.x;
	            e[7] = b.y;
	            e[8] = c.z;
	            e[9] = c.x;
	            e[10] = b.y;
	            e[11] = c.z;
	            e[12] = c.x;
	            e[13] = c.y;
	            e[14] = b.z;
	            e[15] = b.x;
	            e[16] = c.y;
	            e[17] = b.z;
	            e[18] = b.x;
	            e[19] = b.y;
	            e[20] = b.z;
	            e[21] = c.x;
	            e[22] = b.y;
	            e[23] = b.z;
	            d.needsUpdate = !0;
	            this.geometry.computeBoundingSphere()
	         }
	      }
	   }();
	   Bb.prototype.setFromObject = function(a) {
	      this.object = a;
	      this.update();
	      return this
	   };
	   var Ld, re;
	   Cb.prototype = Object.create(B.prototype);
	   Cb.prototype.constructor = Cb;
	   Cb.prototype.setDirection = function() {
	      var a = new p,
	         b;
	      return function(c) {.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
	      }
	   }();
	   Cb.prototype.setLength = function(a, b, c) {
	      void 0 === b && (b = .2 * a);
	      void 0 === c && (c = .2 * b);
	      this.line.scale.set(1, Math.max(0, a - b), 1);
	      this.line.updateMatrix();
	      this.cone.scale.set(c, b, c);
	      this.cone.position.y = a;
	      this.cone.updateMatrix()
	   };
	   Cb.prototype.setColor = function(a) {
	      this.line.material.color.copy(a);
	      this.cone.material.color.copy(a)
	   };
	   Md.prototype = Object.create(da.prototype);
	   Md.prototype.constructor = Md;
	   var Pd = new p,
	      ve = new se,
	      we = new se,
	      xe = new se;
	   Ja.prototype = Object.create(na.prototype);
	   Ja.prototype.constructor = Ja;
	   Ja.prototype.getPoint = function(a) {
	      var b = this.points,
	         c = b.length;
	      2 > c && console.log("duh, you need at least 2 points");
	      a *= c - (this.closed ? 0 : 1);
	      var d = Math.floor(a);
	      a -= d;
	      this.closed ? d += 0 < d ? 0 : (Math.floor(Math.abs(d) / b.length) + 1) * b.length : 0 === a && d === c - 1 && (d = c - 2, a = 1);
	      var e, f, g;
	      this.closed || 0 < d ? e = b[(d - 1) % c] : (Pd.subVectors(b[0], b[1]).add(b[0]), e = Pd);
	      f = b[d % c];
	      g = b[(d + 1) % c];
	      this.closed || d + 2 < c ? b = b[(d + 2) % c] : (Pd.subVectors(b[c - 1], b[c - 2]).add(b[c - 1]), b = Pd);
	      if (void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
	         var h = "chordal" === this.type ? .5 : .25,
	            c = Math.pow(e.distanceToSquared(f), h),
	            d = Math.pow(f.distanceToSquared(g), h),
	            h = Math.pow(g.distanceToSquared(b), h);
	         1e-4 > d && (d = 1);
	         1e-4 > c && (c = d);
	         1e-4 > h && (h = d);
	         ve.initNonuniformCatmullRom(e.x, f.x, g.x, b.x, c, d, h);
	         we.initNonuniformCatmullRom(e.y, f.y, g.y, b.y, c, d, h);
	         xe.initNonuniformCatmullRom(e.z, f.z, g.z, b.z, c, d, h)
	      } else "catmullrom" === this.type && (c = void 0 !== this.tension ? this.tension : .5, ve.initCatmullRom(e.x, f.x, g.x, b.x, c), we.initCatmullRom(e.y, f.y, g.y, b.y, c), xe.initCatmullRom(e.z, f.z, g.z, b.z, c));
	      return new p(ve.calc(a), we.calc(a), xe.calc(a))
	   };
	   ed.prototype = Object.create(na.prototype);
	   ed.prototype.constructor = ed;
	   ed.prototype.getPoint = function(a) {
	      var b = this.v0,
	         c = this.v1,
	         d = this.v2,
	         e = this.v3;
	      return new p(yb(a, b.x, c.x, d.x, e.x), yb(a, b.y, c.y, d.y, e.y), yb(a, b.z, c.z, d.z, e.z))
	   };
	   fd.prototype = Object.create(na.prototype);
	   fd.prototype.constructor = fd;
	   fd.prototype.getPoint = function(a) {
	      var b = this.v0,
	         c = this.v1,
	         d = this.v2;
	      return new p(xb(a, b.x, c.x, d.x), xb(a, b.y, c.y, d.y), xb(a, b.z, c.z, d.z))
	   };
	   gd.prototype = Object.create(na.prototype);
	   gd.prototype.constructor = gd;
	   gd.prototype.getPoint = function(a) {
	      if (1 === a) return this.v2.clone();
	      var b = new p;
	      b.subVectors(this.v2, this.v1);
	      b.multiplyScalar(a);
	      b.add(this.v1);
	      return b
	   };
	   Nd.prototype = Object.create(Xa.prototype);
	   Nd.prototype.constructor = Nd;
	   na.create = function(a, b) {
	      console.log("THREE.Curve.create() has been deprecated");
	      a.prototype = Object.create(na.prototype);
	      a.prototype.constructor = a;
	      a.prototype.getPoint = b;
	      return a
	   };
	   df.prototype = Object.create(Ja.prototype);
	   ef.prototype = Object.create(Ja.prototype);
	   te.prototype = Object.create(Ja.prototype);
	   Object.assign(te.prototype, {
	      initFromArray: function(a) {
	         console.error("THREE.Spline: .initFromArray() has been removed.")
	      },
	      getControlPointsArray: function(a) {
	         console.error("THREE.Spline: .getControlPointsArray() has been removed.")
	      },
	      reparametrizeByArcLength: function(a) {
	         console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
	      }
	   });
	   bd.prototype.setColors = function() {
	      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
	   };
	   Object.assign(id.prototype, {
	      center: function(a) {
	         console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
	         return this.getCenter(a)
	      },
	      empty: function() {
	         console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
	         return this.isEmpty()
	      },
	      isIntersectionBox: function(a) {
	         console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
	         return this.intersectsBox(a)
	      },
	      size: function(a) {
	         console.warn("THREE.Box2: .size() has been renamed to .getSize().");
	         return this.getSize(a)
	      }
	   });
	   Object.assign(Ta.prototype, {
	      center: function(a) {
	         console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
	         return this.getCenter(a)
	      },
	      empty: function() {
	         console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
	         return this.isEmpty()
	      },
	      isIntersectionBox: function(a) {
	         console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
	         return this.intersectsBox(a)
	      },
	      isIntersectionSphere: function(a) {
	         console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
	         return this.intersectsSphere(a)
	      },
	      size: function(a) {
	         console.warn("THREE.Box3: .size() has been renamed to .getSize().");
	         return this.getSize(a)
	      }
	   });
	   Hb.prototype.center = function(a) {
	      console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
	      return this.getCenter(a)
	   };
	   Y.random16 = function() {
	      console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
	      return Math.random()
	   };
	   Object.assign(Ka.prototype, {
	      flattenToArrayOffset: function(a, b) {
	         console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
	         return this.toArray(a, b)
	      },
	      multiplyVector3: function(a) {
	         console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
	         return a.applyMatrix3(this)
	      },
	      multiplyVector3Array: function(a) {
	         console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
	         return this.applyToVector3Array(a)
	      },
	      applyToBuffer: function(a, b, c) {
	         console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
	         return this.applyToBufferAttribute(a)
	      },
	      applyToVector3Array: function(a, b, c) {
	         console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
	      }
	   });
	   Object.assign(J.prototype, {
	      extractPosition: function(a) {
	         console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
	         return this.copyPosition(a)
	      },
	      flattenToArrayOffset: function(a, b) {
	         console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
	         return this.toArray(a, b)
	      },
	      getPosition: function() {
	         var a;
	         return function() {
	            void 0 === a && (a = new p);
	            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
	            return a.setFromMatrixColumn(this, 3)
	         }
	      }(),
	      setRotationFromQuaternion: function(a) {
	         console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
	         return this.makeRotationFromQuaternion(a)
	      },
	      multiplyToArray: function() {
	         console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
	      },
	      multiplyVector3: function(a) {
	         console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
	         return a.applyMatrix4(this)
	      },
	      multiplyVector4: function(a) {
	         console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
	         return a.applyMatrix4(this)
	      },
	      multiplyVector3Array: function(a) {
	         console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
	         return this.applyToVector3Array(a)
	      },
	      rotateAxis: function(a) {
	         console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
	         a.transformDirection(this)
	      },
	      crossVector: function(a) {
	         console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
	         return a.applyMatrix4(this)
	      },
	      translate: function() {
	         console.error("THREE.Matrix4: .translate() has been removed.")
	      },
	      rotateX: function() {
	         console.error("THREE.Matrix4: .rotateX() has been removed.")
	      },
	      rotateY: function() {
	         console.error("THREE.Matrix4: .rotateY() has been removed.")
	      },
	      rotateZ: function() {
	         console.error("THREE.Matrix4: .rotateZ() has been removed.")
	      },
	      rotateByAxis: function() {
	         console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
	      },
	      applyToBuffer: function(a, b, c) {
	         console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
	         return this.applyToBufferAttribute(a)
	      },
	      applyToVector3Array: function(a, b, c) {
	         console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
	      },
	      makeFrustum: function(a, b, c, d, e, f) {
	         console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
	         return this.makePerspective(a, b, d, c, e, f)
	      }
	   });
	   wa.prototype.isIntersectionLine = function(a) {
	      console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
	      return this.intersectsLine(a)
	   };
	   qa.prototype.multiplyVector3 = function(a) {
	      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
	      return a.applyQuaternion(this)
	   };
	   Object.assign(hb.prototype, {
	      isIntersectionBox: function(a) {
	         console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
	         return this.intersectsBox(a)
	      },
	      isIntersectionPlane: function(a) {
	         console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
	         return this.intersectsPlane(a)
	      },
	      isIntersectionSphere: function(a) {
	         console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
	         return this.intersectsSphere(a)
	      }
	   });
	   Object.assign(Ab.prototype, {
	      extrude: function(a) {
	         console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
	         return new db(this, a)
	      },
	      makeGeometry: function(a) {
	         console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
	         return new Zb(this, a)
	      }
	   });
	   Object.assign(D.prototype, {
	      fromAttribute: function(a, b, c) {
	         console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
	         return this.fromBufferAttribute(a, b, c)
	      }
	   });
	   Object.assign(p.prototype, {
	      setEulerFromRotationMatrix: function() {
	         console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
	      },
	      setEulerFromQuaternion: function() {
	         console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
	      },
	      getPositionFromMatrix: function(a) {
	         console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
	         return this.setFromMatrixPosition(a)
	      },
	      getScaleFromMatrix: function(a) {
	         console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
	         return this.setFromMatrixScale(a)
	      },
	      getColumnFromMatrix: function(a, b) {
	         console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
	         return this.setFromMatrixColumn(b, a)
	      },
	      applyProjection: function(a) {
	         console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
	         return this.applyMatrix4(a)
	      },
	      fromAttribute: function(a, b, c) {
	         console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
	         return this.fromBufferAttribute(a, b, c)
	      }
	   });
	   Object.assign(ga.prototype, {
	      fromAttribute: function(a, b, c) {
	         console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
	         return this.fromBufferAttribute(a, b, c)
	      }
	   });
	   M.prototype.computeTangents = function() {
	      console.warn("THREE.Geometry: .computeTangents() has been removed.")
	   };
	   Object.assign(B.prototype, {
	      getChildByName: function(a) {
	         console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
	         return this.getObjectByName(a)
	      },
	      renderDepth: function() {
	         console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
	      },
	      translate: function(a, b) {
	         console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
	         return this.translateOnAxis(b, a)
	      }
	   });
	   Object.defineProperties(B.prototype, {
	      eulerOrder: {
	         get: function() {
	            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
	            return this.rotation.order
	         },
	         set: function(a) {
	            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
	            this.rotation.order = a
	         }
	      },
	      useQuaternion: {
	         get: function() {
	            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
	         },
	         set: function() {
	            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
	         }
	      }
	   });
	   Object.defineProperties(Bc.prototype, {
	      objects: {
	         get: function() {
	            console.warn("THREE.LOD: .objects has been renamed to .levels.");
	            return this.levels
	         }
	      }
	   });
	   Object.defineProperty(Cc.prototype, "useVertexTexture", {
	      get: function() {
	         console.warn("THREE.Skeleton: useVertexTexture has been removed.")
	      },
	      set: function() {
	         console.warn("THREE.Skeleton: useVertexTexture has been removed.")
	      }
	   });
	   Object.defineProperty(na.prototype, "__arcLengthDivisions", {
	      get: function() {
	         console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
	         return this.arcLengthDivisions
	      },
	      set: function(a) {
	         console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
	         this.arcLengthDivisions = a
	      }
	   });
	   xa.prototype.setLens = function(a, b) {
	      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
	      void 0 !== b && (this.filmGauge = b);
	      this.setFocalLength(a)
	   };
	   Object.defineProperties(ma.prototype, {
	      onlyShadow: {
	         set: function() {
	            console.warn("THREE.Light: .onlyShadow has been removed.")
	         }
	      },
	      shadowCameraFov: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
	            this.shadow.camera.fov = a
	         }
	      },
	      shadowCameraLeft: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
	            this.shadow.camera.left = a
	         }
	      },
	      shadowCameraRight: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
	            this.shadow.camera.right = a
	         }
	      },
	      shadowCameraTop: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
	            this.shadow.camera.top = a
	         }
	      },
	      shadowCameraBottom: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
	            this.shadow.camera.bottom = a
	         }
	      },
	      shadowCameraNear: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
	            this.shadow.camera.near = a
	         }
	      },
	      shadowCameraFar: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
	            this.shadow.camera.far = a
	         }
	      },
	      shadowCameraVisible: {
	         set: function() {
	            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
	         }
	      },
	      shadowBias: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
	            this.shadow.bias = a
	         }
	      },
	      shadowDarkness: {
	         set: function() {
	            console.warn("THREE.Light: .shadowDarkness has been removed.")
	         }
	      },
	      shadowMapWidth: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
	            this.shadow.mapSize.width = a
	         }
	      },
	      shadowMapHeight: {
	         set: function(a) {
	            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
	            this.shadow.mapSize.height = a
	         }
	      }
	   });
	   Object.defineProperties(L.prototype, {
	      length: {
	         get: function() {
	            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
	            return this.array.length
	         }
	      }
	   });
	   Object.assign(I.prototype, {
	      addIndex: function(a) {
	         console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
	         this.setIndex(a)
	      },
	      addDrawCall: function(a, b, c) {
	         void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
	         console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
	         this.addGroup(a, b)
	      },
	      clearDrawCalls: function() {
	         console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
	         this.clearGroups()
	      },
	      computeTangents: function() {
	         console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
	      },
	      computeOffsets: function() {
	         console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
	      }
	   });
	   Object.defineProperties(I.prototype, {
	      drawcalls: {
	         get: function() {
	            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
	            return this.groups
	         }
	      },
	      offsets: {
	         get: function() {
	            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
	            return this.groups
	         }
	      }
	   });
	   Object.defineProperties(Jd.prototype, {
	      dynamic: {
	         set: function() {
	            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
	         }
	      },
	      onUpdate: {
	         value: function() {
	            console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
	            return this
	         }
	      }
	   });
	   Object.defineProperties(Z.prototype, {
	      wrapAround: {
	         get: function() {
	            console.warn("THREE.Material: .wrapAround has been removed.")
	         },
	         set: function() {
	            console.warn("THREE.Material: .wrapAround has been removed.")
	         }
	      },
	      wrapRGB: {
	         get: function() {
	            console.warn("THREE.Material: .wrapRGB has been removed.");
	            return new H
	         }
	      }
	   });
	   Object.defineProperties(ta.prototype, {
	      metal: {
	         get: function() {
	            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
	            return !1
	         },
	         set: function() {
	            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
	         }
	      }
	   });
	   Object.defineProperties(Ea.prototype, {
	      derivatives: {
	         get: function() {
	            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
	            return this.extensions.derivatives
	         },
	         set: function(a) {
	            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
	            this.extensions.derivatives = a
	         }
	      }
	   });
	   Object.assign(Xd.prototype, {
	      getCurrentRenderTarget: function() {
	         console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
	         return this.getRenderTarget()
	      },
	      supportsFloatTextures: function() {
	         console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
	         return this.extensions.get("OES_texture_float")
	      },
	      supportsHalfFloatTextures: function() {
	         console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
	         return this.extensions.get("OES_texture_half_float")
	      },
	      supportsStandardDerivatives: function() {
	         console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
	         return this.extensions.get("OES_standard_derivatives")
	      },
	      supportsCompressedTextureS3TC: function() {
	         console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
	         return this.extensions.get("WEBGL_compressed_texture_s3tc")
	      },
	      supportsCompressedTexturePVRTC: function() {
	         console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
	         return this.extensions.get("WEBGL_compressed_texture_pvrtc")
	      },
	      supportsBlendMinMax: function() {
	         console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
	         return this.extensions.get("EXT_blend_minmax")
	      },
	      supportsVertexTextures: function() {
	         console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
	         return this.capabilities.vertexTextures
	      },
	      supportsInstancedArrays: function() {
	         console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
	         return this.extensions.get("ANGLE_instanced_arrays")
	      },
	      enableScissorTest: function(a) {
	         console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
	         this.setScissorTest(a)
	      },
	      initMaterial: function() {
	         console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
	      },
	      addPrePlugin: function() {
	         console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
	      },
	      addPostPlugin: function() {
	         console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
	      },
	      updateShadowMap: function() {
	         console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
	      }
	   });
	   Object.defineProperties(Xd.prototype, {
	      shadowMapEnabled: {
	         get: function() {
	            return this.shadowMap.enabled
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
	            this.shadowMap.enabled = a
	         }
	      },
	      shadowMapType: {
	         get: function() {
	            return this.shadowMap.type
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
	            this.shadowMap.type = a
	         }
	      },
	      shadowMapCullFace: {
	         get: function() {
	            return this.shadowMap.cullFace
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
	            this.shadowMap.cullFace = a
	         }
	      }
	   });
	   Object.defineProperties(Je.prototype, {
	      cullFace: {
	         get: function() {
	            return this.renderReverseSided ? 2 : 1
	         },
	         set: function(a) {
	            a = 1 !== a;
	            console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + ".");
	            this.renderReverseSided = a
	         }
	      }
	   });
	   Object.defineProperties(Db.prototype, {
	      wrapS: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
	            return this.texture.wrapS
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
	            this.texture.wrapS = a
	         }
	      },
	      wrapT: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
	            return this.texture.wrapT
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
	            this.texture.wrapT = a
	         }
	      },
	      magFilter: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
	            return this.texture.magFilter
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
	            this.texture.magFilter = a
	         }
	      },
	      minFilter: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
	            return this.texture.minFilter
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
	            this.texture.minFilter = a
	         }
	      },
	      anisotropy: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
	            return this.texture.anisotropy
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
	            this.texture.anisotropy = a
	         }
	      },
	      offset: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
	            return this.texture.offset
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
	            this.texture.offset = a
	         }
	      },
	      repeat: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
	            return this.texture.repeat
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
	            this.texture.repeat = a
	         }
	      },
	      format: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
	            return this.texture.format
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
	            this.texture.format = a
	         }
	      },
	      type: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
	            return this.texture.type
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
	            this.texture.type = a
	         }
	      },
	      generateMipmaps: {
	         get: function() {
	            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
	            return this.texture.generateMipmaps
	         },
	         set: function(a) {
	            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
	            this.texture.generateMipmaps = a
	         }
	      }
	   });
	   jc.prototype.load = function(a) {
	      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
	      var b = this;
	      (new fe).load(a, function(a) {
	         b.setBuffer(a)
	      });
	      return this
	   };
	   ke.prototype.getData = function() {
	      console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
	      return this.getFrequencyData()
	   };
	   l.WebGLRenderTargetCube = Eb;
	   l.WebGLRenderTarget = Db;
	   l.WebGLRenderer = Xd;
	   l.ShaderLib = ab;
	   l.UniformsLib = V;
	   l.UniformsUtils = Ha;
	   l.ShaderChunk = U;
	   l.FogExp2 = Kb;
	   l.Fog = Lb;
	   l.Scene = md;
	   l.LensFlare = Yd;
	   l.Sprite = Ac;
	   l.LOD = Bc;
	   l.SkinnedMesh = od;
	   l.Skeleton = Cc;
	   l.Bone = nd;
	   l.Mesh = Ca;
	   l.LineSegments = da;
	   l.LineLoop = pd;
	   l.Line = ya;
	   l.Points = Mb;
	   l.Group = Dc;
	   l.VideoTexture = qd;
	   l.DataTexture = eb;
	   l.CompressedTexture = Nb;
	   l.CubeTexture = Za;
	   l.CanvasTexture = rd;
	   l.DepthTexture = Ec;
	   l.Texture = X;
	   l.CompressedTextureLoader = Qe;
	   l.DataTextureLoader = $d;
	   l.CubeTextureLoader = ae;
	   l.TextureLoader = sd;
	   l.ObjectLoader = Re;
	   l.MaterialLoader = Hd;
	   l.BufferGeometryLoader = be;
	   l.DefaultLoadingManager = Aa;
	   l.LoadingManager = Zd;
	   l.JSONLoader = ce;
	   l.ImageLoader = Vc;
	   l.FontLoader = Te;
	   l.FileLoader = ua;
	   l.Loader = gc;
	   l.Cache = hd;
	   l.AudioLoader = fe;
	   l.SpotLightShadow = ud;
	   l.SpotLight = vd;
	   l.PointLight = wd;
	   l.RectAreaLight = Ad;
	   l.HemisphereLight = td;
	   l.DirectionalLightShadow = xd;
	   l.DirectionalLight = yd;
	   l.AmbientLight = zd;
	   l.LightShadow = ub;
	   l.Light = ma;
	   l.StereoCamera = Ue;
	   l.PerspectiveCamera = xa;
	   l.OrthographicCamera = Jb;
	   l.CubeCamera = Id;
	   l.ArrayCamera = ge;
	   l.Camera = Oa;
	   l.AudioListener = he;
	   l.PositionalAudio = je;
	   l.AudioContext = ie;
	   l.AudioAnalyser = ke;
	   l.Audio = jc;
	   l.VectorKeyframeTrack = ec;
	   l.StringKeyframeTrack = Ed;
	   l.QuaternionKeyframeTrack = Xc;
	   l.NumberKeyframeTrack = fc;
	   l.ColorKeyframeTrack = Gd;
	   l.BooleanKeyframeTrack = Fd;
	   l.PropertyMixer = le;
	   l.PropertyBinding = oa;
	   l.KeyframeTrack = wb;
	   l.AnimationUtils = va;
	   l.AnimationObjectGroup = We;
	   l.AnimationMixer = Ye;
	   l.AnimationClip = Ba;
	   l.Uniform = Jd;
	   l.InstancedBufferGeometry = me;
	   l.BufferGeometry = I;
	   l.GeometryIdCount = function() {
	      return Td++
	   };
	   l.Geometry = M;
	   l.InterleavedBufferAttribute = ne;
	   l.InstancedInterleavedBuffer = oe;
	   l.InterleavedBuffer = kc;
	   l.InstancedBufferAttribute = pe;
	   l.Face3 = Va;
	   l.Object3D = B;
	   l.Raycaster = Ze;
	   l.Layers = Rd;
	   l.EventDispatcher = sa;
	   l.Clock = af;
	   l.QuaternionLinearInterpolant = Dd;
	   l.LinearInterpolant = Wc;
	   l.DiscreteInterpolant = Cd;
	   l.CubicInterpolant = Bd;
	   l.Interpolant = Da;
	   l.Triangle = Ua;
	   l.Math = Y;
	   l.Spherical = bf;
	   l.Cylindrical = cf;
	   l.Plane = wa;
	   l.Frustum = jd;
	   l.Sphere = Ga;
	   l.Ray = hb;
	   l.Matrix4 = J;
	   l.Matrix3 = Ka;
	   l.Box3 = Ta;
	   l.Box2 = id;
	   l.Line3 = Hb;
	   l.Euler = bb;
	   l.Vector4 = ga;
	   l.Vector3 = p;
	   l.Vector2 = D;
	   l.Quaternion = qa;
	   l.Color = H;
	   l.MorphBlendMesh = ra;
	   l.ImmediateRenderObject = $c;
	   l.VertexNormalsHelper = ad;
	   l.SpotLightHelper = lc;
	   l.SkeletonHelper = mc;
	   l.PointLightHelper = nc;
	   l.RectAreaLightHelper = oc;
	   l.HemisphereLightHelper = pc;
	   l.GridHelper = bd;
	   l.PolarGridHelper = Kd;
	   l.FaceNormalsHelper = cd;
	   l.DirectionalLightHelper = qc;
	   l.CameraHelper = dd;
	   l.BoxHelper = Bb;
	   l.ArrowHelper = Cb;
	   l.AxisHelper = Md;
	   l.CatmullRomCurve3 = Ja;
	   l.CubicBezierCurve3 = ed;
	   l.QuadraticBezierCurve3 = fd;
	   l.LineCurve3 = gd;
	   l.ArcCurve = Nd;
	   l.EllipseCurve = Xa;
	   l.SplineCurve = zb;
	   l.CubicBezierCurve = hc;
	   l.QuadraticBezierCurve = ic;
	   l.LineCurve = Sa;
	   l.Shape = Ab;
	   l.Path = Zc;
	   l.ShapePath = de;
	   l.Font = ee;
	   l.CurvePath = Yc;
	   l.Curve = na;
	   l.ShapeUtils = za;
	   l.SceneUtils = {
	      createMultiMaterialObject: function(a, b) {
	         for (var c = new Dc, d = 0, e = b.length; d < e; d++) c.add(new Ca(a, b[d]));
	         return c
	      },
	      detach: function(a, b, c) {
	         a.applyMatrix(b.matrixWorld);
	         b.remove(a);
	         c.add(a)
	      },
	      attach: function(a, b, c) {
	         var d = new J;
	         d.getInverse(c.matrixWorld);
	         a.applyMatrix(d);
	         b.remove(a);
	         c.add(a)
	      }
	   };
	   l.WireframeGeometry = Ob;
	   l.ParametricGeometry = Fc;
	   l.ParametricBufferGeometry = Pb;
	   l.TetrahedronGeometry = Hc;
	   l.TetrahedronBufferGeometry = Qb;
	   l.OctahedronGeometry = Ic;
	   l.OctahedronBufferGeometry = mb;
	   l.IcosahedronGeometry = Jc;
	   l.IcosahedronBufferGeometry = Rb;
	   l.DodecahedronGeometry = Kc;
	   l.DodecahedronBufferGeometry = Sb;
	   l.PolyhedronGeometry = Gc;
	   l.PolyhedronBufferGeometry = ia;
	   l.TubeGeometry = Lc;
	   l.TubeBufferGeometry = Tb;
	   l.TorusKnotGeometry = Mc;
	   l.TorusKnotBufferGeometry = Ub;
	   l.TorusGeometry = Nc;
	   l.TorusBufferGeometry = Vb;
	   l.TextGeometry = Oc;
	   l.TextBufferGeometry = Wb;
	   l.SphereGeometry = Pc;
	   l.SphereBufferGeometry = nb;
	   l.RingGeometry = Qc;
	   l.RingBufferGeometry = Xb;
	   l.PlaneGeometry = xc;
	   l.PlaneBufferGeometry = lb;
	   l.LatheGeometry = Rc;
	   l.LatheBufferGeometry = Yb;
	   l.ShapeGeometry = Zb;
	   l.ShapeBufferGeometry = $b;
	   l.ExtrudeGeometry = db;
	   l.ExtrudeBufferGeometry = Fa;
	   l.EdgesGeometry = ac;
	   l.ConeGeometry = Sc;
	   l.ConeBufferGeometry = Tc;
	   l.CylinderGeometry = ob;
	   l.CylinderBufferGeometry = Wa;
	   l.CircleGeometry = Uc;
	   l.CircleBufferGeometry = bc;
	   l.BoxGeometry = Ib;
	   l.BoxBufferGeometry = kb;
	   l.ShadowMaterial = cc;
	   l.SpriteMaterial = cb;
	   l.RawShaderMaterial = dc;
	   l.ShaderMaterial = Ea;
	   l.PointsMaterial = La;
	   l.MeshPhysicalMaterial = pb;
	   l.MeshStandardMaterial = Ra;
	   l.MeshPhongMaterial = ta;
	   l.MeshToonMaterial = qb;
	   l.MeshNormalMaterial = rb;
	   l.MeshLambertMaterial = sb;
	   l.MeshDepthMaterial = $a;
	   l.MeshBasicMaterial = Na;
	   l.LineDashedMaterial = tb;
	   l.LineBasicMaterial = ha;
	   l.Material = Z;
	   l.Float64BufferAttribute = wc;
	   l.Float32BufferAttribute = C;
	   l.Uint32BufferAttribute = jb;
	   l.Int32BufferAttribute = vc;
	   l.Uint16BufferAttribute = ib;
	   l.Int16BufferAttribute = uc;
	   l.Uint8ClampedBufferAttribute = tc;
	   l.Uint8BufferAttribute = sc;
	   l.Int8BufferAttribute = rc;
	   l.BufferAttribute = L;
	   l.REVISION = "85";
	   l.MOUSE = {
	      LEFT: 0,
	      MIDDLE: 1,
	      RIGHT: 2
	   };
	   l.CullFaceNone = 0;
	   l.CullFaceBack = 1;
	   l.CullFaceFront = 2;
	   l.CullFaceFrontBack = 3;
	   l.FrontFaceDirectionCW = 0;
	   l.FrontFaceDirectionCCW = 1;
	   l.BasicShadowMap = 0;
	   l.PCFShadowMap = 1;
	   l.PCFSoftShadowMap = 2;
	   l.FrontSide = 0;
	   l.BackSide = 1;
	   l.DoubleSide = 2;
	   l.FlatShading = 1;
	   l.SmoothShading = 2;
	   l.NoColors = 0;
	   l.FaceColors = 1;
	   l.VertexColors = 2;
	   l.NoBlending = 0;
	   l.NormalBlending = 1;
	   l.AdditiveBlending = 2;
	   l.SubtractiveBlending = 3;
	   l.MultiplyBlending = 4;
	   l.CustomBlending = 5;
	   l.AddEquation = 100;
	   l.SubtractEquation = 101;
	   l.ReverseSubtractEquation = 102;
	   l.MinEquation = 103;
	   l.MaxEquation = 104;
	   l.ZeroFactor = 200;
	   l.OneFactor = 201;
	   l.SrcColorFactor = 202;
	   l.OneMinusSrcColorFactor = 203;
	   l.SrcAlphaFactor = 204;
	   l.OneMinusSrcAlphaFactor = 205;
	   l.DstAlphaFactor = 206;
	   l.OneMinusDstAlphaFactor = 207;
	   l.DstColorFactor = 208;
	   l.OneMinusDstColorFactor = 209;
	   l.SrcAlphaSaturateFactor = 210;
	   l.NeverDepth = 0;
	   l.AlwaysDepth = 1;
	   l.LessDepth = 2;
	   l.LessEqualDepth = 3;
	   l.EqualDepth = 4;
	   l.GreaterEqualDepth = 5;
	   l.GreaterDepth = 6;
	   l.NotEqualDepth = 7;
	   l.MultiplyOperation = 0;
	   l.MixOperation = 1;
	   l.AddOperation = 2;
	   l.NoToneMapping = 0;
	   l.LinearToneMapping = 1;
	   l.ReinhardToneMapping = 2;
	   l.Uncharted2ToneMapping = 3;
	   l.CineonToneMapping = 4;
	   l.UVMapping = 300;
	   l.CubeReflectionMapping = 301;
	   l.CubeRefractionMapping = 302;
	   l.EquirectangularReflectionMapping = 303;
	   l.EquirectangularRefractionMapping = 304;
	   l.SphericalReflectionMapping = 305;
	   l.CubeUVReflectionMapping = 306;
	   l.CubeUVRefractionMapping = 307;
	   l.RepeatWrapping = 1e3;
	   l.ClampToEdgeWrapping = 1001;
	   l.MirroredRepeatWrapping = 1002;
	   l.NearestFilter = 1003;
	   l.NearestMipMapNearestFilter = 1004;
	   l.NearestMipMapLinearFilter = 1005;
	   l.LinearFilter = 1006;
	   l.LinearMipMapNearestFilter = 1007;
	   l.LinearMipMapLinearFilter = 1008;
	   l.UnsignedByteType = 1009;
	   l.ByteType = 1010;
	   l.ShortType = 1011;
	   l.UnsignedShortType = 1012;
	   l.IntType = 1013;
	   l.UnsignedIntType = 1014;
	   l.FloatType = 1015;
	   l.HalfFloatType = 1016;
	   l.UnsignedShort4444Type = 1017;
	   l.UnsignedShort5551Type = 1018;
	   l.UnsignedShort565Type = 1019;
	   l.UnsignedInt248Type = 1020;
	   l.AlphaFormat = 1021;
	   l.RGBFormat = 1022;
	   l.RGBAFormat = 1023;
	   l.LuminanceFormat = 1024;
	   l.LuminanceAlphaFormat = 1025;
	   l.RGBEFormat = 1023;
	   l.DepthFormat = 1026;
	   l.DepthStencilFormat = 1027;
	   l.RGB_S3TC_DXT1_Format = 2001;
	   l.RGBA_S3TC_DXT1_Format = 2002;
	   l.RGBA_S3TC_DXT3_Format = 2003;
	   l.RGBA_S3TC_DXT5_Format = 2004;
	   l.RGB_PVRTC_4BPPV1_Format = 2100;
	   l.RGB_PVRTC_2BPPV1_Format = 2101;
	   l.RGBA_PVRTC_4BPPV1_Format = 2102;
	   l.RGBA_PVRTC_2BPPV1_Format = 2103;
	   l.RGB_ETC1_Format = 2151;
	   l.LoopOnce = 2200;
	   l.LoopRepeat = 2201;
	   l.LoopPingPong = 2202;
	   l.InterpolateDiscrete = 2300;
	   l.InterpolateLinear = 2301;
	   l.InterpolateSmooth = 2302;
	   l.ZeroCurvatureEnding = 2400;
	   l.ZeroSlopeEnding = 2401;
	   l.WrapAroundEnding = 2402;
	   l.TrianglesDrawMode = 0;
	   l.TriangleStripDrawMode = 1;
	   l.TriangleFanDrawMode = 2;
	   l.LinearEncoding = 3e3;
	   l.sRGBEncoding = 3001;
	   l.GammaEncoding = 3007;
	   l.RGBEEncoding = 3002;
	   l.LogLuvEncoding = 3003;
	   l.RGBM7Encoding = 3004;
	   l.RGBM16Encoding = 3005;
	   l.RGBDEncoding = 3006;
	   l.BasicDepthPacking = 3200;
	   l.RGBADepthPacking = 3201;
	   l.CubeGeometry = Ib;
	   l.Face4 = function(a, b, c, d, e, f, g) {
	      console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
	      return new Va(a, b, c, e, f, g)
	   };
	   l.LineStrip = 0;
	   l.LinePieces = 1;
	   l.MeshFaceMaterial = function(a) {
	      console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
	      return a
	   };
	   l.MultiMaterial = function(a) {
	      void 0 === a && (a = []);
	      console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
	      a.isMultiMaterial = !0;
	      a.materials = a;
	      a.clone = function() {
	         return a.slice()
	      };
	      return a
	   };
	   l.PointCloud = function(a, b) {
	      console.warn("THREE.PointCloud has been renamed to THREE.Points.");
	      return new Mb(a, b)
	   };
	   l.Particle = function(a) {
	      console.warn("THREE.Particle has been renamed to THREE.Sprite.");
	      return new Ac(a)
	   };
	   l.ParticleSystem = function(a, b) {
	      console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
	      return new Mb(a, b)
	   };
	   l.PointCloudMaterial = function(a) {
	      console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
	      return new La(a)
	   };
	   l.ParticleBasicMaterial = function(a) {
	      console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
	      return new La(a)
	   };
	   l.ParticleSystemMaterial = function(a) {
	      console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
	      return new La(a)
	   };
	   l.Vertex = function(a, b, c) {
	      console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
	      return new p(a, b, c)
	   };
	   l.DynamicBufferAttribute = function(a, b) {
	      console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
	      return new L(a, b).setDynamic(!0)
	   };
	   l.Int8Attribute = function(a, b) {
	      console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
	      return new rc(a, b)
	   };
	   l.Uint8Attribute = function(a, b) {
	      console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
	      return new sc(a, b)
	   };
	   l.Uint8ClampedAttribute = function(a, b) {
	      console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
	      return new tc(a, b)
	   };
	   l.Int16Attribute = function(a, b) {
	      console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
	      return new uc(a, b)
	   };
	   l.Uint16Attribute = function(a, b) {
	      console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
	      return new ib(a, b)
	   };
	   l.Int32Attribute = function(a, b) {
	      console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
	      return new vc(a, b)
	   };
	   l.Uint32Attribute = function(a, b) {
	      console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
	      return new jb(a, b)
	   };
	   l.Float32Attribute = function(a, b) {
	      console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
	      return new C(a, b)
	   };
	   l.Float64Attribute = function(a, b) {
	      console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
	      return new wc(a, b)
	   };
	   l.ClosedSplineCurve3 = df;
	   l.SplineCurve3 = ef;
	   l.Spline = te;
	   l.BoundingBoxHelper = function(a, b) {
	      console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
	      return new Bb(a, b)
	   };
	   l.EdgesHelper = function(a, b) {
	      console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
	      return new da(new ac(a.geometry), new ha({
	         color: void 0 !== b ? b : 16777215
	      }))
	   };
	   l.WireframeHelper = function(a, b) {
	      console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
	      return new da(new Ob(a.geometry), new ha({
	         color: void 0 !== b ? b : 16777215
	      }))
	   };
	   l.XHRLoader = function(a) {
	      console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
	      return new ua(a)
	   };
	   l.BinaryTextureLoader = function(a) {
	      console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
	      return new $d(a)
	   };
	   l.GeometryUtils = {
	      merge: function(a, b, c) {
	         console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
	         var d;
	         b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
	         a.merge(b, d, c)
	      },
	      center: function(a) {
	         console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
	         return a.center()
	      }
	   };
	   l.ImageUtils = {
	      crossOrigin: void 0,
	      loadTexture: function(a, b, c, d) {
	         console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
	         var e = new sd;
	         e.setCrossOrigin(this.crossOrigin);
	         a = e.load(a, c, void 0, d);
	         b && (a.mapping = b);
	         return a
	      },
	      loadTextureCube: function(a, b, c, d) {
	         console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
	         var e = new ae;
	         e.setCrossOrigin(this.crossOrigin);
	         a = e.load(a, c, void 0, d);
	         b && (a.mapping = b);
	         return a
	      },
	      loadCompressedTexture: function() {
	         console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
	      },
	      loadCompressedTextureCube: function() {
	         console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
	      }
	   };
	   l.Projector = function() {
	      console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
	      this.projectVector = function(a, b) {
	         console.warn("THREE.Projector: .projectVector() is now vector.project().");
	         a.project(b)
	      };
	      this.unprojectVector = function(a, b) {
	         console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
	         a.unproject(b)
	      };
	      this.pickingRay = function() {
	         console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
	      }
	   };
	   l.CanvasRenderer = function() {
	      console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
	      this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	      this.clear = function() {};
	      this.render = function() {};
	      this.setClearColor = function() {};
	      this.setSize = function() {}
	   };
	   Object.defineProperty(l, "__esModule", {
	      value: !0
	   })
	});
	THREE.Animation = function(root, data) {
	   this.root = root;
	   this.data = THREE.AnimationHandler.init(data);
	   this.hierarchy = THREE.AnimationHandler.parse(root);
	   this.currentTime = 0;
	   this.timeScale = 1;
	   this.isPlaying = false;
	   this.loop = true;
	   this.weight = 0;
	   this.interpolationType = THREE.AnimationHandler.LINEAR
	};
	THREE.Animation.prototype = {
	   constructor: THREE.Animation,
	   keyTypes: ["pos", "rot", "scl"],
	   play: function(startTime, weight) {
	      this.currentTime = startTime !== undefined ? startTime : 0;
	      this.weight = weight !== undefined ? weight : 1;
	      this.isPlaying = true;
	      this.reset();
	      THREE.AnimationHandler.play(this)
	   },
	   stop: function() {
	      this.isPlaying = false;
	      THREE.AnimationHandler.stop(this)
	   },
	   reset: function() {
	      for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
	         var object = this.hierarchy[h];
	         if (object.animationCache === undefined) {
	            object.animationCache = {
	               animations: {},
	               blending: {
	                  positionWeight: 0,
	                  quaternionWeight: 0,
	                  scaleWeight: 0
	               }
	            }
	         }
	         var name = this.data.name;
	         var animations = object.animationCache.animations;
	         var animationCache = animations[name];
	         if (animationCache === undefined) {
	            animationCache = {
	               prevKey: {
	                  pos: 0,
	                  rot: 0,
	                  scl: 0
	               },
	               nextKey: {
	                  pos: 0,
	                  rot: 0,
	                  scl: 0
	               },
	               originalMatrix: object.matrix
	            };
	            animations[name] = animationCache
	         }
	         for (var t = 0; t < 3; t++) {
	            var type = this.keyTypes[t];
	            var prevKey = this.data.hierarchy[h].keys[0];
	            var nextKey = this.getNextKeyWith(type, h, 1);
	            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
	               prevKey = nextKey;
	               nextKey = this.getNextKeyWith(type, h, nextKey.index + 1)
	            }
	            animationCache.prevKey[type] = prevKey;
	            animationCache.nextKey[type] = nextKey
	         }
	      }
	   },
	   resetBlendWeights: function() {
	      for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
	         var object = this.hierarchy[h];
	         var animationCache = object.animationCache;
	         if (animationCache !== undefined) {
	            var blending = animationCache.blending;
	            blending.positionWeight = 0;
	            blending.quaternionWeight = 0;
	            blending.scaleWeight = 0
	         }
	      }
	   },
	   update: function() {
	      var points = [];
	      var target = new THREE.Vector3;
	      var newVector = new THREE.Vector3;
	      var newQuat = new THREE.Quaternion;
	      var interpolateCatmullRom = function(points, scale) {
	            var c = [],
	               v3 = [],
	               point, intPoint, weight, w2, w3, pa, pb, pc, pd;
	            point = (points.length - 1) * scale;
	            intPoint = Math.floor(point);
	            weight = point - intPoint;
	            c[0] = intPoint === 0 ? intPoint : intPoint - 1;
	            c[1] = intPoint;
	            c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
	            c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
	            pa = points[c[0]];
	            pb = points[c[1]];
	            pc = points[c[2]];
	            pd = points[c[3]];
	            w2 = weight * weight;
	            w3 = weight * w2;
	            v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
	            v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
	            v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);
	            return v3
	         };
	      var interpolate = function(p0, p1, p2, p3, t, t2, t3) {
	            var v0 = (p2 - p0) * .5,
	               v1 = (p3 - p1) * .5;
	            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1
	         };
	      return function(delta) {
	         if (this.isPlaying === false) return;
	         this.currentTime += delta * this.timeScale;
	         if (this.weight === 0) return;
	         var duration = this.data.length;
	         if (this.currentTime > duration || this.currentTime < 0) {
	            if (this.loop) {
	               this.currentTime %= duration;
	               if (this.currentTime < 0) this.currentTime += duration;
	               this.reset()
	            } else {
	               this.stop()
	            }
	         }
	         for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
	            var object = this.hierarchy[h];
	            var animationCache = object.animationCache.animations[this.data.name];
	            var blending = object.animationCache.blending;
	            for (var t = 0; t < 3; t++) {
	               var type = this.keyTypes[t];
	               var prevKey = animationCache.prevKey[type];
	               var nextKey = animationCache.nextKey[type];
	               if (this.timeScale > 0 && nextKey.time <= this.currentTime || this.timeScale < 0 && prevKey.time >= this.currentTime) {
	                  prevKey = this.data.hierarchy[h].keys[0];
	                  nextKey = this.getNextKeyWith(type, h, 1);
	                  while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
	                     prevKey = nextKey;
	                     nextKey = this.getNextKeyWith(type, h, nextKey.index + 1)
	                  }
	                  animationCache.prevKey[type] = prevKey;
	                  animationCache.nextKey[type] = nextKey
	               }
	               var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
	               var prevXYZ = prevKey[type];
	               var nextXYZ = nextKey[type];
	               if (scale < 0) scale = 0;
	               if (scale > 1) scale = 1;
	               if (type === "pos") {
	                  if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
	                     newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
	                     newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
	                     newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
	                     var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
	                     object.position.lerp(newVector, proportionalWeight);
	                     blending.positionWeight += this.weight
	                  } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
	                     points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
	                     points[1] = prevXYZ;
	                     points[2] = nextXYZ;
	                     points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];
	                     scale = scale * .33 + .33;
	                     var currentPoint = interpolateCatmullRom(points, scale);
	                     var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
	                     blending.positionWeight += this.weight;
	                     var vector = object.position;
	                     vector.x = vector.x + (currentPoint[0] - vector.x) * proportionalWeight;
	                     vector.y = vector.y + (currentPoint[1] - vector.y) * proportionalWeight;
	                     vector.z = vector.z + (currentPoint[2] - vector.z) * proportionalWeight;
	                     if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
	                        var forwardPoint = interpolateCatmullRom(points, scale * 1.01);
	                        target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
	                        target.sub(vector);
	                        target.y = 0;
	                        target.normalize();
	                        var angle = Math.atan2(target.x, target.z);
	                        object.rotation.set(0, angle, 0)
	                     }
	                  }
	               } else if (type === "rot") {
	                  THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
	                  if (blending.quaternionWeight === 0) {
	                     object.quaternion.copy(newQuat);
	                     blending.quaternionWeight = this.weight
	                  } else {
	                     var proportionalWeight = this.weight / (this.weight + blending.quaternionWeight);
	                     THREE.Quaternion.slerp(object.quaternion, newQuat, object.quaternion, proportionalWeight);
	                     blending.quaternionWeight += this.weight
	                  }
	               } else if (type === "scl") {
	                  newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
	                  newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
	                  newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
	                  var proportionalWeight = this.weight / (this.weight + blending.scaleWeight);
	                  object.scale.lerp(newVector, proportionalWeight);
	                  blending.scaleWeight += this.weight
	               }
	            }
	         }
	         return true
	      }
	   }(),
	   getNextKeyWith: function(type, h, key) {
	      var keys = this.data.hierarchy[h].keys;
	      if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
	         key = key < keys.length - 1 ? key : keys.length - 1
	      } else {
	         key = key % keys.length
	      }
	      for (; key < keys.length; key++) {
	         if (keys[key][type] !== undefined) {
	            return keys[key]
	         }
	      }
	      return this.data.hierarchy[h].keys[0]
	   },
	   getPrevKeyWith: function(type, h, key) {
	      var keys = this.data.hierarchy[h].keys;
	      if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
	         key = key > 0 ? key : 0
	      } else {
	         key = key >= 0 ? key : key + keys.length
	      }
	      for (; key >= 0; key--) {
	         if (keys[key][type] !== undefined) {
	            return keys[key]
	         }
	      }
	      return this.data.hierarchy[h].keys[keys.length - 1]
	   }
	};
	THREE.AnimationHandler = {
	   LINEAR: 0,
	   CATMULLROM: 1,
	   CATMULLROM_FORWARD: 2,
	   add: function() {
	      console.warn("THREE.AnimationHandler.add() has been deprecated.")
	   },
	   get: function() {
	      console.warn("THREE.AnimationHandler.get() has been deprecated.")
	   },
	   remove: function() {
	      console.warn("THREE.AnimationHandler.remove() has been deprecated.")
	   },
	   animations: [],
	   init: function(data) {
	      if (data.initialized === true) return data;
	      for (var h = 0; h < data.hierarchy.length; h++) {
	         for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
	            if (data.hierarchy[h].keys[k].time < 0) {
	               data.hierarchy[h].keys[k].time = 0
	            }
	            if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
	               var quat = data.hierarchy[h].keys[k].rot;
	               data.hierarchy[h].keys[k].rot = (new THREE.Quaternion).fromArray(quat)
	            }
	         }
	         if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {
	            var usedMorphTargets = {};
	            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
	               for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
	                  var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];
	                  usedMorphTargets[morphTargetName] = -1
	               }
	            }
	            data.hierarchy[h].usedMorphTargets = usedMorphTargets;
	            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
	               var influences = {};
	               for (var morphTargetName in usedMorphTargets) {
	                  for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
	                     if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {
	                        influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];
	                        break
	                     }
	                  }
	                  if (m === data.hierarchy[h].keys[k].morphTargets.length) {
	                     influences[morphTargetName] = 0
	                  }
	               }
	               data.hierarchy[h].keys[k].morphTargetsInfluences = influences
	            }
	         }
	         for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
	            if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
	               data.hierarchy[h].keys.splice(k, 1);
	               k--
	            }
	         }
	         for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
	            data.hierarchy[h].keys[k].index = k
	         }
	      }
	      data.initialized = true;
	      return data
	   },
	   parse: function(root) {
	      var parseRecurseHierarchy = function(root, hierarchy) {
	            hierarchy.push(root);
	            for (var c = 0; c < root.children.length; c++) parseRecurseHierarchy(root.children[c], hierarchy)
	         };
	      var hierarchy = [];
	      if (root instanceof THREE.SkinnedMesh) {
	         for (var b = 0; b < root.skeleton.bones.length; b++) {
	            hierarchy.push(root.skeleton.bones[b])
	         }
	      } else {
	         parseRecurseHierarchy(root, hierarchy)
	      }
	      return hierarchy
	   },
	   play: function(animation) {
	      if (this.animations.indexOf(animation) === -1) {
	         this.animations.push(animation)
	      }
	   },
	   stop: function(animation) {
	      var index = this.animations.indexOf(animation);
	      if (index !== -1) {
	         this.animations.splice(index, 1)
	      }
	   },
	   update: function(deltaTimeMS) {
	      for (var i = 0; i < this.animations.length; i++) {
	         this.animations[i].resetBlendWeights()
	      }
	      for (var i = 0; i < this.animations.length; i++) {
	         this.animations[i].update(deltaTimeMS)
	      }
	   }
	};
	THREE.KeyFrameAnimation = function(data) {
	   this.root = data.node;
	   this.data = THREE.AnimationHandler.init(data);
	   this.hierarchy = THREE.AnimationHandler.parse(this.root);
	   this.currentTime = 0;
	   this.timeScale = .001;
	   this.isPlaying = false;
	   this.isPaused = true;
	   this.loop = true;
	   for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
	      var keys = this.data.hierarchy[h].keys,
	         sids = this.data.hierarchy[h].sids,
	         obj = this.hierarchy[h];
	      if (keys.length && sids) {
	         for (var s = 0; s < sids.length; s++) {
	            var sid = sids[s],
	               next = this.getNextKeyWith(sid, h, 0);
	            if (next) {
	               next.apply(sid)
	            }
	         }
	         obj.matrixAutoUpdate = false;
	         this.data.hierarchy[h].node.updateMatrix();
	         obj.matrixWorldNeedsUpdate = true
	      }
	   }
	};
	THREE.KeyFrameAnimation.prototype = {
	   constructor: THREE.KeyFrameAnimation,
	   play: function(startTime) {
	      this.currentTime = startTime !== undefined ? startTime : 0;
	      if (this.isPlaying === false) {
	         this.isPlaying = true;
	         var h, hl = this.hierarchy.length,
	            object, node;
	         for (h = 0; h < hl; h++) {
	            object = this.hierarchy[h];
	            node = this.data.hierarchy[h];
	            if (node.animationCache === undefined) {
	               node.animationCache = {};
	               node.animationCache.prevKey = null;
	               node.animationCache.nextKey = null;
	               node.animationCache.originalMatrix = object.matrix
	            }
	            var keys = this.data.hierarchy[h].keys;
	            if (keys.length > 1) {
	               node.animationCache.prevKey = keys[0];
	               node.animationCache.nextKey = keys[1];
	               this.startTime = Math.min(keys[0].time, this.startTime);
	               this.endTime = Math.max(keys[keys.length - 1].time, this.endTime)
	            }
	         }
	         this.update(0)
	      }
	      this.isPaused = false
	   },
	   stop: function() {
	      this.isPlaying = false;
	      this.isPaused = false;
	      for (var h = 0; h < this.data.hierarchy.length; h++) {
	         var obj = this.hierarchy[h];
	         var node = this.data.hierarchy[h];
	         if (node.animationCache !== undefined) {
	            var original = node.animationCache.originalMatrix;
	            original.copy(obj.matrix);
	            obj.matrix = original;
	            delete node.animationCache
	         }
	      }
	   },
	   update: function(delta) {
	      if (this.isPlaying === false) return;
	      this.currentTime += delta * this.timeScale;
	      var duration = this.data.length;
	      if (this.loop === true && this.currentTime > duration) {
	         this.currentTime %= duration
	      }
	      this.currentTime = Math.min(this.currentTime, duration);
	      for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
	         var object = this.hierarchy[h];
	         var node = this.data.hierarchy[h];
	         var keys = node.keys,
	            animationCache = node.animationCache;
	         if (keys.length) {
	            var prevKey = animationCache.prevKey;
	            var nextKey = animationCache.nextKey;
	            if (nextKey.time <= this.currentTime) {
	               while (nextKey.time < this.currentTime && nextKey.index > prevKey.index && nextKey.index < keys.length) {
	                  prevKey = nextKey;
	                  nextKey = keys[prevKey.index + 1]
	               }
	               animationCache.prevKey = prevKey;
	               animationCache.nextKey = nextKey
	            } else if (prevKey.time >= this.currentTime) {
	               while (prevKey.time > this.currentTime && nextKey.index > prevKey.index && prevKey.index > 0) {
	                  nextKey = prevKey;
	                  prevKey = keys[prevKey.index - 1]
	               }
	               animationCache.prevKey = prevKey;
	               animationCache.nextKey = nextKey
	            }
	            if (nextKey.time >= this.currentTime) {
	               prevKey.interpolate(nextKey, this.currentTime)
	            } else {
	               prevKey.interpolate(nextKey, nextKey.time)
	            }
	            this.data.hierarchy[h].node.updateMatrix();
	            object.matrixWorldNeedsUpdate = true
	         }
	      }
	   },
	   getNextKeyWith: function(sid, h, key) {
	      var keys = this.data.hierarchy[h].keys;
	      key = key % keys.length;
	      for (; key < keys.length; key++) {
	         if (keys[key].hasTarget(sid)) {
	            return keys[key]
	         }
	      }
	      return keys[0]
	   },
	   getPrevKeyWith: function(sid, h, key) {
	      var keys = this.data.hierarchy[h].keys;
	      key = key >= 0 ? key : key + keys.length;
	      for (; key >= 0; key--) {
	         if (keys[key].hasTarget(sid)) {
	            return keys[key]
	         }
	      }
	      return keys[keys.length - 1]
	   }
	};
	THREE.ColladaLoader = function() {
	   var COLLADA = null;
	   var scene = null;
	   var visualScene;
	   var kinematicsModel;
	   var readyCallbackFunc = null;
	   var sources = {};
	   var images = {};
	   var animations = {};
	   var controllers = {};
	   var geometries = {};
	   var materials = {};
	   var effects = {};
	   var cameras = {};
	   var lights = {};
	   var animData;
	   var kinematics;
	   var visualScenes;
	   var kinematicsModels;
	   var baseUrl;
	   var morphs;
	   var skins;
	   var flip_uv = true;
	   var preferredShading = THREE.SmoothShading;
	   var options = {
	      centerGeometry: false,
	      convertUpAxis: false,
	      subdivideFaces: true,
	      upAxis: "Y",
	      defaultEnvMap: null
	   };
	   var colladaUnit = 1;
	   var colladaUp = "Y";
	   var upConversion = null;

	   function load(url, readyCallback, progressCallback, failCallback) {
	      var length = 0;
	      if (document.implementation && document.implementation.createDocument) {
	         var request = new XMLHttpRequest;
	         request.onreadystatechange = function() {
	            if (request.readyState === 4) {
	               if (request.status === 0 || request.status === 200) {
	                  if (request.response) {
	                     readyCallbackFunc = readyCallback;
	                     parse(request.response, undefined, url)
	                  } else {
	                     if (failCallback) {
	                        failCallback({
	                           type: "error",
	                           url: url
	                        })
	                     } else {
	                        console.error("ColladaLoader: Empty or non-existing file (" + url + ")")
	                     }
	                  }
	               } else {
	                  if (failCallback) {
	                     failCallback({
	                        type: "error",
	                        url: url
	                     })
	                  } else {
	                     console.error("ColladaLoader: Couldn't load \"" + url + '" (' + request.status + ")")
	                  }
	               }
	            } else if (request.readyState === 3) {
	               if (progressCallback) {
	                  if (length === 0) {
	                     length = request.getResponseHeader("Content-Length")
	                  }
	                  progressCallback({
	                     total: length,
	                     loaded: request.responseText.length
	                  })
	               }
	            }
	         };
	         request.open("GET", url, true);
	         request.send(null)
	      } else {
	         alert("Don't know how to parse XML!")
	      }
	   }
	   function parse(text, callBack, url) {
	      COLLADA = (new DOMParser).parseFromString(text, "text/xml");
	      callBack = callBack || readyCallbackFunc;
	      if (url !== undefined) {
	         var parts = url.split("/");
	         parts.pop();
	         baseUrl = (parts.length < 1 ? "." : parts.join("/")) + "/"
	      }
	      parseAsset();
	      setUpConversion();
	      images = parseLib("library_images image", _Image, "image");
	      materials = parseLib("library_materials material", Material, "material");
	      effects = parseLib("library_effects effect", Effect, "effect");
	      geometries = parseLib("library_geometries geometry", Geometry, "geometry");
	      cameras = parseLib("library_cameras camera", Camera, "camera");
	      lights = parseLib("library_lights light", Light, "light");
	      controllers = parseLib("library_controllers controller", Controller, "controller");
	      animations = parseLib("library_animations animation", Animation, "animation");
	      visualScenes = parseLib("library_visual_scenes visual_scene", VisualScene, "visual_scene");
	      kinematicsModels = parseLib("library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model");
	      morphs = [];
	      skins = [];
	      visualScene = parseScene();
	      scene = new THREE.Group;
	      for (var i = 0; i < visualScene.nodes.length; i++) {
	         scene.add(createSceneGraph(visualScene.nodes[i]))
	      }
	      scene.scale.multiplyScalar(colladaUnit);
	      createAnimations();
	      kinematicsModel = parseKinematicsModel();
	      createKinematics();
	      var result = {
	         scene: scene,
	         morphs: morphs,
	         skins: skins,
	         animations: animData,
	         kinematics: kinematics,
	         dae: {
	            images: images,
	            materials: materials,
	            cameras: cameras,
	            lights: lights,
	            effects: effects,
	            geometries: geometries,
	            controllers: controllers,
	            animations: animations,
	            visualScenes: visualScenes,
	            visualScene: visualScene,
	            scene: visualScene,
	            kinematicsModels: kinematicsModels,
	            kinematicsModel: kinematicsModel
	         }
	      };
	      if (callBack) {
	         callBack(result)
	      }
	      return result
	   }
	   function setPreferredShading(shading) {
	      preferredShading = shading
	   }
	   function parseAsset() {
	      var elements = COLLADA.querySelectorAll("asset");
	      var element = elements[0];
	      if (element && element.childNodes) {
	         for (var i = 0; i < element.childNodes.length; i++) {
	            var child = element.childNodes[i];
	            switch (child.nodeName) {
	            case "unit":
	               var meter = child.getAttribute("meter");
	               if (meter) {
	                  colladaUnit = parseFloat(meter)
	               }
	               break;
	            case "up_axis":
	               colladaUp = child.textContent.charAt(0);
	               break
	            }
	         }
	      }
	   }
	   function parseLib(q, classSpec, prefix) {
	      var elements = COLLADA.querySelectorAll(q);
	      var lib = {};
	      var i = 0;
	      var elementsLength = elements.length;
	      for (var j = 0; j < elementsLength; j++) {
	         var element = elements[j];
	         var daeElement = (new classSpec).parse(element);
	         if (!daeElement.id || daeElement.id.length === 0) daeElement.id = prefix + i++;
	         lib[daeElement.id] = daeElement
	      }
	      return lib
	   }
	   function parseScene() {
	      var sceneElement = COLLADA.querySelectorAll("scene instance_visual_scene")[0];
	      if (sceneElement) {
	         var url = sceneElement.getAttribute("url").replace(/^#/, "");
	         return visualScenes[url.length > 0 ? url : "visual_scene0"]
	      } else {
	         return null
	      }
	   }
	   function parseKinematicsModel() {
	      var kinematicsModelElement = COLLADA.querySelectorAll("instance_kinematics_model")[0];
	      if (kinematicsModelElement) {
	         var url = kinematicsModelElement.getAttribute("url").replace(/^#/, "");
	         return kinematicsModels[url.length > 0 ? url : "kinematics_model0"]
	      } else {
	         return null
	      }
	   }
	   function createAnimations() {
	      animData = [];
	      recurseHierarchy(scene)
	   }
	   function recurseHierarchy(node) {
	      var n = visualScene.getChildById(node.colladaId, true),
	         newData = null;
	      if (n && n.keys) {
	         newData = {
	            fps: 60,
	            hierarchy: [{
	               node: n,
	               keys: n.keys,
	               sids: n.sids
	            }],
	            node: node,
	            name: "animation_" + node.name,
	            length: 0
	         };
	         animData.push(newData);
	         for (var i = 0, il = n.keys.length; i < il; i++) {
	            newData.length = Math.max(newData.length, n.keys[i].time)
	         }
	      } else {
	         newData = {
	            hierarchy: [{
	               keys: [],
	               sids: []
	            }]
	         }
	      }
	      for (var i = 0, il = node.children.length; i < il; i++) {
	         var d = recurseHierarchy(node.children[i]);
	         for (var j = 0, jl = d.hierarchy.length; j < jl; j++) {
	            newData.hierarchy.push({
	               keys: [],
	               sids: []
	            })
	         }
	      }
	      return newData
	   }
	   function calcAnimationBounds() {
	      var start = 1e6;
	      var end = -start;
	      var frames = 0;
	      var ID;
	      for (var id in animations) {
	         var animation = animations[id];
	         ID = ID || animation.id;
	         for (var i = 0; i < animation.sampler.length; i++) {
	            var sampler = animation.sampler[i];
	            sampler.create();
	            start = Math.min(start, sampler.startTime);
	            end = Math.max(end, sampler.endTime);
	            frames = Math.max(frames, sampler.input.length)
	         }
	      }
	      return {
	         start: start,
	         end: end,
	         frames: frames,
	         ID: ID
	      }
	   }
	   function createMorph(geometry, ctrl) {
	      var morphCtrl = ctrl instanceof InstanceController ? controllers[ctrl.url] : ctrl;
	      if (!morphCtrl || !morphCtrl.morph) {
	         console.log("could not find morph controller!");
	         return
	      }
	      var morph = morphCtrl.morph;
	      for (var i = 0; i < morph.targets.length; i++) {
	         var target_id = morph.targets[i];
	         var daeGeometry = geometries[target_id];
	         if (!daeGeometry.mesh || !daeGeometry.mesh.primitives || !daeGeometry.mesh.primitives.length) {
	            continue
	         }
	         var target = daeGeometry.mesh.primitives[0].geometry;
	         if (target.vertices.length === geometry.vertices.length) {
	            geometry.morphTargets.push({
	               name: "target_1",
	               vertices: target.vertices
	            })
	         }
	      }
	      geometry.morphTargets.push({
	         name: "target_Z",
	         vertices: geometry.vertices
	      })
	   }
	   function createSkin(geometry, ctrl, applyBindShape) {
	      var skinCtrl = controllers[ctrl.url];
	      if (!skinCtrl || !skinCtrl.skin) {
	         console.log("could not find skin controller!");
	         return
	      }
	      if (!ctrl.skeleton || !ctrl.skeleton.length) {
	         console.log("could not find the skeleton for the skin!");
	         return
	      }
	      var skin = skinCtrl.skin;
	      var skeleton = visualScene.getChildById(ctrl.skeleton[0]);
	      var hierarchy = [];
	      applyBindShape = applyBindShape !== undefined ? applyBindShape : true;
	      var bones = [];
	      geometry.skinWeights = [];
	      geometry.skinIndices = [];
	      if (applyBindShape) {
	         for (var i = 0; i < geometry.vertices.length; i++) {
	            geometry.vertices[i].applyMatrix4(skin.bindShapeMatrix)
	         }
	      }
	   }
	   function setupSkeleton(node, bones, frame, parent) {
	      node.world = node.world || new THREE.Matrix4;
	      node.localworld = node.localworld || new THREE.Matrix4;
	      node.world.copy(node.matrix);
	      node.localworld.copy(node.matrix);
	      if (node.channels && node.channels.length) {
	         var channel = node.channels[0];
	         var m = channel.sampler.output[frame];
	         if (m instanceof THREE.Matrix4) {
	            node.world.copy(m);
	            node.localworld.copy(m);
	            if (frame === 0) node.matrix.copy(m)
	         }
	      }
	      if (parent) {
	         node.world.multiplyMatrices(parent, node.world)
	      }
	      bones.push(node);
	      for (var i = 0; i < node.nodes.length; i++) {
	         setupSkeleton(node.nodes[i], bones, frame, node.world)
	      }
	   }
	   function setupSkinningMatrices(bones, skin) {
	      for (var i = 0; i < bones.length; i++) {
	         var bone = bones[i];
	         var found = -1;
	         if (bone.type != "JOINT") continue;
	         for (var j = 0; j < skin.joints.length; j++) {
	            if (bone.sid === skin.joints[j]) {
	               found = j;
	               break
	            }
	         }
	         if (found >= 0) {
	            var inv = skin.invBindMatrices[found];
	            bone.invBindMatrix = inv;
	            bone.skinningMatrix = new THREE.Matrix4;
	            bone.skinningMatrix.multiplyMatrices(bone.world, inv);
	            bone.animatrix = new THREE.Matrix4;
	            bone.animatrix.copy(bone.localworld);
	            bone.weights = [];
	            for (var j = 0; j < skin.weights.length; j++) {
	               for (var k = 0; k < skin.weights[j].length; k++) {
	                  var w = skin.weights[j][k];
	                  if (w.joint === found) {
	                     bone.weights.push(w)
	                  }
	               }
	            }
	         } else {
	            console.warn("ColladaLoader: Could not find joint '" + bone.sid + "'.");
	            bone.skinningMatrix = new THREE.Matrix4;
	            bone.weights = []
	         }
	      }
	   }
	   function flattenSkeleton(skeleton) {
	      var list = [];
	      var walk = function(parentid, node, list) {
	            var bone = {};
	            bone.name = node.sid;
	            bone.parent = parentid;
	            bone.matrix = node.matrix;
	            var data = [new THREE.Vector3, new THREE.Quaternion, new THREE.Vector3];
	            bone.matrix.decompose(data[0], data[1], data[2]);
	            bone.pos = [data[0].x, data[0].y, data[0].z];
	            bone.scl = [data[2].x, data[2].y, data[2].z];
	            bone.rotq = [data[1].x, data[1].y, data[1].z, data[1].w];
	            list.push(bone);
	            for (var i in node.nodes) {
	               walk(node.sid, node.nodes[i], list)
	            }
	         };
	      walk(-1, skeleton, list);
	      return list
	   }
	   function skinToBindPose(geometry, skeleton, skinController) {
	      var bones = [];
	      setupSkeleton(skeleton, bones, -1);
	      setupSkinningMatrices(bones, skinController.skin);
	      var v = new THREE.Vector3;
	      var skinned = [];
	      for (var i = 0; i < geometry.vertices.length; i++) {
	         skinned.push(new THREE.Vector3)
	      }
	      for (i = 0; i < bones.length; i++) {
	         if (bones[i].type != "JOINT") continue;
	         for (var j = 0; j < bones[i].weights.length; j++) {
	            var w = bones[i].weights[j];
	            var vidx = w.index;
	            var weight = w.weight;
	            var o = geometry.vertices[vidx];
	            var s = skinned[vidx];
	            v.x = o.x;
	            v.y = o.y;
	            v.z = o.z;
	            v.applyMatrix4(bones[i].skinningMatrix);
	            s.x += v.x * weight;
	            s.y += v.y * weight;
	            s.z += v.z * weight
	         }
	      }
	      for (var i = 0; i < geometry.vertices.length; i++) {
	         geometry.vertices[i] = skinned[i]
	      }
	   }
	   function applySkin(geometry, instanceCtrl, frame) {
	      var skinController = controllers[instanceCtrl.url];
	      frame = frame !== undefined ? frame : 40;
	      if (!skinController || !skinController.skin) {
	         console.log("ColladaLoader: Could not find skin controller.");
	         return
	      }
	      if (!instanceCtrl.skeleton || !instanceCtrl.skeleton.length) {
	         console.log("ColladaLoader: Could not find the skeleton for the skin. ");
	         return
	      }
	      var animationBounds = calcAnimationBounds();
	      var skeleton = visualScene.getChildById(instanceCtrl.skeleton[0], true) || visualScene.getChildBySid(instanceCtrl.skeleton[0], true);
	      var bonelist = flattenSkeleton(skeleton);
	      var joints = skinController.skin.joints;
	      var sortedbones = [];
	      for (var i = 0; i < joints.length; i++) {
	         for (var j = 0; j < bonelist.length; j++) {
	            if (bonelist[j].name === joints[i]) {
	               sortedbones[i] = bonelist[j]
	            }
	         }
	      }
	      for (var i = 0; i < sortedbones.length; i++) {
	         for (var j = 0; j < sortedbones.length; j++) {
	            if (sortedbones[i].parent === sortedbones[j].name) {
	               sortedbones[i].parent = j
	            }
	         }
	      }
	      var i, j, w, vidx, weight;
	      var v = new THREE.Vector3,
	         o, s;
	      for (i = 0; i < geometry.vertices.length; i++) {
	         geometry.vertices[i].applyMatrix4(skinController.skin.bindShapeMatrix)
	      }
	      var skinIndices = [];
	      var skinWeights = [];
	      var weights = skinController.skin.weights;
	      for (var i = 0; i < weights.length; i++) {
	         var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0, weights[i][1] ? weights[i][1].joint : 0, weights[i][2] ? weights[i][2].joint : 0, weights[i][3] ? weights[i][3].joint : 0);
	         var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0, weights[i][1] ? weights[i][1].weight : 0, weights[i][2] ? weights[i][2].weight : 0, weights[i][3] ? weights[i][3].weight : 0);
	         skinIndices.push(indicies);
	         skinWeights.push(weight)
	      }
	      geometry.skinIndices = skinIndices;
	      geometry.skinWeights = skinWeights;
	      geometry.bones = sortedbones;
	      var animationdata = {
	         name: animationBounds.ID,
	         fps: 30,
	         length: animationBounds.frames / 30,
	         hierarchy: []
	      };
	      for (var j = 0; j < sortedbones.length; j++) {
	         animationdata.hierarchy.push({
	            parent: sortedbones[j].parent,
	            name: sortedbones[j].name,
	            keys: []
	         })
	      }
	      console.log("ColladaLoader:", animationBounds.ID + " has " + sortedbones.length + " bones.");
	      skinToBindPose(geometry, skeleton, skinController);
	      for (frame = 0; frame < animationBounds.frames; frame++) {
	         var bones = [];
	         var skinned = [];
	         setupSkeleton(skeleton, bones, frame);
	         setupSkinningMatrices(bones, skinController.skin);
	         for (var i = 0; i < bones.length; i++) {
	            for (var j = 0; j < animationdata.hierarchy.length; j++) {
	               if (animationdata.hierarchy[j].name === bones[i].sid) {
	                  var key = {};
	                  key.time = frame / 30;
	                  key.matrix = bones[i].animatrix;
	                  if (frame === 0) bones[i].matrix = key.matrix;
	                  var data = [new THREE.Vector3, new THREE.Quaternion, new THREE.Vector3];
	                  key.matrix.decompose(data[0], data[1], data[2]);
	                  key.pos = [data[0].x, data[0].y, data[0].z];
	                  key.scl = [data[2].x, data[2].y, data[2].z];
	                  key.rot = data[1];
	                  animationdata.hierarchy[j].keys.push(key)
	               }
	            }
	         }
	         geometry.animation = animationdata
	      }
	   }
	   function createKinematics() {
	      if (kinematicsModel && kinematicsModel.joints.length === 0) {
	         kinematics = undefined;
	         return
	      }
	      var jointMap = {};
	      var _addToMap = function(jointIndex, parentVisualElement) {
	            var parentVisualElementId = parentVisualElement.getAttribute("id");
	            var colladaNode = visualScene.getChildById(parentVisualElementId, true);
	            var joint = kinematicsModel.joints[jointIndex];
	            scene.traverse(function(node) {
	               if (node.colladaId == parentVisualElementId) {
	                  jointMap[jointIndex] = {
	                     node: node,
	                     transforms: colladaNode.transforms,
	                     joint: joint,
	                     position: joint.zeroPosition
	                  }
	               }
	            })
	         };
	      kinematics = {
	         joints: kinematicsModel && kinematicsModel.joints,
	         getJointValue: function(jointIndex) {
	            var jointData = jointMap[jointIndex];
	            if (jointData) {
	               return jointData.position
	            } else {
	               console.log("getJointValue: joint " + jointIndex + " doesn't exist")
	            }
	         },
	         setJointValue: function(jointIndex, value) {
	            var jointData = jointMap[jointIndex];
	            if (jointData) {
	               var joint = jointData.joint;
	               if (value > joint.limits.max || value < joint.limits.min) {
	                  console.log("setJointValue: joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ")")
	               } else if (joint.static) {
	                  console.log("setJointValue: joint " + jointIndex + " is static")
	               } else {
	                  var threejsNode = jointData.node;
	                  var axis = joint.axis;
	                  var transforms = jointData.transforms;
	                  var matrix = new THREE.Matrix4;
	                  var m1 = new THREE.Matrix4;
	                  for (i = 0; i < transforms.length; i++) {
	                     var transform = transforms[i];
	                     if (transform.sid && transform.sid.indexOf("joint" + jointIndex) !== -1) {
	                        switch (joint.type) {
	                        case "revolute":
	                           matrix.multiply(m1.makeRotationAxis(axis, THREE.Math.degToRad(value)));
	                           break;
	                        case "prismatic":
	                           matrix.multiply(m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
	                           break;
	                        default:
	                           console.warn("setJointValue: unknown joint type: " + joint.type);
	                           break
	                        }
	                     } else {
	                        switch (transform.type) {
	                        case "matrix":
	                           matrix.multiply(transform.obj);
	                           break;
	                        case "translate":
	                           matrix.multiply(m1.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
	                           break;
	                        case "rotate":
	                           matrix.multiply(m1.makeRotationAxis(transform.obj, transform.angle));
	                           break
	                        }
	                     }
	                  }
	                  var elementsFloat32Arr = matrix.elements;
	                  var elements = Array.prototype.slice.call(elementsFloat32Arr);
	                  var elementsRowMajor = [elements[0], elements[4], elements[8], elements[12], elements[1], elements[5], elements[9], elements[13], elements[2], elements[6], elements[10], elements[14], elements[3], elements[7], elements[11], elements[15]];
	                  threejsNode.matrix.set.apply(threejsNode.matrix, elementsRowMajor);
	                  threejsNode.matrix.decompose(threejsNode.position, threejsNode.quaternion, threejsNode.scale);
	                  jointMap[jointIndex].position = value
	               }
	            } else {
	               console.log("setJointValue: joint " + jointIndex + " doesn't exist")
	            }
	         }
	      };
	      var element = COLLADA.querySelector("scene instance_kinematics_scene");
	      if (element) {
	         for (var i = 0; i < element.childNodes.length; i++) {
	            var child = element.childNodes[i];
	            if (child.nodeType != 1) continue;
	            switch (child.nodeName) {
	            case "bind_joint_axis":
	               var visualTarget = child.getAttribute("target").split("/").pop();
	               var axis = child.querySelector("axis param").textContent;
	               var jointIndex = parseInt(axis.split("joint").pop().split(".")[0]);
	               var visualTargetElement = COLLADA.querySelector('[sid="' + visualTarget + '"]');
	               if (visualTargetElement) {
	                  var parentVisualElement = visualTargetElement.parentElement;
	                  _addToMap(jointIndex, parentVisualElement)
	               }
	               break;
	            default:
	               break
	            }
	         }
	      }
	   }
	   function createSceneGraph(node, parent) {
	      var obj = new THREE.Object3D;
	      var skinned = false;
	      var skinController;
	      var morphController;
	      var i, j;
	      for (i = 0; i < node.controllers.length; i++) {
	         var controller = controllers[node.controllers[i].url];
	         switch (controller.type) {
	         case "skin":
	            if (geometries[controller.skin.source]) {
	               var inst_geom = new InstanceGeometry;
	               inst_geom.url = controller.skin.source;
	               inst_geom.instance_material = node.controllers[i].instance_material;
	               node.geometries.push(inst_geom);
	               skinned = true;
	               skinController = node.controllers[i]
	            } else if (controllers[controller.skin.source]) {
	               var second = controllers[controller.skin.source];
	               morphController = second;
	               if (second.morph && geometries[second.morph.source]) {
	                  var inst_geom = new InstanceGeometry;
	                  inst_geom.url = second.morph.source;
	                  inst_geom.instance_material = node.controllers[i].instance_material;
	                  node.geometries.push(inst_geom)
	               }
	            }
	            break;
	         case "morph":
	            if (geometries[controller.morph.source]) {
	               var inst_geom = new InstanceGeometry;
	               inst_geom.url = controller.morph.source;
	               inst_geom.instance_material = node.controllers[i].instance_material;
	               node.geometries.push(inst_geom);
	               morphController = node.controllers[i]
	            }
	            console.log("ColladaLoader: Morph-controller partially supported.");
	         default:
	            break
	         }
	      }
	      var double_sided_materials = {};
	      for (i = 0; i < node.geometries.length; i++) {
	         var instance_geometry = node.geometries[i];
	         var instance_materials = instance_geometry.instance_material;
	         var geometry = geometries[instance_geometry.url];
	         var used_materials = {};
	         var used_materials_array = [];
	         var num_materials = 0;
	         var first_material;
	         if (geometry) {
	            if (!geometry.mesh || !geometry.mesh.primitives) continue;
	            if (obj.name.length === 0) {
	               obj.name = geometry.id
	            }
	            if (instance_materials) {
	               for (j = 0; j < instance_materials.length; j++) {
	                  var instance_material = instance_materials[j];
	                  var mat = materials[instance_material.target];
	                  var effect_id = mat.instance_effect.url;
	                  var shader = effects[effect_id].shader;
	                  var material3js = shader.material;
	                  if (geometry.doubleSided) {
	                     if (!(instance_material.symbol in double_sided_materials)) {
	                        var _copied_material = material3js.clone();
	                        _copied_material.side = THREE.DoubleSide;
	                        double_sided_materials[instance_material.symbol] = _copied_material
	                     }
	                     material3js = double_sided_materials[instance_material.symbol]
	                  }
	                  material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
	                  used_materials[instance_material.symbol] = num_materials;
	                  used_materials_array.push(material3js);
	                  first_material = material3js;
	                  first_material.name = mat.name === null || mat.name === "" ? mat.id : mat.name;
	                  num_materials++
	               }
	            }
	            var mesh;
	            var material = first_material || new THREE.MeshLambertMaterial({
	               color: 14540253,
	               side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide
	            });
	            var geom = geometry.mesh.geometry3js;
	            if (num_materials > 1) {
	               material = new THREE.MultiMaterial(used_materials_array);
	               for (j = 0; j < geom.faces.length; j++) {
	                  var face = geom.faces[j];
	                  face.materialIndex = used_materials[face.daeMaterial]
	               }
	            }
	            if (skinController !== undefined) {
	               applySkin(geom, skinController);
	               if (geom.morphTargets.length > 0) {
	                  material.morphTargets = true;
	                  material.skinning = false
	               } else {
	                  material.morphTargets = false;
	                  material.skinning = true
	               }
	               mesh = new THREE.SkinnedMesh(geom, material, false);
	               mesh.name = "skin_" + skins.length;
	               skins.push(mesh)
	            } else if (morphController !== undefined) {
	               createMorph(geom, morphController);
	               material.morphTargets = true;
	               mesh = new THREE.Mesh(geom, material);
	               mesh.name = "morph_" + morphs.length;
	               morphs.push(mesh)
	            } else {
	               if (geom.isLineStrip === true) {
	                  mesh = new THREE.Line(geom)
	               } else {
	                  mesh = new THREE.Mesh(geom, material)
	               }
	            }
	            obj.add(mesh)
	         }
	      }
	      for (i = 0; i < node.cameras.length; i++) {
	         var instance_camera = node.cameras[i];
	         var cparams = cameras[instance_camera.url];
	         var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio), parseFloat(cparams.znear), parseFloat(cparams.zfar));
	         obj.add(cam)
	      }
	      for (i = 0; i < node.lights.length; i++) {
	         var light = null;
	         var instance_light = node.lights[i];
	         var lparams = lights[instance_light.url];
	         if (lparams && lparams.technique) {
	            var color = lparams.color.getHex();
	            var intensity = lparams.intensity;
	            var distance = lparams.distance;
	            var angle = lparams.falloff_angle;
	            switch (lparams.technique) {
	            case "directional":
	               light = new THREE.DirectionalLight(color, intensity, distance);
	               light.position.set(0, 0, 1);
	               break;
	            case "point":
	               light = new THREE.PointLight(color, intensity, distance);
	               break;
	            case "spot":
	               light = new THREE.SpotLight(color, intensity, distance, angle);
	               light.position.set(0, 0, 1);
	               break;
	            case "ambient":
	               light = new THREE.AmbientLight(color);
	               break
	            }
	         }
	         if (light) {
	            obj.add(light)
	         }
	      }
	      obj.name = node.name || node.id || "";
	      obj.colladaId = node.id || "";
	      obj.layer = node.layer || "";
	      obj.matrix = node.matrix;
	      obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
	      if (options.centerGeometry && obj.geometry) {
	         var delta = obj.geometry.center();
	         delta.multiply(obj.scale);
	         delta.applyQuaternion(obj.quaternion);
	         obj.position.sub(delta)
	      }
	      for (i = 0; i < node.nodes.length; i++) {
	         obj.add(createSceneGraph(node.nodes[i], node))
	      }
	      return obj
	   }
	   function getJointId(skin, id) {
	      for (var i = 0; i < skin.joints.length; i++) {
	         if (skin.joints[i] === id) {
	            return i
	         }
	      }
	   }
	   function getLibraryNode(id) {
	      var nodes = COLLADA.querySelectorAll("library_nodes node");
	      for (var i = 0; i < nodes.length; i++) {
	         var attObj = nodes[i].attributes.getNamedItem("id");
	         if (attObj && attObj.value === id) {
	            return nodes[i]
	         }
	      }
	      return undefined
	   }
	   function getChannelsForNode(node) {
	      var channels = [];
	      var startTime = 1e6;
	      var endTime = -1e6;
	      for (var id in animations) {
	         var animation = animations[id];
	         for (var i = 0; i < animation.channel.length; i++) {
	            var channel = animation.channel[i];
	            var sampler = animation.sampler[i];
	            var id = channel.target.split("/")[0];
	            if (id == node.id) {
	               sampler.create();
	               channel.sampler = sampler;
	               startTime = Math.min(startTime, sampler.startTime);
	               endTime = Math.max(endTime, sampler.endTime);
	               channels.push(channel)
	            }
	         }
	      }
	      if (channels.length) {
	         node.startTime = startTime;
	         node.endTime = endTime
	      }
	      return channels
	   }
	   function calcFrameDuration(node) {
	      var minT = 1e7;
	      for (var i = 0; i < node.channels.length; i++) {
	         var sampler = node.channels[i].sampler;
	         for (var j = 0; j < sampler.input.length - 1; j++) {
	            var t0 = sampler.input[j];
	            var t1 = sampler.input[j + 1];
	            minT = Math.min(minT, t1 - t0)
	         }
	      }
	      return minT
	   }
	   function calcMatrixAt(node, t) {
	      var animated = {};
	      var i, j;
	      for (i = 0; i < node.channels.length; i++) {
	         var channel = node.channels[i];
	         animated[channel.sid] = channel
	      }
	      var matrix = new THREE.Matrix4;
	      for (i = 0; i < node.transforms.length; i++) {
	         var transform = node.transforms[i];
	         var channel = animated[transform.sid];
	         if (channel !== undefined) {
	            var sampler = channel.sampler;
	            var value;
	            for (j = 0; j < sampler.input.length - 1; j++) {
	               if (sampler.input[j + 1] > t) {
	                  value = sampler.output[j];
	                  break
	               }
	            }
	            if (value !== undefined) {
	               if (value instanceof THREE.Matrix4) {
	                  matrix.multiplyMatrices(matrix, value)
	               } else {
	                  matrix.multiplyMatrices(matrix, transform.matrix)
	               }
	            } else {
	               matrix.multiplyMatrices(matrix, transform.matrix)
	            }
	         } else {
	            matrix.multiplyMatrices(matrix, transform.matrix)
	         }
	      }
	      return matrix
	   }
	   function bakeAnimations(node) {
	      if (node.channels && node.channels.length) {
	         var keys = [],
	            sids = [];
	         for (var i = 0, il = node.channels.length; i < il; i++) {
	            var channel = node.channels[i],
	               fullSid = channel.fullSid,
	               sampler = channel.sampler,
	               input = sampler.input,
	               transform = node.getTransformBySid(channel.sid),
	               member;
	            if (channel.arrIndices) {
	               member = [];
	               for (var j = 0, jl = channel.arrIndices.length; j < jl; j++) {
	                  member[j] = getConvertedIndex(channel.arrIndices[j])
	               }
	            } else {
	               member = getConvertedMember(channel.member)
	            }
	            if (transform) {
	               if (sids.indexOf(fullSid) === -1) {
	                  sids.push(fullSid)
	               }
	               for (var j = 0, jl = input.length; j < jl; j++) {
	                  var time = input[j],
	                     data = sampler.getData(transform.type, j, member),
	                     key = findKey(keys, time);
	                  if (!key) {
	                     key = new Key(time);
	                     var timeNdx = findTimeNdx(keys, time);
	                     keys.splice(timeNdx === -1 ? keys.length : timeNdx, 0, key)
	                  }
	                  key.addTarget(fullSid, transform, member, data)
	               }
	            } else {
	               console.log('Could not find transform "' + channel.sid + '" in node ' + node.id)
	            }
	         }
	         for (var i = 0; i < sids.length; i++) {
	            var sid = sids[i];
	            for (var j = 0; j < keys.length; j++) {
	               var key = keys[j];
	               if (!key.hasTarget(sid)) {
	                  interpolateKeys(keys, key, j, sid)
	               }
	            }
	         }
	         node.keys = keys;
	         node.sids = sids
	      }
	   }
	   function findKey(keys, time) {
	      var retVal = null;
	      for (var i = 0, il = keys.length; i < il && retVal === null; i++) {
	         var key = keys[i];
	         if (key.time === time) {
	            retVal = key
	         } else if (key.time > time) {
	            break
	         }
	      }
	      return retVal
	   }
	   function findTimeNdx(keys, time) {
	      var ndx = -1;
	      for (var i = 0, il = keys.length; i < il && ndx === -1; i++) {
	         var key = keys[i];
	         if (key.time >= time) {
	            ndx = i
	         }
	      }
	      return ndx
	   }
	   function interpolateKeys(keys, key, ndx, fullSid) {
	      var prevKey = getPrevKeyWith(keys, fullSid, ndx ? ndx - 1 : 0),
	         nextKey = getNextKeyWith(keys, fullSid, ndx + 1);
	      if (prevKey && nextKey) {
	         var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
	            prevTarget = prevKey.getTarget(fullSid),
	            nextData = nextKey.getTarget(fullSid).data,
	            prevData = prevTarget.data,
	            data;
	         if (prevTarget.type === "matrix") {
	            data = prevData
	         } else if (prevData.length) {
	            data = [];
	            for (var i = 0; i < prevData.length; ++i) {
	               data[i] = prevData[i] + (nextData[i] - prevData[i]) * scale
	            }
	         } else {
	            data = prevData + (nextData - prevData) * scale
	         }
	         key.addTarget(fullSid, prevTarget.transform, prevTarget.member, data)
	      }
	   }
	   function getNextKeyWith(keys, fullSid, ndx) {
	      for (; ndx < keys.length; ndx++) {
	         var key = keys[ndx];
	         if (key.hasTarget(fullSid)) {
	            return key
	         }
	      }
	      return null
	   }
	   function getPrevKeyWith(keys, fullSid, ndx) {
	      ndx = ndx >= 0 ? ndx : ndx + keys.length;
	      for (; ndx >= 0; ndx--) {
	         var key = keys[ndx];
	         if (key.hasTarget(fullSid)) {
	            return key
	         }
	      }
	      return null
	   }
	   function _Image() {
	      this.id = "";
	      this.init_from = ""
	   }
	   _Image.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeName === "init_from") {
	            this.init_from = child.textContent
	         }
	      }
	      return this
	   };

	   function Controller() {
	      this.id = "";
	      this.name = "";
	      this.type = "";
	      this.skin = null;
	      this.morph = null
	   }
	   Controller.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      this.type = "none";
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "skin":
	            this.skin = (new Skin).parse(child);
	            this.type = child.nodeName;
	            break;
	         case "morph":
	            this.morph = (new Morph).parse(child);
	            this.type = child.nodeName;
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Morph() {
	      this.method = null;
	      this.source = null;
	      this.targets = null;
	      this.weights = null
	   }
	   Morph.prototype.parse = function(element) {
	      var sources = {};
	      var inputs = [];
	      var i;
	      this.method = element.getAttribute("method");
	      this.source = element.getAttribute("source").replace(/^#/, "");
	      for (i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "source":
	            var source = (new Source).parse(child);
	            sources[source.id] = source;
	            break;
	         case "targets":
	            inputs = this.parseInputs(child);
	            break;
	         default:
	            console.log(child.nodeName);
	            break
	         }
	      }
	      for (i = 0; i < inputs.length; i++) {
	         var input = inputs[i];
	         var source = sources[input.source];
	         switch (input.semantic) {
	         case "MORPH_TARGET":
	            this.targets = source.read();
	            break;
	         case "MORPH_WEIGHT":
	            this.weights = source.read();
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   Morph.prototype.parseInputs = function(element) {
	      var inputs = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "input":
	            inputs.push((new Input).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return inputs
	   };

	   function Skin() {
	      this.source = "";
	      this.bindShapeMatrix = null;
	      this.invBindMatrices = [];
	      this.joints = [];
	      this.weights = []
	   }
	   Skin.prototype.parse = function(element) {
	      var sources = {};
	      var joints, weights;
	      this.source = element.getAttribute("source").replace(/^#/, "");
	      this.invBindMatrices = [];
	      this.joints = [];
	      this.weights = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "bind_shape_matrix":
	            var f = _floats(child.textContent);
	            this.bindShapeMatrix = getConvertedMat4(f);
	            break;
	         case "source":
	            var src = (new Source).parse(child);
	            sources[src.id] = src;
	            break;
	         case "joints":
	            joints = child;
	            break;
	         case "vertex_weights":
	            weights = child;
	            break;
	         default:
	            console.log(child.nodeName);
	            break
	         }
	      }
	      this.parseJoints(joints, sources);
	      this.parseWeights(weights, sources);
	      return this
	   };
	   Skin.prototype.parseJoints = function(element, sources) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "input":
	            var input = (new Input).parse(child);
	            var source = sources[input.source];
	            if (input.semantic === "JOINT") {
	               this.joints = source.read()
	            } else if (input.semantic === "INV_BIND_MATRIX") {
	               this.invBindMatrices = source.read()
	            }
	            break;
	         default:
	            break
	         }
	      }
	   };
	   Skin.prototype.parseWeights = function(element, sources) {
	      var v, vcount, inputs = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "input":
	            inputs.push((new Input).parse(child));
	            break;
	         case "v":
	            v = _ints(child.textContent);
	            break;
	         case "vcount":
	            vcount = _ints(child.textContent);
	            break;
	         default:
	            break
	         }
	      }
	      var index = 0;
	      for (var i = 0; i < vcount.length; i++) {
	         var numBones = vcount[i];
	         var vertex_weights = [];
	         for (var j = 0; j < numBones; j++) {
	            var influence = {};
	            for (var k = 0; k < inputs.length; k++) {
	               var input = inputs[k];
	               var value = v[index + input.offset];
	               switch (input.semantic) {
	               case "JOINT":
	                  influence.joint = value;
	                  break;
	               case "WEIGHT":
	                  influence.weight = sources[input.source].data[value];
	                  break;
	               default:
	                  break
	               }
	            }
	            vertex_weights.push(influence);
	            index += inputs.length
	         }
	         for (var j = 0; j < vertex_weights.length; j++) {
	            vertex_weights[j].index = i
	         }
	         this.weights.push(vertex_weights)
	      }
	   };

	   function VisualScene() {
	      this.id = "";
	      this.name = "";
	      this.nodes = [];
	      this.scene = new THREE.Group
	   }
	   VisualScene.prototype.getChildById = function(id, recursive) {
	      for (var i = 0; i < this.nodes.length; i++) {
	         var node = this.nodes[i].getChildById(id, recursive);
	         if (node) {
	            return node
	         }
	      }
	      return null
	   };
	   VisualScene.prototype.getChildBySid = function(sid, recursive) {
	      for (var i = 0; i < this.nodes.length; i++) {
	         var node = this.nodes[i].getChildBySid(sid, recursive);
	         if (node) {
	            return node
	         }
	      }
	      return null
	   };
	   VisualScene.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      this.nodes = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "node":
	            this.nodes.push((new Node).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Node() {
	      this.id = "";
	      this.name = "";
	      this.sid = "";
	      this.nodes = [];
	      this.controllers = [];
	      this.transforms = [];
	      this.geometries = [];
	      this.channels = [];
	      this.matrix = new THREE.Matrix4
	   }
	   Node.prototype.getChannelForTransform = function(transformSid) {
	      for (var i = 0; i < this.channels.length; i++) {
	         var channel = this.channels[i];
	         var parts = channel.target.split("/");
	         var id = parts.shift();
	         var sid = parts.shift();
	         var dotSyntax = sid.indexOf(".") >= 0;
	         var arrSyntax = sid.indexOf("(") >= 0;
	         var arrIndices;
	         var member;
	         if (dotSyntax) {
	            parts = sid.split(".");
	            sid = parts.shift();
	            member = parts.shift()
	         } else if (arrSyntax) {
	            arrIndices = sid.split("(");
	            sid = arrIndices.shift();
	            for (var j = 0; j < arrIndices.length; j++) {
	               arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ""))
	            }
	         }
	         if (sid === transformSid) {
	            channel.info = {
	               sid: sid,
	               dotSyntax: dotSyntax,
	               arrSyntax: arrSyntax,
	               arrIndices: arrIndices
	            };
	            return channel
	         }
	      }
	      return null
	   };
	   Node.prototype.getChildById = function(id, recursive) {
	      if (this.id === id) {
	         return this
	      }
	      if (recursive) {
	         for (var i = 0; i < this.nodes.length; i++) {
	            var n = this.nodes[i].getChildById(id, recursive);
	            if (n) {
	               return n
	            }
	         }
	      }
	      return null
	   };
	   Node.prototype.getChildBySid = function(sid, recursive) {
	      if (this.sid === sid) {
	         return this
	      }
	      if (recursive) {
	         for (var i = 0; i < this.nodes.length; i++) {
	            var n = this.nodes[i].getChildBySid(sid, recursive);
	            if (n) {
	               return n
	            }
	         }
	      }
	      return null
	   };
	   Node.prototype.getTransformBySid = function(sid) {
	      for (var i = 0; i < this.transforms.length; i++) {
	         if (this.transforms[i].sid === sid) return this.transforms[i]
	      }
	      return null
	   };
	   Node.prototype.parse = function(element) {
	      var url;
	      this.id = element.getAttribute("id");
	      this.sid = element.getAttribute("sid");
	      this.name = element.getAttribute("name");
	      this.type = element.getAttribute("type");
	      this.layer = element.getAttribute("layer");
	      this.type = this.type === "JOINT" ? this.type : "NODE";
	      this.nodes = [];
	      this.transforms = [];
	      this.geometries = [];
	      this.cameras = [];
	      this.lights = [];
	      this.controllers = [];
	      this.matrix = new THREE.Matrix4;
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "node":
	            this.nodes.push((new Node).parse(child));
	            break;
	         case "instance_camera":
	            this.cameras.push((new InstanceCamera).parse(child));
	            break;
	         case "instance_controller":
	            this.controllers.push((new InstanceController).parse(child));
	            break;
	         case "instance_geometry":
	            this.geometries.push((new InstanceGeometry).parse(child));
	            break;
	         case "instance_light":
	            this.lights.push((new InstanceLight).parse(child));
	            break;
	         case "instance_node":
	            url = child.getAttribute("url").replace(/^#/, "");
	            var iNode = getLibraryNode(url);
	            if (iNode) {
	               this.nodes.push((new Node).parse(iNode))
	            }
	            break;
	         case "rotate":
	         case "translate":
	         case "scale":
	         case "matrix":
	         case "lookat":
	         case "skew":
	            this.transforms.push((new Transform).parse(child));
	            break;
	         case "extra":
	            break;
	         default:
	            console.log(child.nodeName);
	            break
	         }
	      }
	      this.channels = getChannelsForNode(this);
	      bakeAnimations(this);
	      this.updateMatrix();
	      return this
	   };
	   Node.prototype.updateMatrix = function() {
	      this.matrix.identity();
	      for (var i = 0; i < this.transforms.length; i++) {
	         this.transforms[i].apply(this.matrix)
	      }
	   };

	   function Transform() {
	      this.sid = "";
	      this.type = "";
	      this.data = [];
	      this.obj = null
	   }
	   Transform.prototype.parse = function(element) {
	      this.sid = element.getAttribute("sid");
	      this.type = element.nodeName;
	      this.data = _floats(element.textContent);
	      this.convert();
	      return this
	   };
	   Transform.prototype.convert = function() {
	      switch (this.type) {
	      case "matrix":
	         this.obj = getConvertedMat4(this.data);
	         break;
	      case "rotate":
	         this.angle = THREE.Math.degToRad(this.data[3]);
	      case "translate":
	         fixCoords(this.data, -1);
	         this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
	         break;
	      case "scale":
	         fixCoords(this.data, 1);
	         this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
	         break;
	      default:
	         console.log("Can not convert Transform of type " + this.type);
	         break
	      }
	   };
	   Transform.prototype.apply = function() {
	      var m1 = new THREE.Matrix4;
	      return function(matrix) {
	         switch (this.type) {
	         case "matrix":
	            matrix.multiply(this.obj);
	            break;
	         case "translate":
	            matrix.multiply(m1.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
	            break;
	         case "rotate":
	            matrix.multiply(m1.makeRotationAxis(this.obj, this.angle));
	            break;
	         case "scale":
	            matrix.scale(this.obj);
	            break
	         }
	      }
	   }();
	   Transform.prototype.update = function(data, member) {
	      var members = ["X", "Y", "Z", "ANGLE"];
	      switch (this.type) {
	      case "matrix":
	         if (!member) {
	            this.obj.copy(data)
	         } else if (member.length === 1) {
	            switch (member[0]) {
	            case 0:
	               this.obj.n11 = data[0];
	               this.obj.n21 = data[1];
	               this.obj.n31 = data[2];
	               this.obj.n41 = data[3];
	               break;
	            case 1:
	               this.obj.n12 = data[0];
	               this.obj.n22 = data[1];
	               this.obj.n32 = data[2];
	               this.obj.n42 = data[3];
	               break;
	            case 2:
	               this.obj.n13 = data[0];
	               this.obj.n23 = data[1];
	               this.obj.n33 = data[2];
	               this.obj.n43 = data[3];
	               break;
	            case 3:
	               this.obj.n14 = data[0];
	               this.obj.n24 = data[1];
	               this.obj.n34 = data[2];
	               this.obj.n44 = data[3];
	               break
	            }
	         } else if (member.length === 2) {
	            var propName = "n" + (member[0] + 1) + (member[1] + 1);
	            this.obj[propName] = data
	         } else {
	            console.log("Incorrect addressing of matrix in transform.")
	         }
	         break;
	      case "translate":
	      case "scale":
	         if (Object.prototype.toString.call(member) === "[object Array]") {
	            member = members[member[0]]
	         }
	         switch (member) {
	         case "X":
	            this.obj.x = data;
	            break;
	         case "Y":
	            this.obj.y = data;
	            break;
	         case "Z":
	            this.obj.z = data;
	            break;
	         default:
	            this.obj.x = data[0];
	            this.obj.y = data[1];
	            this.obj.z = data[2];
	            break
	         }
	         break;
	      case "rotate":
	         if (Object.prototype.toString.call(member) === "[object Array]") {
	            member = members[member[0]]
	         }
	         switch (member) {
	         case "X":
	            this.obj.x = data;
	            break;
	         case "Y":
	            this.obj.y = data;
	            break;
	         case "Z":
	            this.obj.z = data;
	            break;
	         case "ANGLE":
	            this.angle = THREE.Math.degToRad(data);
	            break;
	         default:
	            this.obj.x = data[0];
	            this.obj.y = data[1];
	            this.obj.z = data[2];
	            this.angle = THREE.Math.degToRad(data[3]);
	            break
	         }
	         break
	      }
	   };

	   function InstanceController() {
	      this.url = "";
	      this.skeleton = [];
	      this.instance_material = []
	   }
	   InstanceController.prototype.parse = function(element) {
	      this.url = element.getAttribute("url").replace(/^#/, "");
	      this.skeleton = [];
	      this.instance_material = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType !== 1) continue;
	         switch (child.nodeName) {
	         case "skeleton":
	            this.skeleton.push(child.textContent.replace(/^#/, ""));
	            break;
	         case "bind_material":
	            var instances = child.querySelectorAll("instance_material");
	            for (var j = 0; j < instances.length; j++) {
	               var instance = instances[j];
	               this.instance_material.push((new InstanceMaterial).parse(instance))
	            }
	            break;
	         case "extra":
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function InstanceMaterial() {
	      this.symbol = "";
	      this.target = ""
	   }
	   InstanceMaterial.prototype.parse = function(element) {
	      this.symbol = element.getAttribute("symbol");
	      this.target = element.getAttribute("target").replace(/^#/, "");
	      return this
	   };

	   function InstanceGeometry() {
	      this.url = "";
	      this.instance_material = []
	   }
	   InstanceGeometry.prototype.parse = function(element) {
	      this.url = element.getAttribute("url").replace(/^#/, "");
	      this.instance_material = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         if (child.nodeName === "bind_material") {
	            var instances = child.querySelectorAll("instance_material");
	            for (var j = 0; j < instances.length; j++) {
	               var instance = instances[j];
	               this.instance_material.push((new InstanceMaterial).parse(instance))
	            }
	            break
	         }
	      }
	      return this
	   };

	   function Geometry() {
	      this.id = "";
	      this.mesh = null
	   }
	   Geometry.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      extractDoubleSided(this, element);
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "mesh":
	            this.mesh = new Mesh(this).parse(child);
	            break;
	         case "extra":
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Mesh(geometry) {
	      this.geometry = geometry.id;
	      this.primitives = [];
	      this.vertices = null;
	      this.geometry3js = null
	   }
	   Mesh.prototype.parse = function(element) {
	      this.primitives = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "source":
	            _source(child);
	            break;
	         case "vertices":
	            this.vertices = (new Vertices).parse(child);
	            break;
	         case "linestrips":
	            this.primitives.push((new LineStrips).parse(child));
	            break;
	         case "triangles":
	            this.primitives.push((new Triangles).parse(child));
	            break;
	         case "polygons":
	            this.primitives.push((new Polygons).parse(child));
	            break;
	         case "polylist":
	            this.primitives.push((new Polylist).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      this.geometry3js = new THREE.Geometry;
	      if (this.vertices === null) {
	         return this
	      }
	      var vertexData = sources[this.vertices.input["POSITION"].source].data;
	      for (var i = 0; i < vertexData.length; i += 3) {
	         this.geometry3js.vertices.push(getConvertedVec3(vertexData, i).clone())
	      }
	      for (var i = 0; i < this.primitives.length; i++) {
	         var primitive = this.primitives[i];
	         primitive.setVertices(this.vertices);
	         this.handlePrimitive(primitive, this.geometry3js)
	      }
	      if (this.geometry3js.calcNormals) {
	         this.geometry3js.computeVertexNormals();
	         delete this.geometry3js.calcNormals
	      }
	      return this
	   };
	   Mesh.prototype.handlePrimitive = function(primitive, geom) {
	      if (primitive instanceof LineStrips) {
	         geom.isLineStrip = true;
	         return
	      }
	      var j, k, pList = primitive.p,
	         inputs = primitive.inputs;
	      var input, index, idx32;
	      var source, numParams;
	      var vcIndex = 0,
	         vcount = 3,
	         maxOffset = 0;
	      var texture_sets = [];
	      for (j = 0; j < inputs.length; j++) {
	         input = inputs[j];
	         var offset = input.offset + 1;
	         maxOffset = maxOffset < offset ? offset : maxOffset;
	         switch (input.semantic) {
	         case "TEXCOORD":
	            texture_sets.push(input.set);
	            break
	         }
	      }
	      for (var pCount = 0; pCount < pList.length; ++pCount) {
	         var p = pList[pCount],
	            i = 0;
	         while (i < p.length) {
	            var vs = [];
	            var ns = [];
	            var ts = null;
	            var cs = [];
	            if (primitive.vcount) {
	               vcount = primitive.vcount.length ? primitive.vcount[vcIndex++] : primitive.vcount
	            } else {
	               vcount = p.length / maxOffset
	            }
	            for (j = 0; j < vcount; j++) {
	               for (k = 0; k < inputs.length; k++) {
	                  input = inputs[k];
	                  source = sources[input.source];
	                  index = p[i + j * maxOffset + input.offset];
	                  numParams = source.accessor.params.length;
	                  idx32 = index * numParams;
	                  switch (input.semantic) {
	                  case "VERTEX":
	                     vs.push(index);
	                     break;
	                  case "NORMAL":
	                     ns.push(getConvertedVec3(source.data, idx32));
	                     break;
	                  case "TEXCOORD":
	                     ts = ts || {};
	                     if (ts[input.set] === undefined) ts[input.set] = [];
	                     ts[input.set].push(new THREE.Vector2(source.data[idx32], source.data[idx32 + 1]));
	                     break;
	                  case "COLOR":
	                     cs.push((new THREE.Color).setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
	                     break;
	                  default:
	                     break
	                  }
	               }
	            }
	            if (ns.length === 0) {
	               input = this.vertices.input.NORMAL;
	               if (input) {
	                  source = sources[input.source];
	                  numParams = source.accessor.params.length;
	                  for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
	                     ns.push(getConvertedVec3(source.data, vs[ndx] * numParams))
	                  }
	               } else {
	                  geom.calcNormals = true
	               }
	            }
	            if (!ts) {
	               ts = {};
	               input = this.vertices.input.TEXCOORD;
	               if (input) {
	                  texture_sets.push(input.set);
	                  source = sources[input.source];
	                  numParams = source.accessor.params.length;
	                  for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
	                     idx32 = vs[ndx] * numParams;
	                     if (ts[input.set] === undefined) ts[input.set] = [];
	                     ts[input.set].push(new THREE.Vector2(source.data[idx32], 1 - source.data[idx32 + 1]))
	                  }
	               }
	            }
	            if (cs.length === 0) {
	               input = this.vertices.input.COLOR;
	               if (input) {
	                  source = sources[input.source];
	                  numParams = source.accessor.params.length;
	                  for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
	                     idx32 = vs[ndx] * numParams;
	                     cs.push((new THREE.Color).setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]))
	                  }
	               }
	            }
	            var face = null,
	               faces = [],
	               uv, uvArr;
	            if (vcount === 3) {
	               faces.push(new THREE.Face3(vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color))
	            } else if (vcount === 4) {
	               faces.push(new THREE.Face3(vs[0], vs[1], vs[3], ns.length ? [ns[0].clone(), ns[1].clone(), ns[3].clone()] : [], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color));
	               faces.push(new THREE.Face3(vs[1], vs[2], vs[3], ns.length ? [ns[1].clone(), ns[2].clone(), ns[3].clone()] : [], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color))
	            } else if (vcount > 4 && options.subdivideFaces) {
	               var clr = cs.length ? cs : new THREE.Color,
	                  vec1, vec2, vec3, v1, v2, norm;
	               for (k = 1; k < vcount - 1;) {
	                  faces.push(new THREE.Face3(vs[0], vs[k], vs[k + 1], ns.length ? [ns[0].clone(), ns[k++].clone(), ns[k].clone()] : [], clr))
	               }
	            }
	            if (faces.length) {
	               for (var ndx = 0, len = faces.length; ndx < len; ndx++) {
	                  face = faces[ndx];
	                  face.daeMaterial = primitive.material;
	                  geom.faces.push(face);
	                  for (k = 0; k < texture_sets.length; k++) {
	                     uv = ts[texture_sets[k]];
	                     if (vcount > 4) {
	                        uvArr = [uv[0], uv[ndx + 1], uv[ndx + 2]]
	                     } else if (vcount === 4) {
	                        if (ndx === 0) {
	                           uvArr = [uv[0], uv[1], uv[3]]
	                        } else {
	                           uvArr = [uv[1].clone(), uv[2], uv[3].clone()]
	                        }
	                     } else {
	                        uvArr = [uv[0], uv[1], uv[2]]
	                     }
	                     if (geom.faceVertexUvs[k] === undefined) {
	                        geom.faceVertexUvs[k] = []
	                     }
	                     geom.faceVertexUvs[k].push(uvArr)
	                  }
	               }
	            } else {
	               console.log("dropped face with vcount " + vcount + " for geometry with id: " + geom.id)
	            }
	            i += maxOffset * vcount
	         }
	      }
	   };

	   function Polygons() {
	      this.material = "";
	      this.count = 0;
	      this.inputs = [];
	      this.vcount = null;
	      this.p = [];
	      this.geometry = new THREE.Geometry
	   }
	   Polygons.prototype.setVertices = function(vertices) {
	      for (var i = 0; i < this.inputs.length; i++) {
	         if (this.inputs[i].source === vertices.id) {
	            this.inputs[i].source = vertices.input["POSITION"].source
	         }
	      }
	   };
	   Polygons.prototype.parse = function(element) {
	      this.material = element.getAttribute("material");
	      this.count = _attr_as_int(element, "count", 0);
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "input":
	            this.inputs.push((new Input).parse(element.childNodes[i]));
	            break;
	         case "vcount":
	            this.vcount = _ints(child.textContent);
	            break;
	         case "p":
	            this.p.push(_ints(child.textContent));
	            break;
	         case "ph":
	            console.warn("polygon holes not yet supported!");
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Polylist() {
	      Polygons.call(this);
	      this.vcount = []
	   }
	   Polylist.prototype = Object.create(Polygons.prototype);
	   Polylist.prototype.constructor = Polylist;

	   function LineStrips() {
	      Polygons.call(this);
	      this.vcount = 1
	   }
	   LineStrips.prototype = Object.create(Polygons.prototype);
	   LineStrips.prototype.constructor = LineStrips;

	   function Triangles() {
	      Polygons.call(this);
	      this.vcount = 3
	   }
	   Triangles.prototype = Object.create(Polygons.prototype);
	   Triangles.prototype.constructor = Triangles;

	   function Accessor() {
	      this.source = "";
	      this.count = 0;
	      this.stride = 0;
	      this.params = []
	   }
	   Accessor.prototype.parse = function(element) {
	      this.params = [];
	      this.source = element.getAttribute("source");
	      this.count = _attr_as_int(element, "count", 0);
	      this.stride = _attr_as_int(element, "stride", 0);
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeName === "param") {
	            var param = {};
	            param["name"] = child.getAttribute("name");
	            param["type"] = child.getAttribute("type");
	            this.params.push(param)
	         }
	      }
	      return this
	   };

	   function Vertices() {
	      this.input = {}
	   }
	   Vertices.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         if (element.childNodes[i].nodeName === "input") {
	            var input = (new Input).parse(element.childNodes[i]);
	            this.input[input.semantic] = input
	         }
	      }
	      return this
	   };

	   function Input() {
	      this.semantic = "";
	      this.offset = 0;
	      this.source = "";
	      this.set = 0
	   }
	   Input.prototype.parse = function(element) {
	      this.semantic = element.getAttribute("semantic");
	      this.source = element.getAttribute("source").replace(/^#/, "");
	      this.set = _attr_as_int(element, "set", -1);
	      this.offset = _attr_as_int(element, "offset", 0);
	      if (this.semantic === "TEXCOORD" && this.set < 0) {
	         this.set = 0
	      }
	      return this
	   };

	   function Source(id) {
	      this.id = id;
	      this.type = null
	   }
	   Source.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "bool_array":
	            this.data = _bools(child.textContent);
	            this.type = child.nodeName;
	            break;
	         case "float_array":
	            this.data = _floats(child.textContent);
	            this.type = child.nodeName;
	            break;
	         case "int_array":
	            this.data = _ints(child.textContent);
	            this.type = child.nodeName;
	            break;
	         case "IDREF_array":
	         case "Name_array":
	            this.data = _strings(child.textContent);
	            this.type = child.nodeName;
	            break;
	         case "technique_common":
	            for (var j = 0; j < child.childNodes.length; j++) {
	               if (child.childNodes[j].nodeName === "accessor") {
	                  this.accessor = (new Accessor).parse(child.childNodes[j]);
	                  break
	               }
	            }
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   Source.prototype.read = function() {
	      var result = [];
	      var param = this.accessor.params[0];
	      switch (param.type) {
	      case "IDREF":
	      case "Name":
	      case "name":
	      case "float":
	         return this.data;
	      case "float4x4":
	         for (var j = 0; j < this.data.length; j += 16) {
	            var s = this.data.slice(j, j + 16);
	            var m = getConvertedMat4(s);
	            result.push(m)
	         }
	         break;
	      default:
	         console.log("ColladaLoader: Source: Read dont know how to read " + param.type + ".");
	         break
	      }
	      return result
	   };

	   function Material() {
	      this.id = "";
	      this.name = "";
	      this.instance_effect = null
	   }
	   Material.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         if (element.childNodes[i].nodeName === "instance_effect") {
	            this.instance_effect = (new InstanceEffect).parse(element.childNodes[i]);
	            break
	         }
	      }
	      return this
	   };

	   function ColorOrTexture() {
	      this.color = new THREE.Color;
	      this.color.setRGB(Math.random(), Math.random(), Math.random());
	      this.color.a = 1;
	      this.texture = null;
	      this.texcoord = null;
	      this.texOpts = null
	   }
	   ColorOrTexture.prototype.isColor = function() {
	      return this.texture === null
	   };
	   ColorOrTexture.prototype.isTexture = function() {
	      return this.texture != null
	   };
	   ColorOrTexture.prototype.parse = function(element) {
	      if (element.nodeName === "transparent") {
	         this.opaque = element.getAttribute("opaque")
	      }
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "color":
	            var rgba = _floats(child.textContent);
	            this.color = new THREE.Color;
	            this.color.setRGB(rgba[0], rgba[1], rgba[2]);
	            this.color.a = rgba[3];
	            break;
	         case "texture":
	            this.texture = child.getAttribute("texture");
	            this.texcoord = child.getAttribute("texcoord");
	            this.texOpts = {
	               offsetU: 0,
	               offsetV: 0,
	               repeatU: 1,
	               repeatV: 1,
	               wrapU: 1,
	               wrapV: 1
	            };
	            this.parseTexture(child);
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   ColorOrTexture.prototype.parseTexture = function(element) {
	      if (!element.childNodes) return this;
	      if (element.childNodes[1] && element.childNodes[1].nodeName === "extra") {
	         element = element.childNodes[1];
	         if (element.childNodes[1] && element.childNodes[1].nodeName === "technique") {
	            element = element.childNodes[1]
	         }
	      }
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "offsetU":
	         case "offsetV":
	         case "repeatU":
	         case "repeatV":
	            this.texOpts[child.nodeName] = parseFloat(child.textContent);
	            break;
	         case "wrapU":
	         case "wrapV":
	            if (child.textContent.toUpperCase() === "TRUE") {
	               this.texOpts[child.nodeName] = 1
	            } else {
	               this.texOpts[child.nodeName] = parseInt(child.textContent)
	            }
	            break;
	         default:
	            this.texOpts[child.nodeName] = child.textContent;
	            break
	         }
	      }
	      return this
	   };

	   function Shader(type, effect) {
	      this.type = type;
	      this.effect = effect;
	      this.material = null
	   }
	   Shader.prototype.parse = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "emission":
	         case "diffuse":
	         case "specular":
	         case "transparent":
	            this[child.nodeName] = (new ColorOrTexture).parse(child);
	            break;
	         case "bump":
	            var bumpType = child.getAttribute("bumptype");
	            if (bumpType) {
	               if (bumpType.toLowerCase() === "heightfield") {
	                  this["bump"] = (new ColorOrTexture).parse(child)
	               } else if (bumpType.toLowerCase() === "normalmap") {
	                  this["normal"] = (new ColorOrTexture).parse(child)
	               } else {
	                  console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'");
	                  this["bump"] = (new ColorOrTexture).parse(child)
	               }
	            } else {
	               console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'");
	               this["bump"] = (new ColorOrTexture).parse(child)
	            }
	            break;
	         case "shininess":
	         case "reflectivity":
	         case "index_of_refraction":
	         case "transparency":
	            var f = child.querySelectorAll("float");
	            if (f.length > 0) this[child.nodeName] = parseFloat(f[0].textContent);
	            break;
	         default:
	            break
	         }
	      }
	      this.create();
	      return this
	   };
	   Shader.prototype.create = function() {
	      var props = {};
	      var transparent = false;
	      if (this["transparency"] !== undefined && this["transparent"] !== undefined) {
	         var transparentColor = this["transparent"];
	         var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;
	         if (transparencyLevel > 0) {
	            transparent = true;
	            props["transparent"] = true;
	            props["opacity"] = 1 - transparencyLevel
	         }
	      }
	      var keys = {
	         diffuse: "map",
	         ambient: "lightMap",
	         specular: "specularMap",
	         emission: "emissionMap",
	         bump: "bumpMap",
	         normal: "normalMap"
	      };
	      for (var prop in this) {
	         switch (prop) {
	         case "ambient":
	         case "emission":
	         case "diffuse":
	         case "specular":
	         case "bump":
	         case "normal":
	            var cot = this[prop];
	            if (cot instanceof ColorOrTexture) {
	               if (cot.isTexture()) {
	                  var samplerId = cot.texture;
	                  var sampler = this.effect.sampler[samplerId];
	                  if (sampler !== undefined && sampler.source !== undefined) {
	                     var surface = this.effect.surface[sampler.source];
	                     if (surface !== undefined) {
	                        var image = images[surface.init_from];
	                        if (image) {
	                           var url = baseUrl + image.init_from;
	                           var texture;
	                           var loader = THREE.Loader.Handlers.get(url);
	                           if (loader !== null) {
	                              texture = loader.load(url)
	                           } else {
	                              texture = new THREE.Texture;
	                              loadTextureImage(texture, url)
	                           }
	                           if (sampler.wrap_s === "MIRROR") {
	                              texture.wrapS = THREE.MirroredRepeatWrapping
	                           } else if (sampler.wrap_s === "WRAP" || cot.texOpts.wrapU) {
	                              texture.wrapS = THREE.RepeatWrapping
	                           } else {
	                              texture.wrapS = THREE.ClampToEdgeWrapping
	                           }
	                           if (sampler.wrap_t === "MIRROR") {
	                              texture.wrapT = THREE.MirroredRepeatWrapping
	                           } else if (sampler.wrap_t === "WRAP" || cot.texOpts.wrapV) {
	                              texture.wrapT = THREE.RepeatWrapping
	                           } else {
	                              texture.wrapT = THREE.ClampToEdgeWrapping
	                           }
	                           texture.offset.x = cot.texOpts.offsetU;
	                           texture.offset.y = cot.texOpts.offsetV;
	                           texture.repeat.x = cot.texOpts.repeatU;
	                           texture.repeat.y = cot.texOpts.repeatV;
	                           props[keys[prop]] = texture;
	                           if (prop === "emission") props["emissive"] = 16777215
	                        }
	                     }
	                  }
	               } else if (prop === "diffuse" || !transparent) {
	                  if (prop === "emission") {
	                     props["emissive"] = cot.color.getHex()
	                  } else {
	                     props[prop] = cot.color.getHex()
	                  }
	               }
	            }
	            break;
	         case "shininess":
	            props[prop] = this[prop];
	            break;
	         case "reflectivity":
	            props[prop] = this[prop];
	            if (props[prop] > 0) props["envMap"] = options.defaultEnvMap;
	            props["combine"] = THREE.MixOperation;
	            break;
	         case "index_of_refraction":
	            props["refractionRatio"] = this[prop];
	            if (this[prop] !== 1) props["envMap"] = options.defaultEnvMap;
	            break;
	         case "transparency":
	            break;
	         default:
	            break
	         }
	      }
	      props["shading"] = preferredShading;
	      props["side"] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
	      if (props.diffuse !== undefined) {
	         props.color = props.diffuse;
	         delete props.diffuse
	      }
	      switch (this.type) {
	      case "constant":
	         if (props.emissive != undefined) props.color = props.emissive;
	         this.material = new THREE.MeshBasicMaterial(props);
	         break;
	      case "phong":
	      case "blinn":
	         this.material = new THREE.MeshPhongMaterial(props);
	         break;
	      case "lambert":
	      default:
	         this.material = new THREE.MeshLambertMaterial(props);
	         break
	      }
	      return this.material
	   };

	   function Surface(effect) {
	      this.effect = effect;
	      this.init_from = null;
	      this.format = null
	   }
	   Surface.prototype.parse = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "init_from":
	            this.init_from = child.textContent;
	            break;
	         case "format":
	            this.format = child.textContent;
	            break;
	         default:
	            console.log("unhandled Surface prop: " + child.nodeName);
	            break
	         }
	      }
	      return this
	   };

	   function Sampler2D(effect) {
	      this.effect = effect;
	      this.source = null;
	      this.wrap_s = null;
	      this.wrap_t = null;
	      this.minfilter = null;
	      this.magfilter = null;
	      this.mipfilter = null
	   }
	   Sampler2D.prototype.parse = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "source":
	            this.source = child.textContent;
	            break;
	         case "minfilter":
	            this.minfilter = child.textContent;
	            break;
	         case "magfilter":
	            this.magfilter = child.textContent;
	            break;
	         case "mipfilter":
	            this.mipfilter = child.textContent;
	            break;
	         case "wrap_s":
	            this.wrap_s = child.textContent;
	            break;
	         case "wrap_t":
	            this.wrap_t = child.textContent;
	            break;
	         default:
	            console.log("unhandled Sampler2D prop: " + child.nodeName);
	            break
	         }
	      }
	      return this
	   };

	   function Effect() {
	      this.id = "";
	      this.name = "";
	      this.shader = null;
	      this.surface = {};
	      this.sampler = {}
	   }
	   Effect.prototype.create = function() {
	      if (this.shader === null) {
	         return null
	      }
	   };
	   Effect.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      extractDoubleSided(this, element);
	      this.shader = null;
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "profile_COMMON":
	            this.parseTechnique(this.parseProfileCOMMON(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   Effect.prototype.parseNewparam = function(element) {
	      var sid = element.getAttribute("sid");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "surface":
	            this.surface[sid] = new Surface(this).parse(child);
	            break;
	         case "sampler2D":
	            this.sampler[sid] = new Sampler2D(this).parse(child);
	            break;
	         case "extra":
	            break;
	         default:
	            console.log(child.nodeName);
	            break
	         }
	      }
	   };
	   Effect.prototype.parseProfileCOMMON = function(element) {
	      var technique;
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "profile_COMMON":
	            this.parseProfileCOMMON(child);
	            break;
	         case "technique":
	            technique = child;
	            break;
	         case "newparam":
	            this.parseNewparam(child);
	            break;
	         case "image":
	            var _image = (new _Image).parse(child);
	            images[_image.id] = _image;
	            break;
	         case "extra":
	            break;
	         default:
	            console.log(child.nodeName);
	            break
	         }
	      }
	      return technique
	   };
	   Effect.prototype.parseTechnique = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "constant":
	         case "lambert":
	         case "blinn":
	         case "phong":
	            this.shader = new Shader(child.nodeName, this).parse(child);
	            break;
	         case "extra":
	            this.parseExtra(child);
	            break;
	         default:
	            break
	         }
	      }
	   };
	   Effect.prototype.parseExtra = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "technique":
	            this.parseExtraTechnique(child);
	            break;
	         default:
	            break
	         }
	      }
	   };
	   Effect.prototype.parseExtraTechnique = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "bump":
	            this.shader.parse(element);
	            break;
	         default:
	            break
	         }
	      }
	   };

	   function InstanceEffect() {
	      this.url = ""
	   }
	   InstanceEffect.prototype.parse = function(element) {
	      this.url = element.getAttribute("url").replace(/^#/, "");
	      return this
	   };

	   function Animation() {
	      this.id = "";
	      this.name = "";
	      this.source = {};
	      this.sampler = [];
	      this.channel = []
	   }
	   Animation.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      this.source = {};
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "animation":
	            var anim = (new Animation).parse(child);
	            for (var src in anim.source) {
	               this.source[src] = anim.source[src]
	            }
	            for (var j = 0; j < anim.channel.length; j++) {
	               this.channel.push(anim.channel[j]);
	               this.sampler.push(anim.sampler[j])
	            }
	            break;
	         case "source":
	            var src = (new Source).parse(child);
	            this.source[src.id] = src;
	            break;
	         case "sampler":
	            this.sampler.push(new Sampler(this).parse(child));
	            break;
	         case "channel":
	            this.channel.push(new Channel(this).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Channel(animation) {
	      this.animation = animation;
	      this.source = "";
	      this.target = "";
	      this.fullSid = null;
	      this.sid = null;
	      this.dotSyntax = null;
	      this.arrSyntax = null;
	      this.arrIndices = null;
	      this.member = null
	   }
	   Channel.prototype.parse = function(element) {
	      this.source = element.getAttribute("source").replace(/^#/, "");
	      this.target = element.getAttribute("target");
	      var parts = this.target.split("/");
	      var id = parts.shift();
	      var sid = parts.shift();
	      var dotSyntax = sid.indexOf(".") >= 0;
	      var arrSyntax = sid.indexOf("(") >= 0;
	      if (dotSyntax) {
	         parts = sid.split(".");
	         this.sid = parts.shift();
	         this.member = parts.shift()
	      } else if (arrSyntax) {
	         var arrIndices = sid.split("(");
	         this.sid = arrIndices.shift();
	         for (var j = 0; j < arrIndices.length; j++) {
	            arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ""))
	         }
	         this.arrIndices = arrIndices
	      } else {
	         this.sid = sid
	      }
	      this.fullSid = sid;
	      this.dotSyntax = dotSyntax;
	      this.arrSyntax = arrSyntax;
	      return this
	   };

	   function Sampler(animation) {
	      this.id = "";
	      this.animation = animation;
	      this.inputs = [];
	      this.input = null;
	      this.output = null;
	      this.strideOut = null;
	      this.interpolation = null;
	      this.startTime = null;
	      this.endTime = null;
	      this.duration = 0
	   }
	   Sampler.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.inputs = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "input":
	            this.inputs.push((new Input).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   Sampler.prototype.create = function() {
	      for (var i = 0; i < this.inputs.length; i++) {
	         var input = this.inputs[i];
	         var source = this.animation.source[input.source];
	         switch (input.semantic) {
	         case "INPUT":
	            this.input = source.read();
	            break;
	         case "OUTPUT":
	            this.output = source.read();
	            this.strideOut = source.accessor.stride;
	            break;
	         case "INTERPOLATION":
	            this.interpolation = source.read();
	            break;
	         case "IN_TANGENT":
	            break;
	         case "OUT_TANGENT":
	            break;
	         default:
	            console.log(input.semantic);
	            break
	         }
	      }
	      this.startTime = 0;
	      this.endTime = 0;
	      this.duration = 0;
	      if (this.input.length) {
	         this.startTime = 1e8;
	         this.endTime = -1e8;
	         for (var i = 0; i < this.input.length; i++) {
	            this.startTime = Math.min(this.startTime, this.input[i]);
	            this.endTime = Math.max(this.endTime, this.input[i])
	         }
	         this.duration = this.endTime - this.startTime
	      }
	   };
	   Sampler.prototype.getData = function(type, ndx, member) {
	      var data;
	      if (type === "matrix" && this.strideOut === 16) {
	         data = this.output[ndx]
	      } else if (this.strideOut > 1) {
	         data = [];
	         ndx *= this.strideOut;
	         for (var i = 0; i < this.strideOut; ++i) {
	            data[i] = this.output[ndx + i]
	         }
	         if (this.strideOut === 3) {
	            switch (type) {
	            case "rotate":
	            case "translate":
	               fixCoords(data, -1);
	               break;
	            case "scale":
	               fixCoords(data, 1);
	               break
	            }
	         } else if (this.strideOut === 4 && type === "matrix") {
	            fixCoords(data, -1)
	         }
	      } else {
	         data = this.output[ndx];
	         if (member && type === "translate") {
	            data = getConvertedTranslation(member, data)
	         }
	      }
	      return data
	   };

	   function Key(time) {
	      this.targets = [];
	      this.time = time
	   }
	   Key.prototype.addTarget = function(fullSid, transform, member, data) {
	      this.targets.push({
	         sid: fullSid,
	         member: member,
	         transform: transform,
	         data: data
	      })
	   };
	   Key.prototype.apply = function(opt_sid) {
	      for (var i = 0; i < this.targets.length; ++i) {
	         var target = this.targets[i];
	         if (!opt_sid || target.sid === opt_sid) {
	            target.transform.update(target.data, target.member)
	         }
	      }
	   };
	   Key.prototype.getTarget = function(fullSid) {
	      for (var i = 0; i < this.targets.length; ++i) {
	         if (this.targets[i].sid === fullSid) {
	            return this.targets[i]
	         }
	      }
	      return null
	   };
	   Key.prototype.hasTarget = function(fullSid) {
	      for (var i = 0; i < this.targets.length; ++i) {
	         if (this.targets[i].sid === fullSid) {
	            return true
	         }
	      }
	      return false
	   };
	   Key.prototype.interpolate = function(nextKey, time) {
	      for (var i = 0, l = this.targets.length; i < l; i++) {
	         var target = this.targets[i],
	            nextTarget = nextKey.getTarget(target.sid),
	            data;
	         if (target.transform.type !== "matrix" && nextTarget) {
	            var scale = (time - this.time) / (nextKey.time - this.time),
	               nextData = nextTarget.data,
	               prevData = target.data;
	            if (scale < 0) scale = 0;
	            if (scale > 1) scale = 1;
	            if (prevData.length) {
	               data = [];
	               for (var j = 0; j < prevData.length; ++j) {
	                  data[j] = prevData[j] + (nextData[j] - prevData[j]) * scale
	               }
	            } else {
	               data = prevData + (nextData - prevData) * scale
	            }
	         } else {
	            data = target.data
	         }
	         target.transform.update(data, target.member)
	      }
	   };

	   function Camera() {
	      this.id = "";
	      this.name = "";
	      this.technique = ""
	   }
	   Camera.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "optics":
	            this.parseOptics(child);
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   Camera.prototype.parseOptics = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         if (element.childNodes[i].nodeName === "technique_common") {
	            var technique = element.childNodes[i];
	            for (var j = 0; j < technique.childNodes.length; j++) {
	               this.technique = technique.childNodes[j].nodeName;
	               if (this.technique === "perspective") {
	                  var perspective = technique.childNodes[j];
	                  for (var k = 0; k < perspective.childNodes.length; k++) {
	                     var param = perspective.childNodes[k];
	                     switch (param.nodeName) {
	                     case "yfov":
	                        this.yfov = param.textContent;
	                        break;
	                     case "xfov":
	                        this.xfov = param.textContent;
	                        break;
	                     case "znear":
	                        this.znear = param.textContent;
	                        break;
	                     case "zfar":
	                        this.zfar = param.textContent;
	                        break;
	                     case "aspect_ratio":
	                        this.aspect_ratio = param.textContent;
	                        break
	                     }
	                  }
	               } else if (this.technique === "orthographic") {
	                  var orthographic = technique.childNodes[j];
	                  for (var k = 0; k < orthographic.childNodes.length; k++) {
	                     var param = orthographic.childNodes[k];
	                     switch (param.nodeName) {
	                     case "xmag":
	                        this.xmag = param.textContent;
	                        break;
	                     case "ymag":
	                        this.ymag = param.textContent;
	                        break;
	                     case "znear":
	                        this.znear = param.textContent;
	                        break;
	                     case "zfar":
	                        this.zfar = param.textContent;
	                        break;
	                     case "aspect_ratio":
	                        this.aspect_ratio = param.textContent;
	                        break
	                     }
	                  }
	               }
	            }
	         }
	      }
	      return this
	   };

	   function InstanceCamera() {
	      this.url = ""
	   }
	   InstanceCamera.prototype.parse = function(element) {
	      this.url = element.getAttribute("url").replace(/^#/, "");
	      return this
	   };

	   function Light() {
	      this.id = "";
	      this.name = "";
	      this.technique = ""
	   }
	   Light.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "technique_common":
	            this.parseCommon(child);
	            break;
	         case "technique":
	            this.parseTechnique(child);
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   Light.prototype.parseCommon = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         switch (element.childNodes[i].nodeName) {
	         case "directional":
	         case "point":
	         case "spot":
	         case "ambient":
	            this.technique = element.childNodes[i].nodeName;
	            var light = element.childNodes[i];
	            for (var j = 0; j < light.childNodes.length; j++) {
	               var child = light.childNodes[j];
	               switch (child.nodeName) {
	               case "color":
	                  var rgba = _floats(child.textContent);
	                  this.color = new THREE.Color(0);
	                  this.color.setRGB(rgba[0], rgba[1], rgba[2]);
	                  this.color.a = rgba[3];
	                  break;
	               case "falloff_angle":
	                  this.falloff_angle = parseFloat(child.textContent);
	                  break;
	               case "quadratic_attenuation":
	                  var f = parseFloat(child.textContent);
	                  this.distance = f ? Math.sqrt(1 / f) : 0
	               }
	            }
	         }
	      }
	      return this
	   };
	   Light.prototype.parseTechnique = function(element) {
	      this.profile = element.getAttribute("profile");
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         switch (child.nodeName) {
	         case "intensity":
	            this.intensity = parseFloat(child.textContent);
	            break
	         }
	      }
	      return this
	   };

	   function InstanceLight() {
	      this.url = ""
	   }
	   InstanceLight.prototype.parse = function(element) {
	      this.url = element.getAttribute("url").replace(/^#/, "");
	      return this
	   };

	   function KinematicsModel() {
	      this.id = "";
	      this.name = "";
	      this.joints = [];
	      this.links = []
	   }
	   KinematicsModel.prototype.parse = function(element) {
	      this.id = element.getAttribute("id");
	      this.name = element.getAttribute("name");
	      this.joints = [];
	      this.links = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "technique_common":
	            this.parseCommon(child);
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };
	   KinematicsModel.prototype.parseCommon = function(element) {
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (element.childNodes[i].nodeName) {
	         case "joint":
	            this.joints.push((new Joint).parse(child));
	            break;
	         case "link":
	            this.links.push((new Link).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Joint() {
	      this.sid = "";
	      this.name = "";
	      this.axis = new THREE.Vector3;
	      this.limits = {
	         min: 0,
	         max: 0
	      };
	      this.type = "";
	      this.static = false;
	      this.zeroPosition = 0;
	      this.middlePosition = 0
	   }
	   Joint.prototype.parse = function(element) {
	      this.sid = element.getAttribute("sid");
	      this.name = element.getAttribute("name");
	      this.axis = new THREE.Vector3;
	      this.limits = {
	         min: 0,
	         max: 0
	      };
	      this.type = "";
	      this.static = false;
	      this.zeroPosition = 0;
	      this.middlePosition = 0;
	      var axisElement = element.querySelector("axis");
	      var _axis = _floats(axisElement.textContent);
	      this.axis = getConvertedVec3(_axis, 0);
	      var min = element.querySelector("limits min") ? parseFloat(element.querySelector("limits min").textContent) : -360;
	      var max = element.querySelector("limits max") ? parseFloat(element.querySelector("limits max").textContent) : 360;
	      this.limits = {
	         min: min,
	         max: max
	      };
	      var jointTypes = ["prismatic", "revolute"];
	      for (var i = 0; i < jointTypes.length; i++) {
	         var type = jointTypes[i];
	         var jointElement = element.querySelector(type);
	         if (jointElement) {
	            this.type = type
	         }
	      }
	      if (this.limits.min >= this.limits.max) {
	         this.static = true
	      }
	      this.middlePosition = (this.limits.min + this.limits.max) / 2;
	      return this
	   };

	   function Link() {
	      this.sid = "";
	      this.name = "";
	      this.transforms = [];
	      this.attachments = []
	   }
	   Link.prototype.parse = function(element) {
	      this.sid = element.getAttribute("sid");
	      this.name = element.getAttribute("name");
	      this.transforms = [];
	      this.attachments = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "attachment_full":
	            this.attachments.push((new Attachment).parse(child));
	            break;
	         case "rotate":
	         case "translate":
	         case "matrix":
	            this.transforms.push((new Transform).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function Attachment() {
	      this.joint = "";
	      this.transforms = [];
	      this.links = []
	   }
	   Attachment.prototype.parse = function(element) {
	      this.joint = element.getAttribute("joint").split("/").pop();
	      this.links = [];
	      for (var i = 0; i < element.childNodes.length; i++) {
	         var child = element.childNodes[i];
	         if (child.nodeType != 1) continue;
	         switch (child.nodeName) {
	         case "link":
	            this.links.push((new Link).parse(child));
	            break;
	         case "rotate":
	         case "translate":
	         case "matrix":
	            this.transforms.push((new Transform).parse(child));
	            break;
	         default:
	            break
	         }
	      }
	      return this
	   };

	   function _source(element) {
	      var id = element.getAttribute("id");
	      if (sources[id] != undefined) {
	         return sources[id]
	      }
	      sources[id] = new Source(id).parse(element);
	      return sources[id]
	   }
	   function _nsResolver(nsPrefix) {
	      if (nsPrefix === "dae") {
	         return "http://www.collada.org/2005/11/COLLADASchema"
	      }
	      return null
	   }
	   function _bools(str) {
	      var raw = _strings(str);
	      var data = [];
	      for (var i = 0, l = raw.length; i < l; i++) {
	         data.push(raw[i] === "true" || raw[i] === "1" ? true : false)
	      }
	      return data
	   }
	   function _floats(str) {
	      var raw = _strings(str);
	      var data = [];
	      for (var i = 0, l = raw.length; i < l; i++) {
	         data.push(parseFloat(raw[i]))
	      }
	      return data
	   }
	   function _ints(str) {
	      var raw = _strings(str);
	      var data = [];
	      for (var i = 0, l = raw.length; i < l; i++) {
	         data.push(parseInt(raw[i], 10))
	      }
	      return data
	   }
	   function _strings(str) {
	      return str.length > 0 ? _trimString(str).split(/\s+/) : []
	   }

	   function _trimString(str) {
	      return str.replace(/^\s+/, "").replace(/\s+$/, "")
	   }
	   function _attr_as_float(element, name, defaultValue) {
	      if (element.hasAttribute(name)) {
	         return parseFloat(element.getAttribute(name))
	      } else {
	         return defaultValue
	      }
	   }
	   function _attr_as_int(element, name, defaultValue) {
	      if (element.hasAttribute(name)) {
	         return parseInt(element.getAttribute(name), 10)
	      } else {
	         return defaultValue
	      }
	   }
	   function _attr_as_string(element, name, defaultValue) {
	      if (element.hasAttribute(name)) {
	         return element.getAttribute(name)
	      } else {
	         return defaultValue
	      }
	   }
	   function _format_float(f, num) {
	      if (f === undefined) {
	         var s = "0.";
	         while (s.length < num + 2) {
	            s += "0"
	         }
	         return s
	      }
	      num = num || 2;
	      var parts = f.toString().split(".");
	      parts[1] = parts.length > 1 ? parts[1].substr(0, num) : "0";
	      while (parts[1].length < num) {
	         parts[1] += "0"
	      }
	      return parts.join(".")
	   }
	   function loadTextureImage(texture, url) {
	      var loader = new THREE.ImageLoader;
	      loader.load(url, function(image) {
	         texture.image = image;
	         texture.needsUpdate = true
	      })
	   }
	   function extractDoubleSided(obj, element) {
	      obj.doubleSided = false;
	      var node = element.querySelectorAll("extra double_sided")[0];
	      if (node) {
	         if (node && parseInt(node.textContent, 10) === 1) {
	            obj.doubleSided = true
	         }
	      }
	   }
	   function setUpConversion() {
	      if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
	         upConversion = null
	      } else {
	         switch (colladaUp) {
	         case "X":
	            upConversion = options.upAxis === "Y" ? "XtoY" : "XtoZ";
	            break;
	         case "Y":
	            upConversion = options.upAxis === "X" ? "YtoX" : "YtoZ";
	            break;
	         case "Z":
	            upConversion = options.upAxis === "X" ? "ZtoX" : "ZtoY";
	            break
	         }
	      }
	   }
	   function fixCoords(data, sign) {
	      if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
	         return
	      }
	      switch (upConversion) {
	      case "XtoY":
	         var tmp = data[0];
	         data[0] = sign * data[1];
	         data[1] = tmp;
	         break;
	      case "XtoZ":
	         var tmp = data[2];
	         data[2] = data[1];
	         data[1] = data[0];
	         data[0] = tmp;
	         break;
	      case "YtoX":
	         var tmp = data[0];
	         data[0] = data[1];
	         data[1] = sign * tmp;
	         break;
	      case "YtoZ":
	         var tmp = data[1];
	         data[1] = sign * data[2];
	         data[2] = tmp;
	         break;
	      case "ZtoX":
	         var tmp = data[0];
	         data[0] = data[1];
	         data[1] = data[2];
	         data[2] = tmp;
	         break;
	      case "ZtoY":
	         var tmp = data[1];
	         data[1] = data[2];
	         data[2] = sign * tmp;
	         break
	      }
	   }
	   function getConvertedTranslation(axis, data) {
	      if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
	         return data
	      }
	      switch (axis) {
	      case "X":
	         data = upConversion === "XtoY" ? data * -1 : data;
	         break;
	      case "Y":
	         data = upConversion === "YtoZ" || upConversion === "YtoX" ? data * -1 : data;
	         break;
	      case "Z":
	         data = upConversion === "ZtoY" ? data * -1 : data;
	         break;
	      default:
	         break
	      }
	      return data
	   }
	   function getConvertedVec3(data, offset) {
	      var arr = [data[offset], data[offset + 1], data[offset + 2]];
	      fixCoords(arr, -1);
	      return new THREE.Vector3(arr[0], arr[1], arr[2])
	   }
	   function getConvertedMat4(data) {
	      if (options.convertUpAxis) {
	         var arr = [data[0], data[4], data[8]];
	         fixCoords(arr, -1);
	         data[0] = arr[0];
	         data[4] = arr[1];
	         data[8] = arr[2];
	         arr = [data[1], data[5], data[9]];
	         fixCoords(arr, -1);
	         data[1] = arr[0];
	         data[5] = arr[1];
	         data[9] = arr[2];
	         arr = [data[2], data[6], data[10]];
	         fixCoords(arr, -1);
	         data[2] = arr[0];
	         data[6] = arr[1];
	         data[10] = arr[2];
	         arr = [data[0], data[1], data[2]];
	         fixCoords(arr, -1);
	         data[0] = arr[0];
	         data[1] = arr[1];
	         data[2] = arr[2];
	         arr = [data[4], data[5], data[6]];
	         fixCoords(arr, -1);
	         data[4] = arr[0];
	         data[5] = arr[1];
	         data[6] = arr[2];
	         arr = [data[8], data[9], data[10]];
	         fixCoords(arr, -1);
	         data[8] = arr[0];
	         data[9] = arr[1];
	         data[10] = arr[2];
	         arr = [data[3], data[7], data[11]];
	         fixCoords(arr, -1);
	         data[3] = arr[0];
	         data[7] = arr[1];
	         data[11] = arr[2]
	      }
	      return (new THREE.Matrix4).set(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15])
	   }
	   function getConvertedIndex(index) {
	      if (index > -1 && index < 3) {
	         var members = ["X", "Y", "Z"],
	            indices = {
	               X: 0,
	               Y: 1,
	               Z: 2
	            };
	         index = getConvertedMember(members[index]);
	         index = indices[index]
	      }
	      return index
	   }
	   function getConvertedMember(member) {
	      if (options.convertUpAxis) {
	         switch (member) {
	         case "X":
	            switch (upConversion) {
	            case "XtoY":
	            case "XtoZ":
	            case "YtoX":
	               member = "Y";
	               break;
	            case "ZtoX":
	               member = "Z";
	               break
	            }
	            break;
	         case "Y":
	            switch (upConversion) {
	            case "XtoY":
	            case "YtoX":
	            case "ZtoX":
	               member = "X";
	               break;
	            case "XtoZ":
	            case "YtoZ":
	            case "ZtoY":
	               member = "Z";
	               break
	            }
	            break;
	         case "Z":
	            switch (upConversion) {
	            case "XtoZ":
	               member = "X";
	               break;
	            case "YtoZ":
	            case "ZtoX":
	            case "ZtoY":
	               member = "Y";
	               break
	            }
	            break
	         }
	      }
	      return member
	   }
	   return {
	      load: load,
	      parse: parse,
	      setPreferredShading: setPreferredShading,
	      applySkin: applySkin,
	      geometries: geometries,
	      options: options
	   }
	};
	var Detector = {
	   canvas: !! window.CanvasRenderingContext2D,
	   webgl: function() {
	      try {
	         var canvas = document.createElement("canvas");
	         return !!(window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")))
	      } catch (e) {
	         return false
	      }
	   }(),
	   workers: !! window.Worker,
	   fileapi: window.File && window.FileReader && window.FileList && window.Blob,
	   getWebGLErrorMessage: function() {
	      var element = document.createElement("div");
	      element.id = "webgl-error-message";
	      element.style.fontFamily = "monospace";
	      element.style.fontSize = "13px";
	      element.style.fontWeight = "normal";
	      element.style.textAlign = "center";
	      element.style.background = "#fff";
	      element.style.color = "#000";
	      element.style.padding = "1.5em";
	      element.style.width = "400px";
	      element.style.margin = "5em auto 0";
	      if (!this.webgl) {
	         element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n")
	      }
	      return element
	   },
	   addGetWebGLMessage: function(parameters) {
	      var parent, id, element;
	      parameters = parameters || {};
	      parent = parameters.parent !== undefined ? parameters.parent : document.body;
	      id = parameters.id !== undefined ? parameters.id : "oldie";
	      element = Detector.getWebGLErrorMessage();
	      element.id = id;
	      parent.appendChild(element)
	   }
	};
	if (true) {
	   module.exports = Detector
	}!
	function(a, b) {
	   "use strict";
	   "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
	      if (!a.document) throw new Error("jQuery requires a window with a document");
	      return b(a)
	   } : b(a)
	}("undefined" != typeof window ? window : this, function(a, b) {
	   "use strict";
	   var c = [],
	      d = a.document,
	      e = Object.getPrototypeOf,
	      f = c.slice,
	      g = c.concat,
	      h = c.push,
	      i = c.indexOf,
	      j = {},
	      k = j.toString,
	      l = j.hasOwnProperty,
	      m = l.toString,
	      n = m.call(Object),
	      o = {};

	   function p(a, b) {
	      b = b || d;
	      var c = b.createElement("script");
	      c.text = a, b.head.appendChild(c).parentNode.removeChild(c)
	   }
	   var q = "3.2.1",
	      r = function(a, b) {
	         return new r.fn.init(a, b)
	      },
	      s = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	      t = /^-ms-/,
	      u = /-([a-z])/g,
	      v = function(a, b) {
	         return b.toUpperCase()
	      };
	   r.fn = r.prototype = {
	      jquery: q,
	      constructor: r,
	      length: 0,
	      toArray: function() {
	         return f.call(this)
	      },
	      get: function(a) {
	         return null == a ? f.call(this) : a < 0 ? this[a + this.length] : this[a]
	      },
	      pushStack: function(a) {
	         var b = r.merge(this.constructor(), a);
	         return b.prevObject = this, b
	      },
	      each: function(a) {
	         return r.each(this, a)
	      },
	      map: function(a) {
	         return this.pushStack(r.map(this, function(b, c) {
	            return a.call(b, c, b)
	         }))
	      },
	      slice: function() {
	         return this.pushStack(f.apply(this, arguments))
	      },
	      first: function() {
	         return this.eq(0)
	      },
	      last: function() {
	         return this.eq(-1)
	      },
	      eq: function(a) {
	         var b = this.length,
	            c = +a + (a < 0 ? b : 0);
	         return this.pushStack(c >= 0 && c < b ? [this[c]] : [])
	      },
	      end: function() {
	         return this.prevObject || this.constructor()
	      },
	      push: h,
	      sort: c.sort,
	      splice: c.splice
	   }, r.extend = r.fn.extend = function() {
	      var a, b, c, d, e, f, g = arguments[0] || {},
	         h = 1,
	         i = arguments.length,
	         j = !1;
	      for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || r.isFunction(g) || (g = {}), h === i && (g = this, h--); h < i; h++) if (null != (a = arguments[h])) for (b in a) c = g[b], d = a[b], g !== d && (j && d && (r.isPlainObject(d) || (e = Array.isArray(d))) ? (e ? (e = !1, f = c && Array.isArray(c) ? c : []) : f = c && r.isPlainObject(c) ? c : {}, g[b] = r.extend(j, f, d)) : void 0 !== d && (g[b] = d));
	      return g
	   }, r.extend({
	      expando: "jQuery" + (q + Math.random()).replace(/\D/g, ""),
	      isReady: !0,
	      error: function(a) {
	         throw new Error(a)
	      },
	      noop: function() {},
	      isFunction: function(a) {
	         return "function" === r.type(a)
	      },
	      isWindow: function(a) {
	         return null != a && a === a.window
	      },
	      isNumeric: function(a) {
	         var b = r.type(a);
	         return ("number" === b || "string" === b) && !isNaN(a - parseFloat(a))
	      },
	      isPlainObject: function(a) {
	         var b, c;
	         return !(!a || "[object Object]" !== k.call(a)) && (!(b = e(a)) || (c = l.call(b, "constructor") && b.constructor, "function" == typeof c && m.call(c) === n))
	      },
	      isEmptyObject: function(a) {
	         var b;
	         for (b in a) return !1;
	         return !0
	      },
	      type: function(a) {
	         return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? j[k.call(a)] || "object" : typeof a
	      },
	      globalEval: function(a) {
	         p(a)
	      },
	      camelCase: function(a) {
	         return a.replace(t, "ms-").replace(u, v)
	      },
	      each: function(a, b) {
	         var c, d = 0;
	         if (w(a)) {
	            for (c = a.length; d < c; d++) if (b.call(a[d], d, a[d]) === !1) break
	         } else for (d in a) if (b.call(a[d], d, a[d]) === !1) break;
	         return a
	      },
	      trim: function(a) {
	         return null == a ? "" : (a + "").replace(s, "")
	      },
	      makeArray: function(a, b) {
	         var c = b || [];
	         return null != a && (w(Object(a)) ? r.merge(c, "string" == typeof a ? [a] : a) : h.call(c, a)), c
	      },
	      inArray: function(a, b, c) {
	         return null == b ? -1 : i.call(b, a, c)
	      },
	      merge: function(a, b) {
	         for (var c = +b.length, d = 0, e = a.length; d < c; d++) a[e++] = b[d];
	         return a.length = e, a
	      },
	      grep: function(a, b, c) {
	         for (var d, e = [], f = 0, g = a.length, h = !c; f < g; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
	         return e
	      },
	      map: function(a, b, c) {
	         var d, e, f = 0,
	            h = [];
	         if (w(a)) for (d = a.length; f < d; f++) e = b(a[f], f, c), null != e && h.push(e);
	         else for (f in a) e = b(a[f], f, c), null != e && h.push(e);
	         return g.apply([], h)
	      },
	      guid: 1,
	      proxy: function(a, b) {
	         var c, d, e;
	         if ("string" == typeof b && (c = a[b], b = a, a = c), r.isFunction(a)) return d = f.call(arguments, 2), e = function() {
	            return a.apply(b || this, d.concat(f.call(arguments)))
	         }, e.guid = a.guid = a.guid || r.guid++, e
	      },
	      now: Date.now,
	      support: o
	   }), "function" == typeof Symbol && (r.fn[Symbol.iterator] = c[Symbol.iterator]), r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
	      j["[object " + b + "]"] = b.toLowerCase()
	   });

	   function w(a) {
	      var b = !! a && "length" in a && a.length,
	         c = r.type(a);
	      return "function" !== c && !r.isWindow(a) && ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a)
	   }
	   var x = function(a) {
	         var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date,
	            v = a.document,
	            w = 0,
	            x = 0,
	            y = ha(),
	            z = ha(),
	            A = ha(),
	            B = function(a, b) {
	               return a === b && (l = !0), 0
	            },
	            C = {}.hasOwnProperty,
	            D = [],
	            E = D.pop,
	            F = D.push,
	            G = D.push,
	            H = D.slice,
	            I = function(a, b) {
	               for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c;
	               return -1
	            },
	            J = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	            K = "[\\x20\\t\\r\\n\\f]",
	            L = "(?:\\\\.|[\\w-]|[^\x00-\\xa0])+",
	            M = "\\[" + K + "*(" + L + ")(?:" + K + "*([*^$|!~]?=)" + K + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + L + "))|)" + K + "*\\]",
	            N = ":(" + L + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + M + ")*)|.*)\\)|)",
	            O = new RegExp(K + "+", "g"),
	            P = new RegExp("^" + K + "+|((?:^|[^\\\\])(?:\\\\.)*)" + K + "+$", "g"),
	            Q = new RegExp("^" + K + "*," + K + "*"),
	            R = new RegExp("^" + K + "*([>+~]|" + K + ")" + K + "*"),
	            S = new RegExp("=" + K + "*([^\\]'\"]*?)" + K + "*\\]", "g"),
	            T = new RegExp(N),
	            U = new RegExp("^" + L + "$"),
	            V = {
	               ID: new RegExp("^#(" + L + ")"),
	               CLASS: new RegExp("^\\.(" + L + ")"),
	               TAG: new RegExp("^(" + L + "|[*])"),
	               ATTR: new RegExp("^" + M),
	               PSEUDO: new RegExp("^" + N),
	               CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + K + "*(even|odd|(([+-]|)(\\d*)n|)" + K + "*(?:([+-]|)" + K + "*(\\d+)|))" + K + "*\\)|)", "i"),
	               bool: new RegExp("^(?:" + J + ")$", "i"),
	               needsContext: new RegExp("^" + K + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + K + "*((?:-\\d)?\\d*)" + K + "*\\)|)(?=[^-]|$)", "i")
	            },
	            W = /^(?:input|select|textarea|button)$/i,
	            X = /^h\d$/i,
	            Y = /^[^{]+\{\s*\[native \w/,
	            Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	            $ = /[+~]/,
	            _ = new RegExp("\\\\([\\da-f]{1,6}" + K + "?|(" + K + ")|.)", "ig"),
	            aa = function(a, b, c) {
	               var d = "0x" + b - 65536;
	               return d !== d || c ? b : d < 0 ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
	            },
	            ba = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	            ca = function(a, b) {
	               return b ? "\x00" === a ? "" : a.slice(0, -1) + "\\" + a.charCodeAt(a.length - 1).toString(16) + " " : "\\" + a
	            },
	            da = function() {
	               m()
	            },
	            ea = ta(function(a) {
	               return a.disabled === !0 && ("form" in a || "label" in a)
	            }, {
	               dir: "parentNode",
	               next: "legend"
	            });
	         try {
	            G.apply(D = H.call(v.childNodes), v.childNodes), D[v.childNodes.length].nodeType
	         } catch (fa) {
	            G = {
	               apply: D.length ?
	               function(a, b) {
	                  F.apply(a, H.call(b))
	               } : function(a, b) {
	                  var c = a.length,
	                     d = 0;
	                  while (a[c++] = b[d++]);
	                  a.length = c - 1
	               }
	            }
	         }
	         function ga(a, b, d, e) {
	            var f, h, j, k, l, o, r, s = b && b.ownerDocument,
	               w = b ? b.nodeType : 9;
	            if (d = d || [], "string" != typeof a || !a || 1 !== w && 9 !== w && 11 !== w) return d;
	            if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {
	               if (11 !== w && (l = Z.exec(a))) if (f = l[1]) {
	                  if (9 === w) {
	                     if (!(j = b.getElementById(f))) return d;
	                     if (j.id === f) return d.push(j), d
	                  } else if (s && (j = s.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d
	               } else {
	                  if (l[2]) return G.apply(d, b.getElementsByTagName(a)), d;
	                  if ((f = l[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(f)), d
	               }
	               if (c.qsa && !A[a + " "] && (!q || !q.test(a))) {
	                  if (1 !== w) s = b, r = a;
	                  else if ("object" !== b.nodeName.toLowerCase()) {
	                     (k = b.getAttribute("id")) ? k = k.replace(ba, ca) : b.setAttribute("id", k = u), o = g(a), h = o.length;
	                     while (h--) o[h] = "#" + k + " " + sa(o[h]);
	                     r = o.join(","), s = $.test(a) && qa(b.parentNode) || b
	                  }
	                  if (r) try {
	                     return G.apply(d, s.querySelectorAll(r)), d
	                  } catch (x) {} finally {
	                     k === u && b.removeAttribute("id")
	                  }
	               }
	            }
	            return i(a.replace(P, "$1"), b, d, e)
	         }
	         function ha() {
	            var a = [];

	            function b(c, e) {
	               return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
	            }
	            return b
	         }
	         function ia(a) {
	            return a[u] = !0, a
	         }
	         function ja(a) {
	            var b = n.createElement("fieldset");
	            try {
	               return !!a(b)
	            } catch (c) {
	               return !1
	            } finally {
	               b.parentNode && b.parentNode.removeChild(b), b = null
	            }
	         }
	         function ka(a, b) {
	            var c = a.split("|"),
	               e = c.length;
	            while (e--) d.attrHandle[c[e]] = b
	         }
	         function la(a, b) {
	            var c = b && a,
	               d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
	            if (d) return d;
	            if (c) while (c = c.nextSibling) if (c === b) return -1;
	            return a ? 1 : -1
	         }
	         function ma(a) {
	            return function(b) {
	               var c = b.nodeName.toLowerCase();
	               return "input" === c && b.type === a
	            }
	         }
	         function na(a) {
	            return function(b) {
	               var c = b.nodeName.toLowerCase();
	               return ("input" === c || "button" === c) && b.type === a
	            }
	         }
	         function oa(a) {
	            return function(b) {
	               return "form" in b ? b.parentNode && b.disabled === !1 ? "label" in b ? "label" in b.parentNode ? b.parentNode.disabled === a : b.disabled === a : b.isDisabled === a || b.isDisabled !== !a && ea(b) === a : b.disabled === a : "label" in b && b.disabled === a
	            }
	         }
	         function pa(a) {
	            return ia(function(b) {
	               return b = +b, ia(function(c, d) {
	                  var e, f = a([], c.length, b),
	                     g = f.length;
	                  while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
	               })
	            })
	         }
	         function qa(a) {
	            return a && "undefined" != typeof a.getElementsByTagName && a
	         }
	         c = ga.support = {}, f = ga.isXML = function(a) {
	            var b = a && (a.ownerDocument || a).documentElement;
	            return !!b && "HTML" !== b.nodeName
	         }, m = ga.setDocument = function(a) {
	            var b, e, g = a ? a.ownerDocument || a : v;
	            return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), v !== n && (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ja(function(a) {
	               return a.className = "i", !a.getAttribute("className")
	            }), c.getElementsByTagName = ja(function(a) {
	               return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length
	            }), c.getElementsByClassName = Y.test(n.getElementsByClassName), c.getById = ja(function(a) {
	               return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length
	            }), c.getById ? (d.filter.ID = function(a) {
	               var b = a.replace(_, aa);
	               return function(a) {
	                  return a.getAttribute("id") === b
	               }
	            }, d.find.ID = function(a, b) {
	               if ("undefined" != typeof b.getElementById && p) {
	                  var c = b.getElementById(a);
	                  return c ? [c] : []
	               }
	            }) : (d.filter.ID = function(a) {
	               var b = a.replace(_, aa);
	               return function(a) {
	                  var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
	                  return c && c.value === b
	               }
	            }, d.find.ID = function(a, b) {
	               if ("undefined" != typeof b.getElementById && p) {
	                  var c, d, e, f = b.getElementById(a);
	                  if (f) {
	                     if (c = f.getAttributeNode("id"), c && c.value === a) return [f];
	                     e = b.getElementsByName(a), d = 0;
	                     while (f = e[d++]) if (c = f.getAttributeNode("id"), c && c.value === a) return [f]
	                  }
	                  return []
	               }
	            }), d.find.TAG = c.getElementsByTagName ?
	            function(a, b) {
	               return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
	            } : function(a, b) {
	               var c, d = [],
	                  e = 0,
	                  f = b.getElementsByTagName(a);
	               if ("*" === a) {
	                  while (c = f[e++]) 1 === c.nodeType && d.push(c);
	                  return d
	               }
	               return f
	            }, d.find.CLASS = c.getElementsByClassName &&
	            function(a, b) {
	               if ("undefined" != typeof b.getElementsByClassName && p) return b.getElementsByClassName(a)
	            }, r = [], q = [], (c.qsa = Y.test(n.querySelectorAll)) && (ja(function(a) {
	               o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + K + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + K + "*(?:value|" + J + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
	            }), ja(function(a) {
	               a.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
	               var b = n.createElement("input");
	               b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + K + "*[*^$|!~]?="), 2 !== a.querySelectorAll(":enabled").length && q.push(":enabled", ":disabled"), o.appendChild(a).disabled = !0, 2 !== a.querySelectorAll(":disabled").length && q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
	            })), (c.matchesSelector = Y.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
	               c.disconnectedMatch = s.call(a, "*"), s.call(a, "[s!='']:x"), r.push("!=", N)
	            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Y.test(o.compareDocumentPosition), t = b || Y.test(o.contains) ?
	            function(a, b) {
	               var c = 9 === a.nodeType ? a.documentElement : a,
	                  d = b && b.parentNode;
	               return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
	            } : function(a, b) {
	               if (b) while (b = b.parentNode) if (b === a) return !0;
	               return !1
	            }, B = b ?
	            function(a, b) {
	               if (a === b) return l = !0, 0;
	               var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
	               return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? I(k, a) - I(k, b) : 0 : 4 & d ? -1 : 1)
	            } : function(a, b) {
	               if (a === b) return l = !0, 0;
	               var c, d = 0,
	                  e = a.parentNode,
	                  f = b.parentNode,
	                  g = [a],
	                  h = [b];
	               if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? I(k, a) - I(k, b) : 0;
	               if (e === f) return la(a, b);
	               c = a;
	               while (c = c.parentNode) g.unshift(c);
	               c = b;
	               while (c = c.parentNode) h.unshift(c);
	               while (g[d] === h[d]) d++;
	               return d ? la(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0
	            }, n) : n
	         }, ga.matches = function(a, b) {
	            return ga(a, null, null, b)
	         }, ga.matchesSelector = function(a, b) {
	            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(S, "='$1']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try {
	               var d = s.call(a, b);
	               if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
	            } catch (e) {}
	            return ga(b, n, null, [a]).length > 0
	         }, ga.contains = function(a, b) {
	            return (a.ownerDocument || a) !== n && m(a), t(a, b)
	         }, ga.attr = function(a, b) {
	            (a.ownerDocument || a) !== n && m(a);
	            var e = d.attrHandle[b.toLowerCase()],
	               f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
	            return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
	         }, ga.escape = function(a) {
	            return (a + "").replace(ba, ca)
	         }, ga.error = function(a) {
	            throw new Error("Syntax error, unrecognized expression: " + a)
	         }, ga.uniqueSort = function(a) {
	            var b, d = [],
	               e = 0,
	               f = 0;
	            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
	               while (b = a[f++]) b === a[f] && (e = d.push(f));
	               while (e--) a.splice(d[e], 1)
	            }
	            return k = null, a
	         }, e = ga.getText = function(a) {
	            var b, c = "",
	               d = 0,
	               f = a.nodeType;
	            if (f) {
	               if (1 === f || 9 === f || 11 === f) {
	                  if ("string" == typeof a.textContent) return a.textContent;
	                  for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
	               } else if (3 === f || 4 === f) return a.nodeValue
	            } else while (b = a[d++]) c += e(b);
	            return c
	         }, d = ga.selectors = {
	            cacheLength: 50,
	            createPseudo: ia,
	            match: V,
	            attrHandle: {},
	            find: {},
	            relative: {
	               ">": {
	                  dir: "parentNode",
	                  first: !0
	               },
	               " ": {
	                  dir: "parentNode"
	               },
	               "+": {
	                  dir: "previousSibling",
	                  first: !0
	               },
	               "~": {
	                  dir: "previousSibling"
	               }
	            },
	            preFilter: {
	               ATTR: function(a) {
	                  return a[1] = a[1].replace(_, aa), a[3] = (a[3] || a[4] || a[5] || "").replace(_, aa), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
	               },
	               CHILD: function(a) {
	                  return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), a
	               },
	               PSEUDO: function(a) {
	                  var b, c = !a[6] && a[2];
	                  return V.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && T.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
	               }
	            },
	            filter: {
	               TAG: function(a) {
	                  var b = a.replace(_, aa).toLowerCase();
	                  return "*" === a ?
	                  function() {
	                     return !0
	                  } : function(a) {
	                     return a.nodeName && a.nodeName.toLowerCase() === b
	                  }
	               },
	               CLASS: function(a) {
	                  var b = y[a + " "];
	                  return b || (b = new RegExp("(^|" + K + ")" + a + "(" + K + "|$)")) && y(a, function(a) {
	                     return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
	                  })
	               },
	               ATTR: function(a, b, c) {
	                  return function(d) {
	                     var e = ga.attr(d, a);
	                     return null == e ? "!=" === b : !b || (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(O, " ") + " ").indexOf(c) > -1 : "|=" === b && (e === c || e.slice(0, c.length + 1) === c + "-"))
	                  }
	               },
	               CHILD: function(a, b, c, d, e) {
	                  var f = "nth" !== a.slice(0, 3),
	                     g = "last" !== a.slice(-4),
	                     h = "of-type" === b;
	                  return 1 === d && 0 === e ?
	                  function(a) {
	                     return !!a.parentNode
	                  } : function(b, c, i) {
	                     var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
	                        q = b.parentNode,
	                        r = h && b.nodeName.toLowerCase(),
	                        s = !i && !h,
	                        t = !1;
	                     if (q) {
	                        if (f) {
	                           while (p) {
	                              m = b;
	                              while (m = m[p]) if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;
	                              o = p = "only" === a && !o && "nextSibling"
	                           }
	                           return !0
	                        }
	                        if (o = [g ? q.firstChild : q.lastChild], g && s) {
	                           m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];
	                           while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) if (1 === m.nodeType && ++t && m === b) {
	                              k[a] = [w, n, t];
	                              break
	                           }
	                        } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;
	                        return t -= e, t === d || t % d === 0 && t / d >= 0
	                     }
	                  }
	               },
	               PSEUDO: function(a, b) {
	                  var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
	                  return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
	                     var d, f = e(a, b),
	                        g = f.length;
	                     while (g--) d = I(a, f[g]), a[d] = !(c[d] = f[g])
	                  }) : function(a) {
	                     return e(a, 0, c)
	                  }) : e
	               }
	            },
	            pseudos: {
	               not: ia(function(a) {
	                  var b = [],
	                     c = [],
	                     d = h(a.replace(P, "$1"));
	                  return d[u] ? ia(function(a, b, c, e) {
	                     var f, g = d(a, null, e, []),
	                        h = a.length;
	                     while (h--)(f = g[h]) && (a[h] = !(b[h] = f))
	                  }) : function(a, e, f) {
	                     return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
	                  }
	               }),
	               has: ia(function(a) {
	                  return function(b) {
	                     return ga(a, b).length > 0
	                  }
	               }),
	               contains: ia(function(a) {
	                  return a = a.replace(_, aa), function(b) {
	                     return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
	                  }
	               }),
	               lang: ia(function(a) {
	                  return U.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(_, aa).toLowerCase(), function(b) {
	                     var c;
	                     do
	                     if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-");
	                     while ((b = b.parentNode) && 1 === b.nodeType);
	                     return !1
	                  }
	               }),
	               target: function(b) {
	                  var c = a.location && a.location.hash;
	                  return c && c.slice(1) === b.id
	               },
	               root: function(a) {
	                  return a === o
	               },
	               focus: function(a) {
	                  return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !! (a.type || a.href || ~a.tabIndex)
	               },
	               enabled: oa(!1),
	               disabled: oa(!0),
	               checked: function(a) {
	                  var b = a.nodeName.toLowerCase();
	                  return "input" === b && !! a.checked || "option" === b && !! a.selected
	               },
	               selected: function(a) {
	                  return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
	               },
	               empty: function(a) {
	                  for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
	                  return !0
	               },
	               parent: function(a) {
	                  return !d.pseudos.empty(a)
	               },
	               header: function(a) {
	                  return X.test(a.nodeName)
	               },
	               input: function(a) {
	                  return W.test(a.nodeName)
	               },
	               button: function(a) {
	                  var b = a.nodeName.toLowerCase();
	                  return "input" === b && "button" === a.type || "button" === b
	               },
	               text: function(a) {
	                  var b;
	                  return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
	               },
	               first: pa(function() {
	                  return [0]
	               }),
	               last: pa(function(a, b) {
	                  return [b - 1]
	               }),
	               eq: pa(function(a, b, c) {
	                  return [c < 0 ? c + b : c]
	               }),
	               even: pa(function(a, b) {
	                  for (var c = 0; c < b; c += 2) a.push(c);
	                  return a
	               }),
	               odd: pa(function(a, b) {
	                  for (var c = 1; c < b; c += 2) a.push(c);
	                  return a
	               }),
	               lt: pa(function(a, b, c) {
	                  for (var d = c < 0 ? c + b : c; --d >= 0;) a.push(d);
	                  return a
	               }),
	               gt: pa(function(a, b, c) {
	                  for (var d = c < 0 ? c + b : c; ++d < b;) a.push(d);
	                  return a
	               })
	            }
	         }, d.pseudos.nth = d.pseudos.eq;
	         for (b in {
	            radio: !0,
	            checkbox: !0,
	            file: !0,
	            password: !0,
	            image: !0
	         }) d.pseudos[b] = ma(b);
	         for (b in {
	            submit: !0,
	            reset: !0
	         }) d.pseudos[b] = na(b);

	         function ra() {}
	         ra.prototype = d.filters = d.pseudos, d.setFilters = new ra, g = ga.tokenize = function(a, b) {
	            var c, e, f, g, h, i, j, k = z[a + " "];
	            if (k) return b ? 0 : k.slice(0);
	            h = a, i = [], j = d.preFilter;
	            while (h) {
	               c && !(e = Q.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({
	                  value: c,
	                  type: e[0].replace(P, " ")
	               }), h = h.slice(c.length));
	               for (g in d.filter)!(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
	                  value: c,
	                  type: g,
	                  matches: e
	               }), h = h.slice(c.length));
	               if (!c) break
	            }
	            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0)
	         };

	         function sa(a) {
	            for (var b = 0, c = a.length, d = ""; b < c; b++) d += a[b].value;
	            return d
	         }
	         function ta(a, b, c) {
	            var d = b.dir,
	               e = b.next,
	               f = e || d,
	               g = c && "parentNode" === f,
	               h = x++;
	            return b.first ?
	            function(b, c, e) {
	               while (b = b[d]) if (1 === b.nodeType || g) return a(b, c, e);
	               return !1
	            } : function(b, c, i) {
	               var j, k, l, m = [w, h];
	               if (i) {
	                  while (b = b[d]) if ((1 === b.nodeType || g) && a(b, c, i)) return !0
	               } else while (b = b[d]) if (1 === b.nodeType || g) if (l = b[u] || (b[u] = {}), k = l[b.uniqueID] || (l[b.uniqueID] = {}), e && e === b.nodeName.toLowerCase()) b = b[d] || b;
	               else {
	                  if ((j = k[f]) && j[0] === w && j[1] === h) return m[2] = j[2];
	                  if (k[f] = m, m[2] = a(b, c, i)) return !0
	               }
	               return !1
	            }
	         }
	         function ua(a) {
	            return a.length > 1 ?
	            function(b, c, d) {
	               var e = a.length;
	               while (e--) if (!a[e](b, c, d)) return !1;
	               return !0
	            } : a[0]
	         }
	         function va(a, b, c) {
	            for (var d = 0, e = b.length; d < e; d++) ga(a, b[d], c);
	            return c
	         }
	         function wa(a, b, c, d, e) {
	            for (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
	            return g
	         }
	         function xa(a, b, c, d, e, f) {
	            return d && !d[u] && (d = xa(d)), e && !e[u] && (e = xa(e, f)), ia(function(f, g, h, i) {
	               var j, k, l, m = [],
	                  n = [],
	                  o = g.length,
	                  p = f || va(b || "*", h.nodeType ? [h] : h, []),
	                  q = !a || !f && b ? p : wa(p, m, a, h, i),
	                  r = c ? e || (f ? a : o || d) ? [] : g : q;
	               if (c && c(q, r, h, i), d) {
	                  j = wa(r, n), d(j, [], h, i), k = j.length;
	                  while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
	               }
	               if (f) {
	                  if (e || a) {
	                     if (e) {
	                        j = [], k = r.length;
	                        while (k--)(l = r[k]) && j.push(q[k] = l);
	                        e(null, r = [], j, i)
	                     }
	                     k = r.length;
	                     while (k--)(l = r[k]) && (j = e ? I(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
	                  }
	               } else r = wa(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)
	            })
	         }
	         function ya(a) {
	            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ta(function(a) {
	               return a === b
	            }, h, !0), l = ta(function(a) {
	               return I(b, a) > -1
	            }, h, !0), m = [function(a, c, d) {
	               var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
	               return b = null, e
	            }]; i < f; i++) if (c = d.relative[a[i].type]) m = [ta(ua(m), c)];
	            else {
	               if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
	                  for (e = ++i; e < f; e++) if (d.relative[a[e].type]) break;
	                  return xa(i > 1 && ua(m), i > 1 && sa(a.slice(0, i - 1).concat({
	                     value: " " === a[i - 2].type ? "*" : ""
	                  })).replace(P, "$1"), c, i < e && ya(a.slice(i, e)), e < f && ya(a = a.slice(e)), e < f && sa(a))
	               }
	               m.push(c)
	            }
	            return ua(m)
	         }
	         function za(a, b) {
	            var c = b.length > 0,
	               e = a.length > 0,
	               f = function(f, g, h, i, k) {
	                  var l, o, q, r = 0,
	                     s = "0",
	                     t = f && [],
	                     u = [],
	                     v = j,
	                     x = f || e && d.find.TAG("*", k),
	                     y = w += null == v ? 1 : Math.random() || .1,
	                     z = x.length;
	                  for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {
	                     if (e && l) {
	                        o = 0, g || l.ownerDocument === n || (m(l), h = !p);
	                        while (q = a[o++]) if (q(l, g || n, h)) {
	                           i.push(l);
	                           break
	                        }
	                        k && (w = y)
	                     }
	                     c && ((l = !q && l) && r--, f && t.push(l))
	                  }
	                  if (r += s, c && s !== r) {
	                     o = 0;
	                     while (q = b[o++]) q(t, u, g, h);
	                     if (f) {
	                        if (r > 0) while (s--) t[s] || u[s] || (u[s] = E.call(i));
	                        u = wa(u)
	                     }
	                     G.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && ga.uniqueSort(i)
	                  }
	                  return k && (w = y, j = v), t
	               };
	            return c ? ia(f) : f
	         }
	         return h = ga.compile = function(a, b) {
	            var c, d = [],
	               e = [],
	               f = A[a + " "];
	            if (!f) {
	               b || (b = g(a)), c = b.length;
	               while (c--) f = ya(b[c]), f[u] ? d.push(f) : e.push(f);
	               f = A(a, za(e, d)), f.selector = a
	            }
	            return f
	         }, i = ga.select = function(a, b, c, e) {
	            var f, i, j, k, l, m = "function" == typeof a && a,
	               n = !e && g(a = m.selector || a);
	            if (c = c || [], 1 === n.length) {
	               if (i = n[0] = n[0].slice(0), i.length > 2 && "ID" === (j = i[0]).type && 9 === b.nodeType && p && d.relative[i[1].type]) {
	                  if (b = (d.find.ID(j.matches[0].replace(_, aa), b) || [])[0], !b) return c;
	                  m && (b = b.parentNode), a = a.slice(i.shift().value.length)
	               }
	               f = V.needsContext.test(a) ? 0 : i.length;
	               while (f--) {
	                  if (j = i[f], d.relative[k = j.type]) break;
	                  if ((l = d.find[k]) && (e = l(j.matches[0].replace(_, aa), $.test(i[0].type) && qa(b.parentNode) || b))) {
	                     if (i.splice(f, 1), a = e.length && sa(i), !a) return G.apply(c, e), c;
	                     break
	                  }
	               }
	            }
	            return (m || h(a, n))(e, b, !p, c, !b || $.test(a) && qa(b.parentNode) || b), c
	         }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !! l, m(), c.sortDetached = ja(function(a) {
	            return 1 & a.compareDocumentPosition(n.createElement("fieldset"))
	         }), ja(function(a) {
	            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
	         }) || ka("type|href|height|width", function(a, b, c) {
	            if (!c) return a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
	         }), c.attributes && ja(function(a) {
	            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
	         }) || ka("value", function(a, b, c) {
	            if (!c && "input" === a.nodeName.toLowerCase()) return a.defaultValue
	         }), ja(function(a) {
	            return null == a.getAttribute("disabled")
	         }) || ka(J, function(a, b, c) {
	            var d;
	            if (!c) return a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
	         }), ga
	      }(a);
	   r.find = x, r.expr = x.selectors, r.expr[":"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape;
	   var y = function(a, b, c) {
	         var d = [],
	            e = void 0 !== c;
	         while ((a = a[b]) && 9 !== a.nodeType) if (1 === a.nodeType) {
	            if (e && r(a).is(c)) break;
	            d.push(a)
	         }
	         return d
	      },
	      z = function(a, b) {
	         for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
	         return c
	      },
	      A = r.expr.match.needsContext;

	   function B(a, b) {
	      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
	   }
	   var C = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
	      D = /^.[^:#\[\.,]*$/;

	   function E(a, b, c) {
	      return r.isFunction(b) ? r.grep(a, function(a, d) {
	         return !!b.call(a, d, a) !== c
	      }) : b.nodeType ? r.grep(a, function(a) {
	         return a === b !== c
	      }) : "string" != typeof b ? r.grep(a, function(a) {
	         return i.call(b, a) > -1 !== c
	      }) : D.test(b) ? r.filter(b, a, c) : (b = r.filter(b, a), r.grep(a, function(a) {
	         return i.call(b, a) > -1 !== c && 1 === a.nodeType
	      }))
	   }
	   r.filter = function(a, b, c) {
	      var d = b[0];
	      return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? r.find.matchesSelector(d, a) ? [d] : [] : r.find.matches(a, r.grep(b, function(a) {
	         return 1 === a.nodeType
	      }))
	   }, r.fn.extend({
	      find: function(a) {
	         var b, c, d = this.length,
	            e = this;
	         if ("string" != typeof a) return this.pushStack(r(a).filter(function() {
	            for (b = 0; b < d; b++) if (r.contains(e[b], this)) return !0
	         }));
	         for (c = this.pushStack([]), b = 0; b < d; b++) r.find(a, e[b], c);
	         return d > 1 ? r.uniqueSort(c) : c
	      },
	      filter: function(a) {
	         return this.pushStack(E(this, a || [], !1))
	      },
	      not: function(a) {
	         return this.pushStack(E(this, a || [], !0))
	      },
	      is: function(a) {
	         return !!E(this, "string" == typeof a && A.test(a) ? r(a) : a || [], !1).length
	      }
	   });
	   var F, G = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	      H = r.fn.init = function(a, b, c) {
	         var e, f;
	         if (!a) return this;
	         if (c = c || F, "string" == typeof a) {
	            if (e = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : G.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
	            if (e[1]) {
	               if (b = b instanceof r ? b[0] : b, r.merge(this, r.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), C.test(e[1]) && r.isPlainObject(b)) for (e in b) r.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);
	               return this
	            }
	            return f = d.getElementById(e[2]), f && (this[0] = f, this.length = 1), this
	         }
	         return a.nodeType ? (this[0] = a, this.length = 1, this) : r.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(r) : r.makeArray(a, this)
	      };
	   H.prototype = r.fn, F = r(d);
	   var I = /^(?:parents|prev(?:Until|All))/,
	      J = {
	         children: !0,
	         contents: !0,
	         next: !0,
	         prev: !0
	      };
	   r.fn.extend({
	      has: function(a) {
	         var b = r(a, this),
	            c = b.length;
	         return this.filter(function() {
	            for (var a = 0; a < c; a++) if (r.contains(this, b[a])) return !0
	         })
	      },
	      closest: function(a, b) {
	         var c, d = 0,
	            e = this.length,
	            f = [],
	            g = "string" != typeof a && r(a);
	         if (!A.test(a)) for (; d < e; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && r.find.matchesSelector(c, a))) {
	            f.push(c);
	            break
	         }
	         return this.pushStack(f.length > 1 ? r.uniqueSort(f) : f)
	      },
	      index: function(a) {
	         return a ? "string" == typeof a ? i.call(r(a), this[0]) : i.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
	      },
	      add: function(a, b) {
	         return this.pushStack(r.uniqueSort(r.merge(this.get(), r(a, b))))
	      },
	      addBack: function(a) {
	         return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
	      }
	   });

	   function K(a, b) {
	      while ((a = a[b]) && 1 !== a.nodeType);
	      return a
	   }
	   r.each({
	      parent: function(a) {
	         var b = a.parentNode;
	         return b && 11 !== b.nodeType ? b : null
	      },
	      parents: function(a) {
	         return y(a, "parentNode")
	      },
	      parentsUntil: function(a, b, c) {
	         return y(a, "parentNode", c)
	      },
	      next: function(a) {
	         return K(a, "nextSibling")
	      },
	      prev: function(a) {
	         return K(a, "previousSibling")
	      },
	      nextAll: function(a) {
	         return y(a, "nextSibling")
	      },
	      prevAll: function(a) {
	         return y(a, "previousSibling")
	      },
	      nextUntil: function(a, b, c) {
	         return y(a, "nextSibling", c)
	      },
	      prevUntil: function(a, b, c) {
	         return y(a, "previousSibling", c)
	      },
	      siblings: function(a) {
	         return z((a.parentNode || {}).firstChild, a)
	      },
	      children: function(a) {
	         return z(a.firstChild)
	      },
	      contents: function(a) {
	         return B(a, "iframe") ? a.contentDocument : (B(a, "template") && (a = a.content || a), r.merge([], a.childNodes))
	      }
	   }, function(a, b) {
	      r.fn[a] = function(c, d) {
	         var e = r.map(this, b, c);
	         return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = r.filter(d, e)), this.length > 1 && (J[a] || r.uniqueSort(e), I.test(a) && e.reverse()), this.pushStack(e)
	      }
	   });
	   var L = /[^\x20\t\r\n\f]+/g;

	   function M(a) {
	      var b = {};
	      return r.each(a.match(L) || [], function(a, c) {
	         b[c] = !0
	      }), b
	   }
	   r.Callbacks = function(a) {
	      a = "string" == typeof a ? M(a) : r.extend({}, a);
	      var b, c, d, e, f = [],
	         g = [],
	         h = -1,
	         i = function() {
	            for (e = e || a.once, d = b = !0; g.length; h = -1) {
	               c = g.shift();
	               while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1)
	            }
	            a.memory || (c = !1), b = !1, e && (f = c ? [] : "")
	         },
	         j = {
	            add: function() {
	               return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {
	                  r.each(b, function(b, c) {
	                     r.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== r.type(c) && d(c)
	                  })
	               }(arguments), c && !b && i()), this
	            },
	            remove: function() {
	               return r.each(arguments, function(a, b) {
	                  var c;
	                  while ((c = r.inArray(b, f, c)) > -1) f.splice(c, 1), c <= h && h--
	               }), this
	            },
	            has: function(a) {
	               return a ? r.inArray(a, f) > -1 : f.length > 0
	            },
	            empty: function() {
	               return f && (f = []), this
	            },
	            disable: function() {
	               return e = g = [], f = c = "", this
	            },
	            disabled: function() {
	               return !f
	            },
	            lock: function() {
	               return e = g = [], c || b || (f = c = ""), this
	            },
	            locked: function() {
	               return !!e
	            },
	            fireWith: function(a, c) {
	               return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this
	            },
	            fire: function() {
	               return j.fireWith(this, arguments), this
	            },
	            fired: function() {
	               return !!d
	            }
	         };
	      return j
	   };

	   function N(a) {
	      return a
	   }
	   function O(a) {
	      throw a
	   }
	   function P(a, b, c, d) {
	      var e;
	      try {
	         a && r.isFunction(e = a.promise) ? e.call(a).done(b).fail(c) : a && r.isFunction(e = a.then) ? e.call(a, b, c) : b.apply(void 0, [a].slice(d))
	      } catch (a) {
	         c.apply(void 0, [a])
	      }
	   }
	   r.extend({
	      Deferred: function(b) {
	         var c = [
	            ["notify", "progress", r.Callbacks("memory"), r.Callbacks("memory"), 2],
	            ["resolve", "done", r.Callbacks("once memory"), r.Callbacks("once memory"), 0, "resolved"],
	            ["reject", "fail", r.Callbacks("once memory"), r.Callbacks("once memory"), 1, "rejected"]
	         ],
	            d = "pending",
	            e = {
	               state: function() {
	                  return d
	               },
	               always: function() {
	                  return f.done(arguments).fail(arguments), this
	               },
	               "catch": function(a) {
	                  return e.then(null, a)
	               },
	               pipe: function() {
	                  var a = arguments;
	                  return r.Deferred(function(b) {
	                     r.each(c, function(c, d) {
	                        var e = r.isFunction(a[d[4]]) && a[d[4]];
	                        f[d[1]](function() {
	                           var a = e && e.apply(this, arguments);
	                           a && r.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + "With"](this, e ? [a] : arguments)
	                        })
	                     }), a = null
	                  }).promise()
	               },
	               then: function(b, d, e) {
	                  var f = 0;

	                  function g(b, c, d, e) {
	                     return function() {
	                        var h = this,
	                           i = arguments,
	                           j = function() {
	                              var a, j;
	                              if (!(b < f)) {
	                                 if (a = d.apply(h, i), a === c.promise()) throw new TypeError("Thenable self-resolution");
	                                 j = a && ("object" == typeof a || "function" == typeof a) && a.then, r.isFunction(j) ? e ? j.call(a, g(f, c, N, e), g(f, c, O, e)) : (f++, j.call(a, g(f, c, N, e), g(f, c, O, e), g(f, c, N, c.notifyWith))) : (d !== N && (h = void 0, i = [a]), (e || c.resolveWith)(h, i))
	                              }
	                           },
	                           k = e ? j : function() {
	                              try {
	                                 j()
	                              } catch (a) {
	                                 r.Deferred.exceptionHook && r.Deferred.exceptionHook(a, k.stackTrace), b + 1 >= f && (d !== O && (h = void 0, i = [a]), c.rejectWith(h, i))
	                              }
	                           };
	                        b ? k() : (r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook()), a.setTimeout(k))
	                     }
	                  }
	                  return r.Deferred(function(a) {
	                     c[0][3].add(g(0, a, r.isFunction(e) ? e : N, a.notifyWith)), c[1][3].add(g(0, a, r.isFunction(b) ? b : N)), c[2][3].add(g(0, a, r.isFunction(d) ? d : O))
	                  }).promise()
	               },
	               promise: function(a) {
	                  return null != a ? r.extend(a, e) : e
	               }
	            },
	            f = {};
	         return r.each(c, function(a, b) {
	            var g = b[2],
	               h = b[5];
	            e[b[1]] = g.add, h && g.add(function() {
	               d = h
	            }, c[3 - a][2].disable, c[0][2].lock), g.add(b[3].fire), f[b[0]] = function() {
	               return f[b[0] + "With"](this === f ? void 0 : this, arguments), this
	            }, f[b[0] + "With"] = g.fireWith
	         }), e.promise(f), b && b.call(f, f), f
	      },
	      when: function(a) {
	         var b = arguments.length,
	            c = b,
	            d = Array(c),
	            e = f.call(arguments),
	            g = r.Deferred(),
	            h = function(a) {
	               return function(c) {
	                  d[a] = this, e[a] = arguments.length > 1 ? f.call(arguments) : c, --b || g.resolveWith(d, e)
	               }
	            };
	         if (b <= 1 && (P(a, g.done(h(c)).resolve, g.reject, !b), "pending" === g.state() || r.isFunction(e[c] && e[c].then))) return g.then();
	         while (c--) P(e[c], h(c), g.reject);
	         return g.promise()
	      }
	   });
	   var Q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	   r.Deferred.exceptionHook = function(b, c) {
	      a.console && a.console.warn && b && Q.test(b.name) && a.console.warn("jQuery.Deferred exception: " + b.message, b.stack, c)
	   }, r.readyException = function(b) {
	      a.setTimeout(function() {
	         throw b
	      })
	   };
	   var R = r.Deferred();
	   r.fn.ready = function(a) {
	      return R.then(a)["catch"](function(a) {
	         r.readyException(a)
	      }), this
	   }, r.extend({
	      isReady: !1,
	      readyWait: 1,
	      ready: function(a) {
	         (a === !0 ? --r.readyWait : r.isReady) || (r.isReady = !0, a !== !0 && --r.readyWait > 0 || R.resolveWith(d, [r]))
	      }
	   }), r.ready.then = R.then;

	   function S() {
	      d.removeEventListener("DOMContentLoaded", S), a.removeEventListener("load", S), r.ready()
	   }
	   "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(r.ready) : (d.addEventListener("DOMContentLoaded", S), a.addEventListener("load", S));
	   var T = function(a, b, c, d, e, f, g) {
	         var h = 0,
	            i = a.length,
	            j = null == c;
	         if ("object" === r.type(c)) {
	            e = !0;
	            for (h in c) T(a, b, h, c[h], !0, f, g)
	         } else if (void 0 !== d && (e = !0, r.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
	            return j.call(r(a), c)
	         })), b)) for (; h < i; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
	         return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
	      },
	      U = function(a) {
	         return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
	      };

	   function V() {
	      this.expando = r.expando + V.uid++
	   }
	   V.uid = 1, V.prototype = {
	      cache: function(a) {
	         var b = a[this.expando];
	         return b || (b = {}, U(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
	            value: b,
	            configurable: !0
	         }))), b
	      },
	      set: function(a, b, c) {
	         var d, e = this.cache(a);
	         if ("string" == typeof b) e[r.camelCase(b)] = c;
	         else for (d in b) e[r.camelCase(d)] = b[d];
	         return e
	      },
	      get: function(a, b) {
	         return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][r.camelCase(b)]
	      },
	      access: function(a, b, c) {
	         return void 0 === b || b && "string" == typeof b && void 0 === c ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b)
	      },
	      remove: function(a, b) {
	         var c, d = a[this.expando];
	         if (void 0 !== d) {
	            if (void 0 !== b) {
	               Array.isArray(b) ? b = b.map(r.camelCase) : (b = r.camelCase(b), b = b in d ? [b] : b.match(L) || []), c = b.length;
	               while (c--) delete d[b[c]]
	            }(void 0 === b || r.isEmptyObject(d)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
	         }
	      },
	      hasData: function(a) {
	         var b = a[this.expando];
	         return void 0 !== b && !r.isEmptyObject(b)
	      }
	   };
	   var W = new V,
	      X = new V,
	      Y = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	      Z = /[A-Z]/g;

	   function $(a) {
	      return "true" === a || "false" !== a && ("null" === a ? null : a === +a + "" ? +a : Y.test(a) ? JSON.parse(a) : a)
	   }
	   function _(a, b, c) {
	      var d;
	      if (void 0 === c && 1 === a.nodeType) if (d = "data-" + b.replace(Z, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
	         try {
	            c = $(c)
	         } catch (e) {}
	         X.set(a, b, c)
	      } else c = void 0;
	      return c
	   }
	   r.extend({
	      hasData: function(a) {
	         return X.hasData(a) || W.hasData(a)
	      },
	      data: function(a, b, c) {
	         return X.access(a, b, c)
	      },
	      removeData: function(a, b) {
	         X.remove(a, b)
	      },
	      _data: function(a, b, c) {
	         return W.access(a, b, c)
	      },
	      _removeData: function(a, b) {
	         W.remove(a, b)
	      }
	   }), r.fn.extend({
	      data: function(a, b) {
	         var c, d, e, f = this[0],
	            g = f && f.attributes;
	         if (void 0 === a) {
	            if (this.length && (e = X.get(f), 1 === f.nodeType && !W.get(f, "hasDataAttrs"))) {
	               c = g.length;
	               while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = r.camelCase(d.slice(5)), _(f, d, e[d])));
	               W.set(f, "hasDataAttrs", !0)
	            }
	            return e
	         }
	         return "object" == typeof a ? this.each(function() {
	            X.set(this, a)
	         }) : T(this, function(b) {
	            var c;
	            if (f && void 0 === b) {
	               if (c = X.get(f, a), void 0 !== c) return c;
	               if (c = _(f, a), void 0 !== c) return c
	            } else this.each(function() {
	               X.set(this, a, b)
	            })
	         }, null, b, arguments.length > 1, null, !0)
	      },
	      removeData: function(a) {
	         return this.each(function() {
	            X.remove(this, a)
	         })
	      }
	   }), r.extend({
	      queue: function(a, b, c) {
	         var d;
	         if (a) return b = (b || "fx") + "queue", d = W.get(a, b), c && (!d || Array.isArray(c) ? d = W.access(a, b, r.makeArray(c)) : d.push(c)), d || []
	      },
	      dequeue: function(a, b) {
	         b = b || "fx";
	         var c = r.queue(a, b),
	            d = c.length,
	            e = c.shift(),
	            f = r._queueHooks(a, b),
	            g = function() {
	               r.dequeue(a, b)
	            };
	         "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
	      },
	      _queueHooks: function(a, b) {
	         var c = b + "queueHooks";
	         return W.get(a, c) || W.access(a, c, {
	            empty: r.Callbacks("once memory").add(function() {
	               W.remove(a, [b + "queue", c])
	            })
	         })
	      }
	   }), r.fn.extend({
	      queue: function(a, b) {
	         var c = 2;
	         return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? r.queue(this[0], a) : void 0 === b ? this : this.each(function() {
	            var c = r.queue(this, a, b);
	            r._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && r.dequeue(this, a)
	         })
	      },
	      dequeue: function(a) {
	         return this.each(function() {
	            r.dequeue(this, a)
	         })
	      },
	      clearQueue: function(a) {
	         return this.queue(a || "fx", [])
	      },
	      promise: function(a, b) {
	         var c, d = 1,
	            e = r.Deferred(),
	            f = this,
	            g = this.length,
	            h = function() {
	               --d || e.resolveWith(f, [f])
	            };
	         "string" != typeof a && (b = a, a = void 0), a = a || "fx";
	         while (g--) c = W.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
	         return h(), e.promise(b)
	      }
	   });
	   var aa = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
	      ba = new RegExp("^(?:([+-])=|)(" + aa + ")([a-z%]*)$", "i"),
	      ca = ["Top", "Right", "Bottom", "Left"],
	      da = function(a, b) {
	         return a = b || a, "none" === a.style.display || "" === a.style.display && r.contains(a.ownerDocument, a) && "none" === r.css(a, "display")
	      },
	      ea = function(a, b, c, d) {
	         var e, f, g = {};
	         for (f in b) g[f] = a.style[f], a.style[f] = b[f];
	         e = c.apply(a, d || []);
	         for (f in b) a.style[f] = g[f];
	         return e
	      };

	   function fa(a, b, c, d) {
	      var e, f = 1,
	         g = 20,
	         h = d ?
	      function() {
	         return d.cur()
	      } : function() {
	         return r.css(a, b, "")
	      }, i = h(), j = c && c[3] || (r.cssNumber[b] ? "" : "px"), k = (r.cssNumber[b] || "px" !== j && +i) && ba.exec(r.css(a, b));
	      if (k && k[3] !== j) {
	         j = j || k[3], c = c || [], k = +i || 1;
	         do f = f || ".5", k /= f, r.style(a, b, k + j);
	         while (f !== (f = h() / i) && 1 !== f && --g)
	      }
	      return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
	   }
	   var ga = {};

	   function ha(a) {
	      var b, c = a.ownerDocument,
	         d = a.nodeName,
	         e = ga[d];
	      return e ? e : (b = c.body.appendChild(c.createElement(d)), e = r.css(b, "display"), b.parentNode.removeChild(b), "none" === e && (e = "block"), ga[d] = e, e)
	   }
	   function ia(a, b) {
	      for (var c, d, e = [], f = 0, g = a.length; f < g; f++) d = a[f], d.style && (c = d.style.display, b ? ("none" === c && (e[f] = W.get(d, "display") || null, e[f] || (d.style.display = "")), "" === d.style.display && da(d) && (e[f] = ha(d))) : "none" !== c && (e[f] = "none", W.set(d, "display", c)));
	      for (f = 0; f < g; f++) null != e[f] && (a[f].style.display = e[f]);
	      return a
	   }
	   r.fn.extend({
	      show: function() {
	         return ia(this, !0)
	      },
	      hide: function() {
	         return ia(this)
	      },
	      toggle: function(a) {
	         return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
	            da(this) ? r(this).show() : r(this).hide()
	         })
	      }
	   });
	   var ja = /^(?:checkbox|radio)$/i,
	      ka = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
	      la = /^$|\/(?:java|ecma)script/i,
	      ma = {
	         option: [1, "<select multiple='multiple'>", "</select>"],
	         thead: [1, "<table>", "</table>"],
	         col: [2, "<table><colgroup>", "</colgroup></table>"],
	         tr: [2, "<table><tbody>", "</tbody></table>"],
	         td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	         _default: [0, "", ""]
	      };
	   ma.optgroup = ma.option, ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead, ma.th = ma.td;

	   function na(a, b) {
	      var c;
	      return c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [], void 0 === b || b && B(a, b) ? r.merge([a], c) : c
	   }
	   function oa(a, b) {
	      for (var c = 0, d = a.length; c < d; c++) W.set(a[c], "globalEval", !b || W.get(b[c], "globalEval"))
	   }
	   var pa = /<|&#?\w+;/;

	   function qa(a, b, c, d, e) {
	      for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; n < o; n++) if (f = a[n], f || 0 === f) if ("object" === r.type(f)) r.merge(m, f.nodeType ? [f] : f);
	      else if (pa.test(f)) {
	         g = g || l.appendChild(b.createElement("div")), h = (ka.exec(f) || ["", ""])[1].toLowerCase(), i = ma[h] || ma._default, g.innerHTML = i[1] + r.htmlPrefilter(f) + i[2], k = i[0];
	         while (k--) g = g.lastChild;
	         r.merge(m, g.childNodes), g = l.firstChild, g.textContent = ""
	      } else m.push(b.createTextNode(f));
	      l.textContent = "", n = 0;
	      while (f = m[n++]) if (d && r.inArray(f, d) > -1) e && e.push(f);
	      else if (j = r.contains(f.ownerDocument, f), g = na(l.appendChild(f), "script"), j && oa(g), c) {
	         k = 0;
	         while (f = g[k++]) la.test(f.type || "") && c.push(f)
	      }
	      return l
	   }!
	   function() {
	      var a = d.createDocumentFragment(),
	         b = a.appendChild(d.createElement("div")),
	         c = d.createElement("input");
	      c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), o.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", o.noCloneChecked = !! b.cloneNode(!0).lastChild.defaultValue
	   }();
	   var ra = d.documentElement,
	      sa = /^key/,
	      ta = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	      ua = /^([^.]*)(?:\.(.+)|)/;

	   function va() {
	      return !0
	   }
	   function wa() {
	      return !1
	   }
	   function xa() {
	      try {
	         return d.activeElement
	      } catch (a) {}
	   }
	   function ya(a, b, c, d, e, f) {
	      var g, h;
	      if ("object" == typeof b) {
	         "string" != typeof c && (d = d || c, c = void 0);
	         for (h in b) ya(a, h, c, d, b[h], f);
	         return a
	      }
	      if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = wa;
	      else if (!e) return a;
	      return 1 === f && (g = e, e = function(a) {
	         return r().off(a), g.apply(this, arguments)
	      }, e.guid = g.guid || (g.guid = r.guid++)), a.each(function() {
	         r.event.add(this, b, e, d, c)
	      })
	   }
	   r.event = {
	      global: {},
	      add: function(a, b, c, d, e) {
	         var f, g, h, i, j, k, l, m, n, o, p, q = W.get(a);
	         if (q) {
	            c.handler && (f = c, c = f.handler, e = f.selector), e && r.find.matchesSelector(ra, e), c.guid || (c.guid = r.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function(b) {
	               return "undefined" != typeof r && r.event.triggered !== b.type ? r.event.dispatch.apply(a, arguments) : void 0
	            }), b = (b || "").match(L) || [""], j = b.length;
	            while (j--) h = ua.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n && (l = r.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = r.event.special[n] || {}, k = r.extend({
	               type: n,
	               origType: p,
	               data: d,
	               handler: c,
	               guid: c.guid,
	               selector: e,
	               needsContext: e && r.expr.match.needsContext.test(e),
	               namespace: o.join(".")
	            }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== !1 || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), r.event.global[n] = !0)
	         }
	      },
	      remove: function(a, b, c, d, e) {
	         var f, g, h, i, j, k, l, m, n, o, p, q = W.hasData(a) && W.get(a);
	         if (q && (i = q.events)) {
	            b = (b || "").match(L) || [""], j = b.length;
	            while (j--) if (h = ua.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
	               l = r.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
	               while (f--) k = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
	               g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || r.removeEvent(a, n, q.handle), delete i[n])
	            } else for (n in i) r.event.remove(a, n + b[j], c, d, !0);
	            r.isEmptyObject(i) && W.remove(a, "handle events")
	         }
	      },
	      dispatch: function(a) {
	         var b = r.event.fix(a),
	            c, d, e, f, g, h, i = new Array(arguments.length),
	            j = (W.get(this, "events") || {})[b.type] || [],
	            k = r.event.special[b.type] || {};
	         for (i[0] = b, c = 1; c < arguments.length; c++) i[c] = arguments[c];
	         if (b.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, b) !== !1) {
	            h = r.event.handlers.call(this, b, j), c = 0;
	            while ((f = h[c++]) && !b.isPropagationStopped()) {
	               b.currentTarget = f.elem, d = 0;
	               while ((g = f.handlers[d++]) && !b.isImmediatePropagationStopped()) b.rnamespace && !b.rnamespace.test(g.namespace) || (b.handleObj = g, b.data = g.data, e = ((r.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (b.result = e) === !1 && (b.preventDefault(), b.stopPropagation()))
	            }
	            return k.postDispatch && k.postDispatch.call(this, b), b.result
	         }
	      },
	      handlers: function(a, b) {
	         var c, d, e, f, g, h = [],
	            i = b.delegateCount,
	            j = a.target;
	         if (i && j.nodeType && !("click" === a.type && a.button >= 1)) for (; j !== this; j = j.parentNode || this) if (1 === j.nodeType && ("click" !== a.type || j.disabled !== !0)) {
	            for (f = [], g = {}, c = 0; c < i; c++) d = b[c], e = d.selector + " ", void 0 === g[e] && (g[e] = d.needsContext ? r(e, this).index(j) > -1 : r.find(e, this, null, [j]).length), g[e] && f.push(d);
	            f.length && h.push({
	               elem: j,
	               handlers: f
	            })
	         }
	         return j = this, i < b.length && h.push({
	            elem: j,
	            handlers: b.slice(i)
	         }), h
	      },
	      addProp: function(a, b) {
	         Object.defineProperty(r.Event.prototype, a, {
	            enumerable: !0,
	            configurable: !0,
	            get: r.isFunction(b) ?
	            function() {
	               if (this.originalEvent) return b(this.originalEvent)
	            } : function() {
	               if (this.originalEvent) return this.originalEvent[a]
	            },
	            set: function(b) {
	               Object.defineProperty(this, a, {
	                  enumerable: !0,
	                  configurable: !0,
	                  writable: !0,
	                  value: b
	               })
	            }
	         })
	      },
	      fix: function(a) {
	         return a[r.expando] ? a : new r.Event(a)
	      },
	      special: {
	         load: {
	            noBubble: !0
	         },
	         focus: {
	            trigger: function() {
	               if (this !== xa() && this.focus) return this.focus(), !1
	            },
	            delegateType: "focusin"
	         },
	         blur: {
	            trigger: function() {
	               if (this === xa() && this.blur) return this.blur(), !1
	            },
	            delegateType: "focusout"
	         },
	         click: {
	            trigger: function() {
	               if ("checkbox" === this.type && this.click && B(this, "input")) return this.click(), !1
	            },
	            _default: function(a) {
	               return B(a.target, "a")
	            }
	         },
	         beforeunload: {
	            postDispatch: function(a) {
	               void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
	            }
	         }
	      }
	   }, r.removeEvent = function(a, b, c) {
	      a.removeEventListener && a.removeEventListener(b, c)
	   }, r.Event = function(a, b) {
	      return this instanceof r.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? va : wa, this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget) : this.type = a, b && r.extend(this, b), this.timeStamp = a && a.timeStamp || r.now(), void(this[r.expando] = !0)) : new r.Event(a, b)
	   }, r.Event.prototype = {
	      constructor: r.Event,
	      isDefaultPrevented: wa,
	      isPropagationStopped: wa,
	      isImmediatePropagationStopped: wa,
	      isSimulated: !1,
	      preventDefault: function() {
	         var a = this.originalEvent;
	         this.isDefaultPrevented = va, a && !this.isSimulated && a.preventDefault()
	      },
	      stopPropagation: function() {
	         var a = this.originalEvent;
	         this.isPropagationStopped = va, a && !this.isSimulated && a.stopPropagation()
	      },
	      stopImmediatePropagation: function() {
	         var a = this.originalEvent;
	         this.isImmediatePropagationStopped = va, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation()
	      }
	   }, r.each({
	      altKey: !0,
	      bubbles: !0,
	      cancelable: !0,
	      changedTouches: !0,
	      ctrlKey: !0,
	      detail: !0,
	      eventPhase: !0,
	      metaKey: !0,
	      pageX: !0,
	      pageY: !0,
	      shiftKey: !0,
	      view: !0,
	      "char": !0,
	      charCode: !0,
	      key: !0,
	      keyCode: !0,
	      button: !0,
	      buttons: !0,
	      clientX: !0,
	      clientY: !0,
	      offsetX: !0,
	      offsetY: !0,
	      pointerId: !0,
	      pointerType: !0,
	      screenX: !0,
	      screenY: !0,
	      targetTouches: !0,
	      toElement: !0,
	      touches: !0,
	      which: function(a) {
	         var b = a.button;
	         return null == a.which && sa.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && ta.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which
	      }
	   }, r.event.addProp), r.each({
	      mouseenter: "mouseover",
	      mouseleave: "mouseout",
	      pointerenter: "pointerover",
	      pointerleave: "pointerout"
	   }, function(a, b) {
	      r.event.special[a] = {
	         delegateType: b,
	         bindType: b,
	         handle: function(a) {
	            var c, d = this,
	               e = a.relatedTarget,
	               f = a.handleObj;
	            return e && (e === d || r.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
	         }
	      }
	   }), r.fn.extend({
	      on: function(a, b, c, d) {
	         return ya(this, a, b, c, d)
	      },
	      one: function(a, b, c, d) {
	         return ya(this, a, b, c, d, 1)
	      },
	      off: function(a, b, c) {
	         var d, e;
	         if (a && a.preventDefault && a.handleObj) return d = a.handleObj, r(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
	         if ("object" == typeof a) {
	            for (e in a) this.off(e, b, a[e]);
	            return this
	         }
	         return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = wa), this.each(function() {
	            r.event.remove(this, a, c, b)
	         })
	      }
	   });
	   var za = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	      Aa = /<script|<style|<link/i,
	      Ba = /checked\s*(?:[^=]|=\s*.checked.)/i,
	      Ca = /^true\/(.*)/,
	      Da = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	   function Ea(a, b) {
	      return B(a, "table") && B(11 !== b.nodeType ? b : b.firstChild, "tr") ? r(">tbody", a)[0] || a : a
	   }
	   function Fa(a) {
	      return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
	   }
	   function Ga(a) {
	      var b = Ca.exec(a.type);
	      return b ? a.type = b[1] : a.removeAttribute("type"), a
	   }
	   function Ha(a, b) {
	      var c, d, e, f, g, h, i, j;
	      if (1 === b.nodeType) {
	         if (W.hasData(a) && (f = W.access(a), g = W.set(b, f), j = f.events)) {
	            delete g.handle, g.events = {};
	            for (e in j) for (c = 0, d = j[e].length; c < d; c++) r.event.add(b, e, j[e][c])
	         }
	         X.hasData(a) && (h = X.access(a), i = r.extend({}, h), X.set(b, i))
	      }
	   }
	   function Ia(a, b) {
	      var c = b.nodeName.toLowerCase();
	      "input" === c && ja.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
	   }
	   function Ja(a, b, c, d) {
	      b = g.apply([], b);
	      var e, f, h, i, j, k, l = 0,
	         m = a.length,
	         n = m - 1,
	         q = b[0],
	         s = r.isFunction(q);
	      if (s || m > 1 && "string" == typeof q && !o.checkClone && Ba.test(q)) return a.each(function(e) {
	         var f = a.eq(e);
	         s && (b[0] = q.call(this, e, f.html())), Ja(f, b, c, d)
	      });
	      if (m && (e = qa(b, a[0].ownerDocument, !1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {
	         for (h = r.map(na(e, "script"), Fa), i = h.length; l < m; l++) j = e, l !== n && (j = r.clone(j, !0, !0), i && r.merge(h, na(j, "script"))), c.call(a[l], j, l);
	         if (i) for (k = h[h.length - 1].ownerDocument, r.map(h, Ga), l = 0; l < i; l++) j = h[l], la.test(j.type || "") && !W.access(j, "globalEval") && r.contains(k, j) && (j.src ? r._evalUrl && r._evalUrl(j.src) : p(j.textContent.replace(Da, ""), k))
	      }
	      return a
	   }
	   function Ka(a, b, c) {
	      for (var d, e = b ? r.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || r.cleanData(na(d)), d.parentNode && (c && r.contains(d.ownerDocument, d) && oa(na(d, "script")), d.parentNode.removeChild(d));
	      return a
	   }
	   r.extend({
	      htmlPrefilter: function(a) {
	         return a.replace(za, "<$1></$2>")
	      },
	      clone: function(a, b, c) {
	         var d, e, f, g, h = a.cloneNode(!0),
	            i = r.contains(a.ownerDocument, a);
	         if (!(o.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || r.isXMLDoc(a))) for (g = na(h), f = na(a), d = 0, e = f.length; d < e; d++) Ia(f[d], g[d]);
	         if (b) if (c) for (f = f || na(a), g = g || na(h), d = 0, e = f.length; d < e; d++) Ha(f[d], g[d]);
	         else Ha(a, h);
	         return g = na(h, "script"), g.length > 0 && oa(g, !i && na(a, "script")), h
	      },
	      cleanData: function(a) {
	         for (var b, c, d, e = r.event.special, f = 0; void 0 !== (c = a[f]); f++) if (U(c)) {
	            if (b = c[W.expando]) {
	               if (b.events) for (d in b.events) e[d] ? r.event.remove(c, d) : r.removeEvent(c, d, b.handle);
	               c[W.expando] = void 0
	            }
	            c[X.expando] && (c[X.expando] = void 0)
	         }
	      }
	   }), r.fn.extend({
	      detach: function(a) {
	         return Ka(this, a, !0)
	      },
	      remove: function(a) {
	         return Ka(this, a)
	      },
	      text: function(a) {
	         return T(this, function(a) {
	            return void 0 === a ? r.text(this) : this.empty().each(function() {
	               1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
	            })
	         }, null, a, arguments.length)
	      },
	      append: function() {
	         return Ja(this, arguments, function(a) {
	            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
	               var b = Ea(this, a);
	               b.appendChild(a)
	            }
	         })
	      },
	      prepend: function() {
	         return Ja(this, arguments, function(a) {
	            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
	               var b = Ea(this, a);
	               b.insertBefore(a, b.firstChild)
	            }
	         })
	      },
	      before: function() {
	         return Ja(this, arguments, function(a) {
	            this.parentNode && this.parentNode.insertBefore(a, this)
	         })
	      },
	      after: function() {
	         return Ja(this, arguments, function(a) {
	            this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
	         })
	      },
	      empty: function() {
	         for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (r.cleanData(na(a, !1)), a.textContent = "");
	         return this
	      },
	      clone: function(a, b) {
	         return a = null != a && a, b = null == b ? a : b, this.map(function() {
	            return r.clone(this, a, b)
	         })
	      },
	      html: function(a) {
	         return T(this, function(a) {
	            var b = this[0] || {},
	               c = 0,
	               d = this.length;
	            if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
	            if ("string" == typeof a && !Aa.test(a) && !ma[(ka.exec(a) || ["", ""])[1].toLowerCase()]) {
	               a = r.htmlPrefilter(a);
	               try {
	                  for (; c < d; c++) b = this[c] || {}, 1 === b.nodeType && (r.cleanData(na(b, !1)), b.innerHTML = a);
	                  b = 0
	               } catch (e) {}
	            }
	            b && this.empty().append(a)
	         }, null, a, arguments.length)
	      },
	      replaceWith: function() {
	         var a = [];
	         return Ja(this, arguments, function(b) {
	            var c = this.parentNode;
	            r.inArray(this, a) < 0 && (r.cleanData(na(this)), c && c.replaceChild(b, this))
	         }, a)
	      }
	   }), r.each({
	      appendTo: "append",
	      prependTo: "prepend",
	      insertBefore: "before",
	      insertAfter: "after",
	      replaceAll: "replaceWith"
	   }, function(a, b) {
	      r.fn[a] = function(a) {
	         for (var c, d = [], e = r(a), f = e.length - 1, g = 0; g <= f; g++) c = g === f ? this : this.clone(!0), r(e[g])[b](c), h.apply(d, c.get());
	         return this.pushStack(d)
	      }
	   });
	   var La = /^margin/,
	      Ma = new RegExp("^(" + aa + ")(?!px)[a-z%]+$", "i"),
	      Na = function(b) {
	         var c = b.ownerDocument.defaultView;
	         return c && c.opener || (c = a), c.getComputedStyle(b)
	      };
	   !
	   function() {
	      function b() {
	         if (i) {
	            i.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", i.innerHTML = "", ra.appendChild(h);
	            var b = a.getComputedStyle(i);
	            c = "1%" !== b.top, g = "2px" === b.marginLeft, e = "4px" === b.width, i.style.marginRight = "50%", f = "4px" === b.marginRight, ra.removeChild(h), i = null
	         }
	      }
	      var c, e, f, g, h = d.createElement("div"),
	         i = d.createElement("div");
	      i.style && (i.style.backgroundClip = "content-box", i.cloneNode(!0).style.backgroundClip = "", o.clearCloneStyle = "content-box" === i.style.backgroundClip, h.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", h.appendChild(i), r.extend(o, {
	         pixelPosition: function() {
	            return b(), c
	         },
	         boxSizingReliable: function() {
	            return b(), e
	         },
	         pixelMarginRight: function() {
	            return b(), f
	         },
	         reliableMarginLeft: function() {
	            return b(), g
	         }
	      }))
	   }();

	   function Oa(a, b, c) {
	      var d, e, f, g, h = a.style;
	      return c = c || Na(a), c && (g = c.getPropertyValue(b) || c[b], "" !== g || r.contains(a.ownerDocument, a) || (g = r.style(a, b)), !o.pixelMarginRight() && Ma.test(g) && La.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g
	   }
	   function Pa(a, b) {
	      return {
	         get: function() {
	            return a() ? void delete this.get : (this.get = b).apply(this, arguments)
	         }
	      }
	   }
	   var Qa = /^(none|table(?!-c[ea]).+)/,
	      Ra = /^--/,
	      Sa = {
	         position: "absolute",
	         visibility: "hidden",
	         display: "block"
	      },
	      Ta = {
	         letterSpacing: "0",
	         fontWeight: "400"
	      },
	      Ua = ["Webkit", "Moz", "ms"],
	      Va = d.createElement("div").style;

	   function Wa(a) {
	      if (a in Va) return a;
	      var b = a[0].toUpperCase() + a.slice(1),
	         c = Ua.length;
	      while (c--) if (a = Ua[c] + b, a in Va) return a
	   }
	   function Xa(a) {
	      var b = r.cssProps[a];
	      return b || (b = r.cssProps[a] = Wa(a) || a), b
	   }
	   function Ya(a, b, c) {
	      var d = ba.exec(b);
	      return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
	   }
	   function Za(a, b, c, d, e) {
	      var f, g = 0;
	      for (f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0; f < 4; f += 2)"margin" === c && (g += r.css(a, c + ca[f], !0, e)), d ? ("content" === c && (g -= r.css(a, "padding" + ca[f], !0, e)), "margin" !== c && (g -= r.css(a, "border" + ca[f] + "Width", !0, e))) : (g += r.css(a, "padding" + ca[f], !0, e), "padding" !== c && (g += r.css(a, "border" + ca[f] + "Width", !0, e)));
	      return g
	   }
	   function $a(a, b, c) {
	      var d, e = Na(a),
	         f = Oa(a, b, e),
	         g = "border-box" === r.css(a, "boxSizing", !1, e);
	      return Ma.test(f) ? f : (d = g && (o.boxSizingReliable() || f === a.style[b]), "auto" === f && (f = a["offset" + b[0].toUpperCase() + b.slice(1)]), f = parseFloat(f) || 0, f + Za(a, b, c || (g ? "border" : "content"), d, e) + "px")
	   }
	   r.extend({
	      cssHooks: {
	         opacity: {
	            get: function(a, b) {
	               if (b) {
	                  var c = Oa(a, "opacity");
	                  return "" === c ? "1" : c
	               }
	            }
	         }
	      },
	      cssNumber: {
	         animationIterationCount: !0,
	         columnCount: !0,
	         fillOpacity: !0,
	         flexGrow: !0,
	         flexShrink: !0,
	         fontWeight: !0,
	         lineHeight: !0,
	         opacity: !0,
	         order: !0,
	         orphans: !0,
	         widows: !0,
	         zIndex: !0,
	         zoom: !0
	      },
	      cssProps: {
	         "float": "cssFloat"
	      },
	      style: function(a, b, c, d) {
	         if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
	            var e, f, g, h = r.camelCase(b),
	               i = Ra.test(b),
	               j = a.style;
	            return i || (b = Xa(h)), g = r.cssHooks[b] || r.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : j[b] : (f = typeof c, "string" === f && (e = ba.exec(c)) && e[1] && (c = fa(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (r.cssNumber[h] ? "" : "px")), o.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (j[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i ? j.setProperty(b, c) : j[b] = c)), void 0)
	         }
	      },
	      css: function(a, b, c, d) {
	         var e, f, g, h = r.camelCase(b),
	            i = Ra.test(b);
	         return i || (b = Xa(h)), g = r.cssHooks[b] || r.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Oa(a, b, d)), "normal" === e && b in Ta && (e = Ta[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e
	      }
	   }), r.each(["height", "width"], function(a, b) {
	      r.cssHooks[b] = {
	         get: function(a, c, d) {
	            if (c) return !Qa.test(r.css(a, "display")) || a.getClientRects().length && a.getBoundingClientRect().width ? $a(a, b, d) : ea(a, Sa, function() {
	               return $a(a, b, d)
	            })
	         },
	         set: function(a, c, d) {
	            var e, f = d && Na(a),
	               g = d && Za(a, b, d, "border-box" === r.css(a, "boxSizing", !1, f), f);
	            return g && (e = ba.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = r.css(a, b)), Ya(a, c, g)
	         }
	      }
	   }), r.cssHooks.marginLeft = Pa(o.reliableMarginLeft, function(a, b) {
	      if (b) return (parseFloat(Oa(a, "marginLeft")) || a.getBoundingClientRect().left - ea(a, {
	         marginLeft: 0
	      }, function() {
	         return a.getBoundingClientRect().left
	      })) + "px"
	   }), r.each({
	      margin: "",
	      padding: "",
	      border: "Width"
	   }, function(a, b) {
	      r.cssHooks[a + b] = {
	         expand: function(c) {
	            for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; d < 4; d++) e[a + ca[d] + b] = f[d] || f[d - 2] || f[0];
	            return e
	         }
	      }, La.test(a) || (r.cssHooks[a + b].set = Ya)
	   }), r.fn.extend({
	      css: function(a, b) {
	         return T(this, function(a, b, c) {
	            var d, e, f = {},
	               g = 0;
	            if (Array.isArray(b)) {
	               for (d = Na(a), e = b.length; g < e; g++) f[b[g]] = r.css(a, b[g], !1, d);
	               return f
	            }
	            return void 0 !== c ? r.style(a, b, c) : r.css(a, b)
	         }, a, b, arguments.length > 1)
	      }
	   });

	   function _a(a, b, c, d, e) {
	      return new _a.prototype.init(a, b, c, d, e)
	   }
	   r.Tween = _a, _a.prototype = {
	      constructor: _a,
	      init: function(a, b, c, d, e, f) {
	         this.elem = a, this.prop = c, this.easing = e || r.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (r.cssNumber[c] ? "" : "px")
	      },
	      cur: function() {
	         var a = _a.propHooks[this.prop];
	         return a && a.get ? a.get(this) : _a.propHooks._default.get(this)
	      },
	      run: function(a) {
	         var b, c = _a.propHooks[this.prop];
	         return this.options.duration ? this.pos = b = r.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : _a.propHooks._default.set(this), this
	      }
	   }, _a.prototype.init.prototype = _a.prototype, _a.propHooks = {
	      _default: {
	         get: function(a) {
	            var b;
	            return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = r.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
	         },
	         set: function(a) {
	            r.fx.step[a.prop] ? r.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[r.cssProps[a.prop]] && !r.cssHooks[a.prop] ? a.elem[a.prop] = a.now : r.style(a.elem, a.prop, a.now + a.unit)
	         }
	      }
	   }, _a.propHooks.scrollTop = _a.propHooks.scrollLeft = {
	      set: function(a) {
	         a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
	      }
	   }, r.easing = {
	      linear: function(a) {
	         return a
	      },
	      swing: function(a) {
	         return .5 - Math.cos(a * Math.PI) / 2
	      },
	      _default: "swing"
	   }, r.fx = _a.prototype.init, r.fx.step = {};
	   var ab, bb, cb = /^(?:toggle|show|hide)$/,
	      db = /queueHooks$/;

	   function eb() {
	      bb && (d.hidden === !1 && a.requestAnimationFrame ? a.requestAnimationFrame(eb) : a.setTimeout(eb, r.fx.interval), r.fx.tick())
	   }
	   function fb() {
	      return a.setTimeout(function() {
	         ab = void 0
	      }), ab = r.now()
	   }
	   function gb(a, b) {
	      var c, d = 0,
	         e = {
	            height: a
	         };
	      for (b = b ? 1 : 0; d < 4; d += 2 - b) c = ca[d], e["margin" + c] = e["padding" + c] = a;
	      return b && (e.opacity = e.width = a), e
	   }
	   function hb(a, b, c) {
	      for (var d, e = (kb.tweeners[b] || []).concat(kb.tweeners["*"]), f = 0, g = e.length; f < g; f++) if (d = e[f].call(c, b, a)) return d
	   }
	   function ib(a, b, c) {
	      var d, e, f, g, h, i, j, k, l = "width" in b || "height" in b,
	         m = this,
	         n = {},
	         o = a.style,
	         p = a.nodeType && da(a),
	         q = W.get(a, "fxshow");
	      c.queue || (g = r._queueHooks(a, "fx"), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function() {
	         g.unqueued || h()
	      }), g.unqueued++, m.always(function() {
	         m.always(function() {
	            g.unqueued--, r.queue(a, "fx").length || g.empty.fire()
	         })
	      }));
	      for (d in b) if (e = b[d], cb.test(e)) {
	         if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
	            if ("show" !== e || !q || void 0 === q[d]) continue;
	            p = !0
	         }
	         n[d] = q && q[d] || r.style(a, d)
	      }
	      if (i = !r.isEmptyObject(b), i || !r.isEmptyObject(n)) {
	         l && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null == j && (j = W.get(a, "display")), k = r.css(a, "display"), "none" === k && (j ? k = j : (ia([a], !0), j = a.style.display || j, k = r.css(a, "display"), ia([a]))), ("inline" === k || "inline-block" === k && null != j) && "none" === r.css(a, "float") && (i || (m.done(function() {
	            o.display = j;
	         }), null == j && (k = o.display, j = "none" === k ? "" : k)), o.display = "inline-block")), c.overflow && (o.overflow = "hidden", m.always(function() {
	            o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
	         })), i = !1;
	         for (d in n) i || (q ? "hidden" in q && (p = q.hidden) : q = W.access(a, "fxshow", {
	            display: j
	         }), f && (q.hidden = !p), p && ia([a], !0), m.done(function() {
	            p || ia([a]), W.remove(a, "fxshow");
	            for (d in n) r.style(a, d, n[d])
	         })), i = hb(p ? q[d] : 0, d, m), d in q || (q[d] = i.start, p && (i.end = i.start, i.start = 0))
	      }
	   }
	   function jb(a, b) {
	      var c, d, e, f, g;
	      for (c in a) if (d = r.camelCase(c), e = b[d], f = a[c], Array.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = r.cssHooks[d], g && "expand" in g) {
	         f = g.expand(f), delete a[d];
	         for (c in f) c in a || (a[c] = f[c], b[c] = e)
	      } else b[d] = e
	   }
	   function kb(a, b, c) {
	      var d, e, f = 0,
	         g = kb.prefilters.length,
	         h = r.Deferred().always(function() {
	            delete i.elem
	         }),
	         i = function() {
	            if (e) return !1;
	            for (var b = ab || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; g < i; g++) j.tweens[g].run(f);
	            return h.notifyWith(a, [j, f, c]), f < 1 && i ? c : (i || h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j]), !1)
	         },
	         j = h.promise({
	            elem: a,
	            props: r.extend({}, b),
	            opts: r.extend(!0, {
	               specialEasing: {},
	               easing: r.easing._default
	            }, c),
	            originalProperties: b,
	            originalOptions: c,
	            startTime: ab || fb(),
	            duration: c.duration,
	            tweens: [],
	            createTween: function(b, c) {
	               var d = r.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
	               return j.tweens.push(d), d
	            },
	            stop: function(b) {
	               var c = 0,
	                  d = b ? j.tweens.length : 0;
	               if (e) return this;
	               for (e = !0; c < d; c++) j.tweens[c].run(1);
	               return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
	            }
	         }),
	         k = j.props;
	      for (jb(k, j.opts.specialEasing); f < g; f++) if (d = kb.prefilters[f].call(j, a, k, j.opts)) return r.isFunction(d.stop) && (r._queueHooks(j.elem, j.opts.queue).stop = r.proxy(d.stop, d)), d;
	      return r.map(k, hb, j), r.isFunction(j.opts.start) && j.opts.start.call(a, j), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always), r.fx.timer(r.extend(i, {
	         elem: a,
	         anim: j,
	         queue: j.opts.queue
	      })), j
	   }
	   r.Animation = r.extend(kb, {
	      tweeners: {
	         "*": [function(a, b) {
	            var c = this.createTween(a, b);
	            return fa(c.elem, a, ba.exec(b), c), c
	         }]
	      },
	      tweener: function(a, b) {
	         r.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(L);
	         for (var c, d = 0, e = a.length; d < e; d++) c = a[d], kb.tweeners[c] = kb.tweeners[c] || [], kb.tweeners[c].unshift(b)
	      },
	      prefilters: [ib],
	      prefilter: function(a, b) {
	         b ? kb.prefilters.unshift(a) : kb.prefilters.push(a)
	      }
	   }), r.speed = function(a, b, c) {
	      var d = a && "object" == typeof a ? r.extend({}, a) : {
	         complete: c || !c && b || r.isFunction(a) && a,
	         duration: a,
	         easing: c && b || b && !r.isFunction(b) && b
	      };
	      return r.fx.off ? d.duration = 0 : "number" != typeof d.duration && (d.duration in r.fx.speeds ? d.duration = r.fx.speeds[d.duration] : d.duration = r.fx.speeds._default), null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
	         r.isFunction(d.old) && d.old.call(this), d.queue && r.dequeue(this, d.queue)
	      }, d
	   }, r.fn.extend({
	      fadeTo: function(a, b, c, d) {
	         return this.filter(da).css("opacity", 0).show().end().animate({
	            opacity: b
	         }, a, c, d)
	      },
	      animate: function(a, b, c, d) {
	         var e = r.isEmptyObject(a),
	            f = r.speed(b, c, d),
	            g = function() {
	               var b = kb(this, r.extend({}, a), f);
	               (e || W.get(this, "finish")) && b.stop(!0)
	            };
	         return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
	      },
	      stop: function(a, b, c) {
	         var d = function(a) {
	               var b = a.stop;
	               delete a.stop, b(c)
	            };
	         return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
	            var b = !0,
	               e = null != a && a + "queueHooks",
	               f = r.timers,
	               g = W.get(this);
	            if (e) g[e] && g[e].stop && d(g[e]);
	            else for (e in g) g[e] && g[e].stop && db.test(e) && d(g[e]);
	            for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
	            !b && c || r.dequeue(this, a)
	         })
	      },
	      finish: function(a) {
	         return a !== !1 && (a = a || "fx"), this.each(function() {
	            var b, c = W.get(this),
	               d = c[a + "queue"],
	               e = c[a + "queueHooks"],
	               f = r.timers,
	               g = d ? d.length : 0;
	            for (c.finish = !0, r.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
	            for (b = 0; b < g; b++) d[b] && d[b].finish && d[b].finish.call(this);
	            delete c.finish
	         })
	      }
	   }), r.each(["toggle", "show", "hide"], function(a, b) {
	      var c = r.fn[b];
	      r.fn[b] = function(a, d, e) {
	         return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e)
	      }
	   }), r.each({
	      slideDown: gb("show"),
	      slideUp: gb("hide"),
	      slideToggle: gb("toggle"),
	      fadeIn: {
	         opacity: "show"
	      },
	      fadeOut: {
	         opacity: "hide"
	      },
	      fadeToggle: {
	         opacity: "toggle"
	      }
	   }, function(a, b) {
	      r.fn[a] = function(a, c, d) {
	         return this.animate(b, a, c, d)
	      }
	   }), r.timers = [], r.fx.tick = function() {
	      var a, b = 0,
	         c = r.timers;
	      for (ab = r.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
	      c.length || r.fx.stop(), ab = void 0
	   }, r.fx.timer = function(a) {
	      r.timers.push(a), r.fx.start()
	   }, r.fx.interval = 13, r.fx.start = function() {
	      bb || (bb = !0, eb())
	   }, r.fx.stop = function() {
	      bb = null
	   }, r.fx.speeds = {
	      slow: 600,
	      fast: 200,
	      _default: 400
	   }, r.fn.delay = function(b, c) {
	      return b = r.fx ? r.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
	         var e = a.setTimeout(c, b);
	         d.stop = function() {
	            a.clearTimeout(e)
	         }
	      })
	   }, function() {
	      var a = d.createElement("input"),
	         b = d.createElement("select"),
	         c = b.appendChild(d.createElement("option"));
	      a.type = "checkbox", o.checkOn = "" !== a.value, o.optSelected = c.selected, a = d.createElement("input"), a.value = "t", a.type = "radio", o.radioValue = "t" === a.value
	   }();
	   var lb, mb = r.expr.attrHandle;
	   r.fn.extend({
	      attr: function(a, b) {
	         return T(this, r.attr, a, b, arguments.length > 1)
	      },
	      removeAttr: function(a) {
	         return this.each(function() {
	            r.removeAttr(this, a)
	         })
	      }
	   }), r.extend({
	      attr: function(a, b, c) {
	         var d, e, f = a.nodeType;
	         if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? r.prop(a, b, c) : (1 === f && r.isXMLDoc(a) || (e = r.attrHooks[b.toLowerCase()] || (r.expr.match.bool.test(b) ? lb : void 0)), void 0 !== c ? null === c ? void r.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = r.find.attr(a, b), null == d ? void 0 : d))
	      },
	      attrHooks: {
	         type: {
	            set: function(a, b) {
	               if (!o.radioValue && "radio" === b && B(a, "input")) {
	                  var c = a.value;
	                  return a.setAttribute("type", b), c && (a.value = c), b
	               }
	            }
	         }
	      },
	      removeAttr: function(a, b) {
	         var c, d = 0,
	            e = b && b.match(L);
	         if (e && 1 === a.nodeType) while (c = e[d++]) a.removeAttribute(c)
	      }
	   }), lb = {
	      set: function(a, b, c) {
	         return b === !1 ? r.removeAttr(a, c) : a.setAttribute(c, c), c
	      }
	   }, r.each(r.expr.match.bool.source.match(/\w+/g), function(a, b) {
	      var c = mb[b] || r.find.attr;
	      mb[b] = function(a, b, d) {
	         var e, f, g = b.toLowerCase();
	         return d || (f = mb[g], mb[g] = e, e = null != c(a, b, d) ? g : null, mb[g] = f), e
	      }
	   });
	   var nb = /^(?:input|select|textarea|button)$/i,
	      ob = /^(?:a|area)$/i;
	   r.fn.extend({
	      prop: function(a, b) {
	         return T(this, r.prop, a, b, arguments.length > 1)
	      },
	      removeProp: function(a) {
	         return this.each(function() {
	            delete this[r.propFix[a] || a]
	         })
	      }
	   }), r.extend({
	      prop: function(a, b, c) {
	         var d, e, f = a.nodeType;
	         if (3 !== f && 8 !== f && 2 !== f) return 1 === f && r.isXMLDoc(a) || (b = r.propFix[b] || b, e = r.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
	      },
	      propHooks: {
	         tabIndex: {
	            get: function(a) {
	               var b = r.find.attr(a, "tabindex");
	               return b ? parseInt(b, 10) : nb.test(a.nodeName) || ob.test(a.nodeName) && a.href ? 0 : -1
	            }
	         }
	      },
	      propFix: {
	         "for": "htmlFor",
	         "class": "className"
	      }
	   }), o.optSelected || (r.propHooks.selected = {
	      get: function(a) {
	         var b = a.parentNode;
	         return b && b.parentNode && b.parentNode.selectedIndex, null
	      },
	      set: function(a) {
	         var b = a.parentNode;
	         b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
	      }
	   }), r.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
	      r.propFix[this.toLowerCase()] = this
	   });

	   function pb(a) {
	      var b = a.match(L) || [];
	      return b.join(" ")
	   }
	   function qb(a) {
	      return a.getAttribute && a.getAttribute("class") || ""
	   }
	   r.fn.extend({
	      addClass: function(a) {
	         var b, c, d, e, f, g, h, i = 0;
	         if (r.isFunction(a)) return this.each(function(b) {
	            r(this).addClass(a.call(this, b, qb(this)))
	         });
	         if ("string" == typeof a && a) {
	            b = a.match(L) || [];
	            while (c = this[i++]) if (e = qb(c), d = 1 === c.nodeType && " " + pb(e) + " ") {
	               g = 0;
	               while (f = b[g++]) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
	               h = pb(d), e !== h && c.setAttribute("class", h)
	            }
	         }
	         return this
	      },
	      removeClass: function(a) {
	         var b, c, d, e, f, g, h, i = 0;
	         if (r.isFunction(a)) return this.each(function(b) {
	            r(this).removeClass(a.call(this, b, qb(this)))
	         });
	         if (!arguments.length) return this.attr("class", "");
	         if ("string" == typeof a && a) {
	            b = a.match(L) || [];
	            while (c = this[i++]) if (e = qb(c), d = 1 === c.nodeType && " " + pb(e) + " ") {
	               g = 0;
	               while (f = b[g++]) while (d.indexOf(" " + f + " ") > -1) d = d.replace(" " + f + " ", " ");
	               h = pb(d), e !== h && c.setAttribute("class", h)
	            }
	         }
	         return this
	      },
	      toggleClass: function(a, b) {
	         var c = typeof a;
	         return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : r.isFunction(a) ? this.each(function(c) {
	            r(this).toggleClass(a.call(this, c, qb(this), b), b)
	         }) : this.each(function() {
	            var b, d, e, f;
	            if ("string" === c) {
	               d = 0, e = r(this), f = a.match(L) || [];
	               while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
	            } else void 0 !== a && "boolean" !== c || (b = qb(this), b && W.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : W.get(this, "__className__") || ""))
	         })
	      },
	      hasClass: function(a) {
	         var b, c, d = 0;
	         b = " " + a + " ";
	         while (c = this[d++]) if (1 === c.nodeType && (" " + pb(qb(c)) + " ").indexOf(b) > -1) return !0;
	         return !1
	      }
	   });
	   var rb = /\r/g;
	   r.fn.extend({
	      val: function(a) {
	         var b, c, d, e = this[0]; {
	            if (arguments.length) return d = r.isFunction(a), this.each(function(c) {
	               var e;
	               1 === this.nodeType && (e = d ? a.call(this, c, r(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : Array.isArray(e) && (e = r.map(e, function(a) {
	                  return null == a ? "" : a + ""
	               })), b = r.valHooks[this.type] || r.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
	            });
	            if (e) return b = r.valHooks[e.type] || r.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(rb, "") : null == c ? "" : c)
	         }
	      }
	   }), r.extend({
	      valHooks: {
	         option: {
	            get: function(a) {
	               var b = r.find.attr(a, "value");
	               return null != b ? b : pb(r.text(a))
	            }
	         },
	         select: {
	            get: function(a) {
	               var b, c, d, e = a.options,
	                  f = a.selectedIndex,
	                  g = "select-one" === a.type,
	                  h = g ? null : [],
	                  i = g ? f + 1 : e.length;
	               for (d = f < 0 ? i : g ? f : 0; d < i; d++) if (c = e[d], (c.selected || d === f) && !c.disabled && (!c.parentNode.disabled || !B(c.parentNode, "optgroup"))) {
	                  if (b = r(c).val(), g) return b;
	                  h.push(b)
	               }
	               return h
	            },
	            set: function(a, b) {
	               var c, d, e = a.options,
	                  f = r.makeArray(b),
	                  g = e.length;
	               while (g--) d = e[g], (d.selected = r.inArray(r.valHooks.option.get(d), f) > -1) && (c = !0);
	               return c || (a.selectedIndex = -1), f
	            }
	         }
	      }
	   }), r.each(["radio", "checkbox"], function() {
	      r.valHooks[this] = {
	         set: function(a, b) {
	            if (Array.isArray(b)) return a.checked = r.inArray(r(a).val(), b) > -1
	         }
	      }, o.checkOn || (r.valHooks[this].get = function(a) {
	         return null === a.getAttribute("value") ? "on" : a.value
	      })
	   });
	   var sb = /^(?:focusinfocus|focusoutblur)$/;
	   r.extend(r.event, {
	      trigger: function(b, c, e, f) {
	         var g, h, i, j, k, m, n, o = [e || d],
	            p = l.call(b, "type") ? b.type : b,
	            q = l.call(b, "namespace") ? b.namespace.split(".") : [];
	         if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !sb.test(p + r.event.triggered) && (p.indexOf(".") > -1 && (q = p.split("."), p = q.shift(), q.sort()), k = p.indexOf(":") < 0 && "on" + p, b = b[r.expando] ? b : new r.Event(p, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = q.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : r.makeArray(c, [b]), n = r.event.special[p] || {}, f || !n.trigger || n.trigger.apply(e, c) !== !1)) {
	            if (!f && !n.noBubble && !r.isWindow(e)) {
	               for (j = n.delegateType || p, sb.test(j + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), i = h;
	               i === (e.ownerDocument || d) && o.push(i.defaultView || i.parentWindow || a)
	            }
	            g = 0;
	            while ((h = o[g++]) && !b.isPropagationStopped()) b.type = g > 1 ? j : n.bindType || p, m = (W.get(h, "events") || {})[b.type] && W.get(h, "handle"), m && m.apply(h, c), m = k && h[k], m && m.apply && U(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());
	            return b.type = p, f || b.isDefaultPrevented() || n._default && n._default.apply(o.pop(), c) !== !1 || !U(e) || k && r.isFunction(e[p]) && !r.isWindow(e) && (i = e[k], i && (e[k] = null), r.event.triggered = p, e[p](), r.event.triggered = void 0, i && (e[k] = i)), b.result
	         }
	      },
	      simulate: function(a, b, c) {
	         var d = r.extend(new r.Event, c, {
	            type: a,
	            isSimulated: !0
	         });
	         r.event.trigger(d, null, b)
	      }
	   }), r.fn.extend({
	      trigger: function(a, b) {
	         return this.each(function() {
	            r.event.trigger(a, b, this)
	         })
	      },
	      triggerHandler: function(a, b) {
	         var c = this[0];
	         if (c) return r.event.trigger(a, b, c, !0)
	      }
	   }), r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(a, b) {
	      r.fn[b] = function(a, c) {
	         return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
	      }
	   }), r.fn.extend({
	      hover: function(a, b) {
	         return this.mouseenter(a).mouseleave(b || a)
	      }
	   }), o.focusin = "onfocusin" in a, o.focusin || r.each({
	      focus: "focusin",
	      blur: "focusout"
	   }, function(a, b) {
	      var c = function(a) {
	            r.event.simulate(b, a.target, r.event.fix(a))
	         };
	      r.event.special[b] = {
	         setup: function() {
	            var d = this.ownerDocument || this,
	               e = W.access(d, b);
	            e || d.addEventListener(a, c, !0), W.access(d, b, (e || 0) + 1)
	         },
	         teardown: function() {
	            var d = this.ownerDocument || this,
	               e = W.access(d, b) - 1;
	            e ? W.access(d, b, e) : (d.removeEventListener(a, c, !0), W.remove(d, b))
	         }
	      }
	   });
	   var tb = a.location,
	      ub = r.now(),
	      vb = /\?/;
	   r.parseXML = function(b) {
	      var c;
	      if (!b || "string" != typeof b) return null;
	      try {
	         c = (new a.DOMParser).parseFromString(b, "text/xml")
	      } catch (d) {
	         c = void 0
	      }
	      return c && !c.getElementsByTagName("parsererror").length || r.error("Invalid XML: " + b), c
	   };
	   var wb = /\[\]$/,
	      xb = /\r?\n/g,
	      yb = /^(?:submit|button|image|reset|file)$/i,
	      zb = /^(?:input|select|textarea|keygen)/i;

	   function Ab(a, b, c, d) {
	      var e;
	      if (Array.isArray(b)) r.each(b, function(b, e) {
	         c || wb.test(a) ? d(a, e) : Ab(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
	      });
	      else if (c || "object" !== r.type(b)) d(a, b);
	      else for (e in b) Ab(a + "[" + e + "]", b[e], c, d)
	   }
	   r.param = function(a, b) {
	      var c, d = [],
	         e = function(a, b) {
	            var c = r.isFunction(b) ? b() : b;
	            d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(null == c ? "" : c)
	         };
	      if (Array.isArray(a) || a.jquery && !r.isPlainObject(a)) r.each(a, function() {
	         e(this.name, this.value)
	      });
	      else for (c in a) Ab(c, a[c], b, e);
	      return d.join("&")
	   }, r.fn.extend({
	      serialize: function() {
	         return r.param(this.serializeArray())
	      },
	      serializeArray: function() {
	         return this.map(function() {
	            var a = r.prop(this, "elements");
	            return a ? r.makeArray(a) : this
	         }).filter(function() {
	            var a = this.type;
	            return this.name && !r(this).is(":disabled") && zb.test(this.nodeName) && !yb.test(a) && (this.checked || !ja.test(a))
	         }).map(function(a, b) {
	            var c = r(this).val();
	            return null == c ? null : Array.isArray(c) ? r.map(c, function(a) {
	               return {
	                  name: b.name,
	                  value: a.replace(xb, "\r\n")
	               }
	            }) : {
	               name: b.name,
	               value: c.replace(xb, "\r\n")
	            }
	         }).get()
	      }
	   });
	   var Bb = /%20/g,
	      Cb = /#.*$/,
	      Db = /([?&])_=[^&]*/,
	      Eb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
	      Fb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	      Gb = /^(?:GET|HEAD)$/,
	      Hb = /^\/\//,
	      Ib = {},
	      Jb = {},
	      Kb = "*/".concat("*"),
	      Lb = d.createElement("a");
	   Lb.href = tb.href;

	   function Mb(a) {
	      return function(b, c) {
	         "string" != typeof b && (c = b, b = "*");
	         var d, e = 0,
	            f = b.toLowerCase().match(L) || [];
	         if (r.isFunction(c)) while (d = f[e++])"+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
	      }
	   }
	   function Nb(a, b, c, d) {
	      var e = {},
	         f = a === Jb;

	      function g(h) {
	         var i;
	         return e[h] = !0, r.each(a[h] || [], function(a, h) {
	            var j = h(b, c, d);
	            return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
	         }), i
	      }
	      return g(b.dataTypes[0]) || !e["*"] && g("*")
	   }
	   function Ob(a, b) {
	      var c, d, e = r.ajaxSettings.flatOptions || {};
	      for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
	      return d && r.extend(!0, a, d), a
	   }
	   function Pb(a, b, c) {
	      var d, e, f, g, h = a.contents,
	         i = a.dataTypes;
	      while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
	      if (d) for (e in h) if (h[e] && h[e].test(d)) {
	         i.unshift(e);
	         break
	      }
	      if (i[0] in c) f = i[0];
	      else {
	         for (e in c) {
	            if (!i[0] || a.converters[e + " " + i[0]]) {
	               f = e;
	               break
	            }
	            g || (g = e)
	         }
	         f = f || g
	      }
	      if (f) return f !== i[0] && i.unshift(f), c[f]
	   }
	   function Qb(a, b, c, d) {
	      var e, f, g, h, i, j = {},
	         k = a.dataTypes.slice();
	      if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
	      f = k.shift();
	      while (f) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i;
	      else if ("*" !== i && i !== f) {
	         if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
	            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
	            break
	         }
	         if (g !== !0) if (g && a["throws"]) b = g(b);
	         else try {
	            b = g(b)
	         } catch (l) {
	            return {
	               state: "parsererror",
	               error: g ? l : "No conversion from " + i + " to " + f
	            }
	         }
	      }
	      return {
	         state: "success",
	         data: b
	      }
	   }
	   r.extend({
	      active: 0,
	      lastModified: {},
	      etag: {},
	      ajaxSettings: {
	         url: tb.href,
	         type: "GET",
	         isLocal: Fb.test(tb.protocol),
	         global: !0,
	         processData: !0,
	         async: !0,
	         contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	         accepts: {
	            "*": Kb,
	            text: "text/plain",
	            html: "text/html",
	            xml: "application/xml, text/xml",
	            json: "application/json, text/javascript"
	         },
	         contents: {
	            xml: /\bxml\b/,
	            html: /\bhtml/,
	            json: /\bjson\b/
	         },
	         responseFields: {
	            xml: "responseXML",
	            text: "responseText",
	            json: "responseJSON"
	         },
	         converters: {
	            "* text": String,
	            "text html": !0,
	            "text json": JSON.parse,
	            "text xml": r.parseXML
	         },
	         flatOptions: {
	            url: !0,
	            context: !0
	         }
	      },
	      ajaxSetup: function(a, b) {
	         return b ? Ob(Ob(a, r.ajaxSettings), b) : Ob(r.ajaxSettings, a)
	      },
	      ajaxPrefilter: Mb(Ib),
	      ajaxTransport: Mb(Jb),
	      ajax: function(b, c) {
	         "object" == typeof b && (c = b, b = void 0), c = c || {};
	         var e, f, g, h, i, j, k, l, m, n, o = r.ajaxSetup({}, c),
	            p = o.context || o,
	            q = o.context && (p.nodeType || p.jquery) ? r(p) : r.event,
	            s = r.Deferred(),
	            t = r.Callbacks("once memory"),
	            u = o.statusCode || {},
	            v = {},
	            w = {},
	            x = "canceled",
	            y = {
	               readyState: 0,
	               getResponseHeader: function(a) {
	                  var b;
	                  if (k) {
	                     if (!h) {
	                        h = {};
	                        while (b = Eb.exec(g)) h[b[1].toLowerCase()] = b[2]
	                     }
	                     b = h[a.toLowerCase()]
	                  }
	                  return null == b ? null : b
	               },
	               getAllResponseHeaders: function() {
	                  return k ? g : null
	               },
	               setRequestHeader: function(a, b) {
	                  return null == k && (a = w[a.toLowerCase()] = w[a.toLowerCase()] || a, v[a] = b), this
	               },
	               overrideMimeType: function(a) {
	                  return null == k && (o.mimeType = a), this
	               },
	               statusCode: function(a) {
	                  var b;
	                  if (a) if (k) y.always(a[y.status]);
	                  else for (b in a) u[b] = [u[b], a[b]];
	                  return this
	               },
	               abort: function(a) {
	                  var b = a || x;
	                  return e && e.abort(b), A(0, b), this
	               }
	            };
	         if (s.promise(y), o.url = ((b || o.url || tb.href) + "").replace(Hb, tb.protocol + "//"), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || "*").toLowerCase().match(L) || [""], null == o.crossDomain) {
	            j = d.createElement("a");
	            try {
	               j.href = o.url, j.href = j.href, o.crossDomain = Lb.protocol + "//" + Lb.host != j.protocol + "//" + j.host
	            } catch (z) {
	               o.crossDomain = !0
	            }
	         }
	         if (o.data && o.processData && "string" != typeof o.data && (o.data = r.param(o.data, o.traditional)), Nb(Ib, o, c, y), k) return y;
	         l = r.event && o.global, l && 0 === r.active++ && r.event.trigger("ajaxStart"), o.type = o.type.toUpperCase(), o.hasContent = !Gb.test(o.type), f = o.url.replace(Cb, ""), o.hasContent ? o.data && o.processData && 0 === (o.contentType || "").indexOf("application/x-www-form-urlencoded") && (o.data = o.data.replace(Bb, "+")) : (n = o.url.slice(f.length), o.data && (f += (vb.test(f) ? "&" : "?") + o.data, delete o.data), o.cache === !1 && (f = f.replace(Db, "$1"), n = (vb.test(f) ? "&" : "?") + "_=" + ub+++n), o.url = f + n), o.ifModified && (r.lastModified[f] && y.setRequestHeader("If-Modified-Since", r.lastModified[f]), r.etag[f] && y.setRequestHeader("If-None-Match", r.etag[f])), (o.data && o.hasContent && o.contentType !== !1 || c.contentType) && y.setRequestHeader("Content-Type", o.contentType), y.setRequestHeader("Accept", o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + ("*" !== o.dataTypes[0] ? ", " + Kb + "; q=0.01" : "") : o.accepts["*"]);
	         for (m in o.headers) y.setRequestHeader(m, o.headers[m]);
	         if (o.beforeSend && (o.beforeSend.call(p, y, o) === !1 || k)) return y.abort();
	         if (x = "abort", t.add(o.complete), y.done(o.success), y.fail(o.error), e = Nb(Jb, o, c, y)) {
	            if (y.readyState = 1, l && q.trigger("ajaxSend", [y, o]), k) return y;
	            o.async && o.timeout > 0 && (i = a.setTimeout(function() {
	               y.abort("timeout")
	            }, o.timeout));
	            try {
	               k = !1, e.send(v, A)
	            } catch (z) {
	               if (k) throw z;
	               A(-1, z)
	            }
	         } else A(-1, "No Transport");

	         function A(b, c, d, h) {
	            var j, m, n, v, w, x = c;
	            k || (k = !0, i && a.clearTimeout(i), e = void 0, g = h || "", y.readyState = b > 0 ? 4 : 0, j = b >= 200 && b < 300 || 304 === b, d && (v = Pb(o, y, d)), v = Qb(o, v, y, j), j ? (o.ifModified && (w = y.getResponseHeader("Last-Modified"), w && (r.lastModified[f] = w), w = y.getResponseHeader("etag"), w && (r.etag[f] = w)), 204 === b || "HEAD" === o.type ? x = "nocontent" : 304 === b ? x = "notmodified" : (x = v.state, m = v.data, n = v.error, j = !n)) : (n = x, !b && x || (x = "error", b < 0 && (b = 0))), y.status = b, y.statusText = (c || x) + "", j ? s.resolveWith(p, [m, x, y]) : s.rejectWith(p, [y, x, n]), y.statusCode(u), u = void 0, l && q.trigger(j ? "ajaxSuccess" : "ajaxError", [y, o, j ? m : n]), t.fireWith(p, [y, x]), l && (q.trigger("ajaxComplete", [y, o]), --r.active || r.event.trigger("ajaxStop")))
	         }
	         return y
	      },
	      getJSON: function(a, b, c) {
	         return r.get(a, b, c, "json")
	      },
	      getScript: function(a, b) {
	         return r.get(a, void 0, b, "script")
	      }
	   }), r.each(["get", "post"], function(a, b) {
	      r[b] = function(a, c, d, e) {
	         return r.isFunction(c) && (e = e || d, d = c, c = void 0), r.ajax(r.extend({
	            url: a,
	            type: b,
	            dataType: e,
	            data: c,
	            success: d
	         }, r.isPlainObject(a) && a))
	      }
	   }), r._evalUrl = function(a) {
	      return r.ajax({
	         url: a,
	         type: "GET",
	         dataType: "script",
	         cache: !0,
	         async: !1,
	         global: !1,
	         "throws": !0
	      })
	   }, r.fn.extend({
	      wrapAll: function(a) {
	         var b;
	         return this[0] && (r.isFunction(a) && (a = a.call(this[0])), b = r(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
	            var a = this;
	            while (a.firstElementChild) a = a.firstElementChild;
	            return a
	         }).append(this)), this
	      },
	      wrapInner: function(a) {
	         return r.isFunction(a) ? this.each(function(b) {
	            r(this).wrapInner(a.call(this, b))
	         }) : this.each(function() {
	            var b = r(this),
	               c = b.contents();
	            c.length ? c.wrapAll(a) : b.append(a)
	         })
	      },
	      wrap: function(a) {
	         var b = r.isFunction(a);
	         return this.each(function(c) {
	            r(this).wrapAll(b ? a.call(this, c) : a)
	         })
	      },
	      unwrap: function(a) {
	         return this.parent(a).not("body").each(function() {
	            r(this).replaceWith(this.childNodes)
	         }), this
	      }
	   }), r.expr.pseudos.hidden = function(a) {
	      return !r.expr.pseudos.visible(a)
	   }, r.expr.pseudos.visible = function(a) {
	      return !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length)
	   }, r.ajaxSettings.xhr = function() {
	      try {
	         return new a.XMLHttpRequest
	      } catch (b) {}
	   };
	   var Rb = {
	      0: 200,
	      1223: 204
	   },
	      Sb = r.ajaxSettings.xhr();
	   o.cors = !! Sb && "withCredentials" in Sb, o.ajax = Sb = !! Sb, r.ajaxTransport(function(b) {
	      var c, d;
	      if (o.cors || Sb && !b.crossDomain) return {
	         send: function(e, f) {
	            var g, h = b.xhr();
	            if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) h[g] = b.xhrFields[g];
	            b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
	            for (g in e) h.setRequestHeader(g, e[g]);
	            c = function(a) {
	               return function() {
	                  c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Rb[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
	                     binary: h.response
	                  } : {
	                     text: h.responseText
	                  }, h.getAllResponseHeaders()))
	               }
	            }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
	               4 === h.readyState && a.setTimeout(function() {
	                  c && d()
	               })
	            }, c = c("abort");
	            try {
	               h.send(b.hasContent && b.data || null)
	            } catch (i) {
	               if (c) throw i
	            }
	         },
	         abort: function() {
	            c && c()
	         }
	      }
	   }), r.ajaxPrefilter(function(a) {
	      a.crossDomain && (a.contents.script = !1)
	   }), r.ajaxSetup({
	      accepts: {
	         script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	      },
	      contents: {
	         script: /\b(?:java|ecma)script\b/
	      },
	      converters: {
	         "text script": function(a) {
	            return r.globalEval(a), a
	         }
	      }
	   }), r.ajaxPrefilter("script", function(a) {
	      void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
	   }), r.ajaxTransport("script", function(a) {
	      if (a.crossDomain) {
	         var b, c;
	         return {
	            send: function(e, f) {
	               b = r("<script>").prop({
	                  charset: a.scriptCharset,
	                  src: a.url
	               }).on("load error", c = function(a) {
	                  b.remove(), c = null, a && f("error" === a.type ? 404 : 200, a.type)
	               }), d.head.appendChild(b[0])
	            },
	            abort: function() {
	               c && c()
	            }
	         }
	      }
	   });
	   var Tb = [],
	      Ub = /(=)\?(?=&|$)|\?\?/;
	   r.ajaxSetup({
	      jsonp: "callback",
	      jsonpCallback: function() {
	         var a = Tb.pop() || r.expando + "_" + ub++;
	         return this[a] = !0, a
	      }
	   }), r.ajaxPrefilter("json jsonp", function(b, c, d) {
	      var e, f, g, h = b.jsonp !== !1 && (Ub.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Ub.test(b.data) && "data");
	      if (h || "jsonp" === b.dataTypes[0]) return e = b.jsonpCallback = r.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Ub, "$1" + e) : b.jsonp !== !1 && (b.url += (vb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
	         return g || r.error(e + " was not called"), g[0]
	      }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
	         g = arguments
	      }, d.always(function() {
	         void 0 === f ? r(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Tb.push(e)), g && r.isFunction(f) && f(g[0]), g = f = void 0
	      }), "script"
	   }), o.createHTMLDocument = function() {
	      var a = d.implementation.createHTMLDocument("").body;
	      return a.innerHTML = "<form></form><form></form>", 2 === a.childNodes.length
	   }(), r.parseHTML = function(a, b, c) {
	      if ("string" != typeof a) return [];
	      "boolean" == typeof b && (c = b, b = !1);
	      var e, f, g;
	      return b || (o.createHTMLDocument ? (b = d.implementation.createHTMLDocument(""), e = b.createElement("base"), e.href = d.location.href, b.head.appendChild(e)) : b = d), f = C.exec(a), g = !c && [], f ? [b.createElement(f[1])] : (f = qa([a], b, g), g && g.length && r(g).remove(), r.merge([], f.childNodes))
	   }, r.fn.load = function(a, b, c) {
	      var d, e, f, g = this,
	         h = a.indexOf(" ");
	      return h > -1 && (d = pb(a.slice(h)), a = a.slice(0, h)), r.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && r.ajax({
	         url: a,
	         type: e || "GET",
	         dataType: "html",
	         data: b
	      }).done(function(a) {
	         f = arguments, g.html(d ? r("<div>").append(r.parseHTML(a)).find(d) : a)
	      }).always(c &&
	      function(a, b) {
	         g.each(function() {
	            c.apply(this, f || [a.responseText, b, a])
	         })
	      }), this
	   }, r.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
	      r.fn[b] = function(a) {
	         return this.on(b, a)
	      }
	   }), r.expr.pseudos.animated = function(a) {
	      return r.grep(r.timers, function(b) {
	         return a === b.elem
	      }).length
	   }, r.offset = {
	      setOffset: function(a, b, c) {
	         var d, e, f, g, h, i, j, k = r.css(a, "position"),
	            l = r(a),
	            m = {};
	         "static" === k && (a.style.position = "relative"), h = l.offset(), f = r.css(a, "top"), i = r.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), r.isFunction(b) && (b = b.call(a, c, r.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
	      }
	   }, r.fn.extend({
	      offset: function(a) {
	         if (arguments.length) return void 0 === a ? this : this.each(function(b) {
	            r.offset.setOffset(this, a, b)
	         });
	         var b, c, d, e, f = this[0];
	         if (f) return f.getClientRects().length ? (d = f.getBoundingClientRect(), b = f.ownerDocument, c = b.documentElement, e = b.defaultView, {
	            top: d.top + e.pageYOffset - c.clientTop,
	            left: d.left + e.pageXOffset - c.clientLeft
	         }) : {
	            top: 0,
	            left: 0
	         }
	      },
	      position: function() {
	         if (this[0]) {
	            var a, b, c = this[0],
	               d = {
	                  top: 0,
	                  left: 0
	               };
	            return "fixed" === r.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), B(a[0], "html") || (d = a.offset()), d = {
	               top: d.top + r.css(a[0], "borderTopWidth", !0),
	               left: d.left + r.css(a[0], "borderLeftWidth", !0)
	            }), {
	               top: b.top - d.top - r.css(c, "marginTop", !0),
	               left: b.left - d.left - r.css(c, "marginLeft", !0)
	            }
	         }
	      },
	      offsetParent: function() {
	         return this.map(function() {
	            var a = this.offsetParent;
	            while (a && "static" === r.css(a, "position")) a = a.offsetParent;
	            return a || ra
	         })
	      }
	   }), r.each({
	      scrollLeft: "pageXOffset",
	      scrollTop: "pageYOffset"
	   }, function(a, b) {
	      var c = "pageYOffset" === b;
	      r.fn[a] = function(d) {
	         return T(this, function(a, d, e) {
	            var f;
	            return r.isWindow(a) ? f = a : 9 === a.nodeType && (f = a.defaultView), void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
	         }, a, d, arguments.length)
	      }
	   }), r.each(["top", "left"], function(a, b) {
	      r.cssHooks[b] = Pa(o.pixelPosition, function(a, c) {
	         if (c) return c = Oa(a, b), Ma.test(c) ? r(a).position()[b] + "px" : c
	      })
	   }), r.each({
	      Height: "height",
	      Width: "width"
	   }, function(a, b) {
	      r.each({
	         padding: "inner" + a,
	         content: b,
	         "": "outer" + a
	      }, function(c, d) {
	         r.fn[d] = function(e, f) {
	            var g = arguments.length && (c || "boolean" != typeof e),
	               h = c || (e === !0 || f === !0 ? "margin" : "border");
	            return T(this, function(b, c, e) {
	               var f;
	               return r.isWindow(b) ? 0 === d.indexOf("outer") ? b["inner" + a] : b.document.documentElement["client" + a] : 9 === b.nodeType ? (f = b.documentElement, Math.max(b.body["scroll" + a], f["scroll" + a], b.body["offset" + a], f["offset" + a], f["client" + a])) : void 0 === e ? r.css(b, c, h) : r.style(b, c, e, h)
	            }, b, g ? e : void 0, g)
	         }
	      })
	   }), r.fn.extend({
	      bind: function(a, b, c) {
	         return this.on(a, null, b, c)
	      },
	      unbind: function(a, b) {
	         return this.off(a, null, b)
	      },
	      delegate: function(a, b, c, d) {
	         return this.on(b, a, c, d)
	      },
	      undelegate: function(a, b, c) {
	         return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
	      }
	   }), r.holdReady = function(a) {
	      a ? r.readyWait++ : r.ready(!0)
	   }, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "function" == "function" && __webpack_require__(3) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return r
	   }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	   var Vb = a.jQuery,
	      Wb = a.$;
	   return r.noConflict = function(b) {
	      return a.$ === r && (a.$ = Wb), b && a.jQuery === r && (a.jQuery = Vb), r
	   }, b || (a.jQuery = a.$ = r), r
	});
	jQuery.fn.momentus = function(cfg) {
	   var now = Date.now ||
	   function() {
	      return (new Date).valueOf()
	   }, start_point = {
	      x: 0,
	      y: 0
	   }, last_point = {
	      x: 0,
	      y: 0
	   }, current_coords = {
	      x: 0,
	      y: 0
	   }, last_coords = {
	      x: 0,
	      y: 0
	   }, velocity = {
	      x: 0,
	      y: 0
	   }, last_time = now(), inertia_time = last_time, mass = cfg.mass || 1e3, u = cfg.u || 4, wheel_ratio = cfg.wheelRatio || 1e3, mouse_ratio = cfg.mouseRatio || 20, touch_ratio = cfg.touchRatio || 2, on_change = cfg.onChange ||
	   function() {}, frame_rate = cfg.frameRate || 60;

	   function calculateVelocity(e) {
	      var time = now(),
	         delta_time = time - last_time,
	         vel_x = velocity.x + last_coords.x / delta_time / (e.pageX ? mouse_ratio : touch_ratio),
	         vel_y = velocity.y + last_coords.y / delta_time / (e.pageY ? mouse_ratio : touch_ratio);
	      vel_x = !isNaN(vel_x) ? vel_x : 0;
	      vel_y = !isNaN(vel_y) ? vel_y : 0;
	      return {
	         x: vel_x,
	         y: vel_y
	      }
	   }
	   var self = this;
	   $(this).on("mousedown touchstart", function(e) {
	      e.preventDefault();
	      var x = e.pageX || e.originalEvent.touches[0].pageX,
	         y = e.pageY || e.originalEvent.touches[0].pageY;
	      last_coords = {
	         x: 0,
	         y: 0
	      };
	      start_point = {
	         x: x,
	         y: y
	      };
	      velocity = {
	         x: 0,
	         y: 0
	      };
	      on_change(current_coords, velocity);
	      $("body").on("mousemove touchmove", function(e) {
	         e.preventDefault();
	         var vel = calculateVelocity(e);
	         last_time = now();
	         var x = e.pageX || e.originalEvent.touches[0].pageX,
	            y = e.pageY || e.originalEvent.touches[0].pageY,
	            delta_x = x - start_point.x,
	            delta_y = y - start_point.y;
	         last_point = start_point;
	         start_point = {
	            x: x,
	            y: y
	         };
	         last_coords.x = delta_x;
	         last_coords.y = delta_y;
	         current_coords.x += delta_x;
	         current_coords.y += delta_y;
	         on_change(current_coords, vel);
	         $(self).trigger("mousewheel")
	      });
	      $("body").on("mouseup touchend", function(e) {
	         velocity = calculateVelocity(e);
	         on_change(current_coords, velocity);
	         inertia_time = null;
	         $("body").off("mousemove touchmove mouseup touchend")
	      })
	   });
	   $(this).on("wheel mousewheel", function(e) {
	      if (velocity.x == 0 && velocity.y == 0) inertia_time = now();
	      var delta_x, delta_y;
	      if (e.originalEvent) {
	         delta_x = e.originalEvent.deltaX || 0, delta_y = e.originalEvent.deltaY || 0
	      } else {
	         delta_x = 0, delta_y = 0
	      }
	      velocity.x -= delta_x / wheel_ratio;
	      velocity.y -= delta_y / wheel_ratio
	   });
	   (function inertia() {
	      velocity.x = !isNaN(velocity.x) ? velocity.x : 0;
	      velocity.y = !isNaN(velocity.y) ? velocity.y : 0;
	      if (!inertia_time) {
	         inertia_time = now()
	      } else if (velocity.x != 0 || velocity.y != 0) {
	         var time = now(),
	            force_x = velocity.x * u,
	            force_y = velocity.y * u,
	            acc_x = force_x / mass,
	            acc_y = force_y / mass,
	            delta_time = time - inertia_time,
	            vel_x = velocity.x - acc_x * delta_time,
	            vel_y = velocity.y - acc_y * delta_time;
	         vel_x = !isNaN(vel_x) ? vel_x : 0;
	         vel_y = !isNaN(vel_y) ? vel_y : 0;
	         velocity.x = vel_x;
	         velocity.y = vel_y;
	         var delta_x = vel_x * delta_time,
	            delta_y = vel_y * delta_time;
	         last_coords.x = current_coords.x;
	         last_coords.y = current_coords.y;
	         current_coords.x += delta_x;
	         current_coords.y += delta_y;
	         inertia_time = time;
	         on_change(current_coords, velocity)
	      }
	      if (window.requestAnimationFrame) {
	         requestAnimationFrame(inertia)
	      } else {
	         setTimeout(inertia, 1e3 / frame_rate)
	      }
	   })();
	   return this
	};
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var createScollSensor = function(wrapper) {
	      var scrollSensor = document.createElement("div");
	      if (!wrapper) wrapper = document.body;
	      scrollSensor.className = "kfa-scroll-sensor";
	      scrollSensor.style.cssText = "position:absolute;width:100%;height:100%;z-index:2;top:0";
	      wrapper.appendChild(scrollSensor);
	      return scrollSensor
	   };
	var createLoadingText = function(wrapper) {
	      var splash = document.createElement("div");
	      splash.className = "kfa-splash";
	      var text = document.createElement("div");
	      text.className = "splash-text";
	      text.innerText = "LOADING";
	      var percentage = document.createElement("div");
	      percentage.className = "splash-percentage";
	      splash.appendChild(text);
	      splash.appendChild(percentage);
	      if (!wrapper) wrapper = document.body;
	      wrapper.appendChild(splash);
	      return [splash, percentage]
	   };
	var createAudio = function(url) {
	      var audio = new Audio;
	      audio.src = url;
	      audio.setAttribute("preload", true);
	      audio.loop = true;
	      return audio
	   };

	function audioPlay(audio) {
	   var isMob = isMobile();
	   var playAuido = function() {
	         audio.play();
	         document.body.removeEventListener("touchstart", playAuido);
	      };
	   if (isMob) {
	      document.body.addEventListener("touchstart", playAuido)
	   } else {
	      audio.play()
	   }
	}
	function isMobile() {
	   var isMob = false;
	   if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0, 4))) isMob = true;
	   return isMob
	}
	function getParam(progress) {
	   //console.log('=======', progress);
	   var isMob = isMobile();
	   var isOpera = !! window.opr && !! opr.addons || !! window.opera || navigator.userAgent.indexOf(" OPR/") >= 0;
	   var isFirefox = typeof InstallTrigger !== "undefined";
	   var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0;
	   var isIE = false || !! document.documentMode;
	   var isEdge = !isIE && !! window.StyleMedia;
	   var isChrome = !! window.chrome && !! window.chrome.webstore;
	   var isBlink = (isChrome || isOpera) && !! window.CSS;
	   if (!isMob) {
	      if (isFirefox) {
	         return progress.toFixed(2) * -.1
	      }
	      return progress.toFixed(2) * -.01
	   } else {
	      //console.log('-------', progress);
	      if (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i)) {
	         return progress.toFixed(2) * -.005
	      }
	      return progress.toFixed(2) * -.01
	   }
	}
	function climp(n, min, max) {
	   if (n < min) {
	      return min
	   } else if (n > max) {
	      return max
	   } else {
	      return n
	   }
	}
	function KFASwiper(config) {
	   if (!Detector.webgl) Detector.addGetWebGLMessage();
	   var renderer;
	   var container;
	   var loader = new THREE.ColladaLoader;
	   var defaultCameraFov = 70;
	   var defaultCameraNear = 10;
	   var defaultCameraFar = 6e3;
	   var loadingText = config.loading_text || true;
	   var timeScale = config.time_scale || .5;
	   var textureLoadingCallback = config.on_texture_loading;
	   var textureLoadedCallback = config.on_texture_loaded;
	   var modelLoadedCallback = config.on_model_loaded;
	   var progressCallback = config.on_chapter_progress;
	   var scrollCallback = config.onscroll;
	   var wrapper = config.wrapper;
	   var scrollSensor = createScollSensor();
	   var eles = createLoadingText();
	   var percentage = eles[1],
	      splash = eles[0];
	   var timeStampControl = config.control === "timestamp" ? true : false;
	   if (timeStampControl) {
	      var clock = new THREE.Clock
	   }
	   var chapters = config.chapters;
	   var currentChapterIndex = 0;
	   var currentChapter = null;
	   var chapterLength = chapters.length;
	   var isMob = isMobile();
	   var self = this;

	   function initRenderer(callback) {
	      container = document.createElement("div");
	      wrapper.appendChild(container);
	      container.className = "chapter";
	      renderer = new THREE.WebGLRenderer({
	         antialias: true,
	         alpha: true,
	         logarithmicDepthBuffer: true
	      });
	      //renderer.setPixelRatio(window.devicePixelRatio);
	      renderer.setSize(window.innerWidth, window.innerHeight);
	      container.appendChild(renderer.domElement);
	      if (callback) callback.call()
	   }
	   function initScene(chapter, callback) {
	      var scene = new THREE.Scene;
	      chapter.kfAnimations = [];
	      var longestAnimationLength = 0;
	      for (var i = 0; i < chapter.kfAnimationsLength; ++i) {
	         var animation = chapter.animations[i];
	         var kfAnimation = new THREE.KeyFrameAnimation(animation);
	         kfAnimation.loop = false;
	         kfAnimation.timeScale = timeScale;
	         chapter.kfAnimations.push(kfAnimation);
	         if (animation.length > longestAnimationLength) {
	            chapter.benchmarkAnimation = kfAnimation;
	            longestAnimationLength = animation.length
	         }
	      }
	      scene.add(chapter.model);
	      var light = new THREE.AmbientLight(16777215);
	      light.name = "scene-ambient-light";
	      scene.add(light);
	      chapter.model.traverse(function(child) {
	         if (child instanceof THREE.PerspectiveCamera) {
	            var camera = child;
	            camera.fov = chapter.camera_fov || defaultCameraFov;
	            camera.far = chapter.camera_far || defaultCameraFar;
	            camera.near = chapter.camera_near || defaultCameraNear;
	            chapter.camera = camera;
	            camera.aspect = windowHalfX / windowHalfY;
	            camera.updateProjectionMatrix()
	         }
	      });
	      if (chapter.camera === undefined) {
	         chapter.camera = new THREE.PerspectiveCamera(chapter.camera_fov, window.innerWidth / window.innerHeight, chapter.camera_near, chapter.camera_far);
	         chapter.camera.name = "mycamera"
	      }
	      chapter.scene = scene;
	      if (chapter.audio_file) {
	         var audio = createAudio(chapter.audio_file);
	         chapter.audio = audio
	      }
	      if (callback) callback.call()
	   }
	   function start() {
	      for (var i = 0; i < currentChapter.kfAnimationsLength; ++i) {
	         var animation = currentChapter.kfAnimations[i];
	         for (var h = 0, hl = animation.hierarchy.length; h < hl; h++) {
	            var keys = animation.data.hierarchy[h].keys;
	            var sids = animation.data.hierarchy[h].sids;
	            var obj = animation.hierarchy[h];
	            if (keys.length && sids) {
	               for (var s = 0; s < sids.length; s++) {
	                  var sid = sids[s];
	                  var next = animation.getNextKeyWith(sid, h, 0);
	                  if (next) next.apply(sid)
	               }
	               obj.matrixAutoUpdate = false;
	               animation.data.hierarchy[h].node.updateMatrix();
	               obj.matrixWorldNeedsUpdate = true
	            }
	         }
	         animation.play()
	      }
	      update(0)
	   }
	   function update(deltaY) {
	      /*if (timeStampControl) {
	         var deltaY = clock.getDelta()
	      }
	      if (chapterChanging) {
	         return
	      }*/
	      console.log('%%%%%%%%%%%%', deltaY)
	      if (Math.abs(deltaY) > 10) return;
	      var current = currentChapter.benchmarkAnimation.currentTime;
	      console.log(current)
	      var length = currentChapter.benchmarkAnimation.data.length;
	      var deltaFrameTime = 0;
	      var deltaFrameTime = climp(deltaY, 0 - current, currentChapter.benchmarkAnimation.data.length - current);
	      console.log('++++++++',deltaFrameTime)
	      console.log(currentChapter.benchmarkAnimation)
	      currentChapter.benchmarkAnimation.update(deltaFrameTime);
	      for (var i = 0; i < currentChapter.kfAnimationsLength; ++i) {
	         if (current < currentChapter.kfAnimations[i].data.length) {
	            currentChapter.kfAnimations[i].currentTime = currentChapter.benchmarkAnimation.currentTime;
	            currentChapter.kfAnimations[i].update(0)
	         }
	      }
	      startAnimation();
	      renderer.render(currentChapter.scene, currentChapter.camera)
	   }
	   var initialized = false;
	   var requestId;

	   function loop() {
	      requestId = window.requestAnimationFrame(tempReq)
	   }
	   function startAnimation() {
	      if (!requestId && !initialized) {
	         initialized = true;
	         loop()
	      }
	   }
	   function stopAnimation() {
	      if (requestId) {
	         window.cancelAnimationFrame(requestId);
	         requestId = undefined
	      }
	   }
	   var tempReq = function() {
	         update(0);
	         loop()
	      };

	   function bindEventListeners() {
	      var lastTimestamp = 0;
	      $(scrollSensor).momentus({
	         onChange: function(coords) {
	            stopAnimation();
	            var progress = coords.y - lastTimestamp;
	            var param = getParam(progress);

	            update(param);
	            if (scrollCallback) {
	               scrollCallback.call(window, coords.y)
	            }
	            if (progressCallback) {
	               progressCallback.call(window, currentChapterIndex, currentChapter.benchmarkAnimation.currentTime)
	            }
	            lastTimestamp = coords.y
	         }
	      })
	   }
	   function loadModel(chapter, callback) {
	      var self = this;
	      var modelPath = chapter.model_path;
	      var texturePath = chapter.texture_path;
	      var textureDict = chapter.texture_dict;
	      loader.load(modelPath, function(collada) {
	         var model = collada.scene;
	         chapter.animations = collada.animations;
	         chapter.kfAnimationsLength = collada.animations.length;
	         chapter.model = model;
	         model.scale.x = model.scale.y = model.scale.z = .1;
	         if (texturePath) {
	            var manager = new THREE.LoadingManager;
	            manager.onProgress = function(item, loaded, total) {
	               if (loadingText && loadedIndex === 0) {
	                  percentage.innerText = 50 + parseInt(loaded / total * 100 / 2)
	               }
	               textureLoadingCallback.call(window, item, loaded, total)
	            };
	            manager.onLoad = function() {
	               hideSpalsh();
	               textureLoadedCallback.call(window)
	            };
	            var loader = new THREE.ImageLoader(manager);
	            loader.crossOrigin = true;
	            var children = collada.scene.children || [];
	            processArray(children);

	            function processArray(array) {
	               var forbiddenNames = ["Light", "Plane", "Camera", "Nullo"];
	               var transparent = [];
	               for (var i = 0; i < array.length; i++) {
	                  var name = array[i].name.toLowerCase();
	                  if ($.inArray(name, forbiddenNames) < 0) {
	                     var object = array[i];
	                     if (name.indexOf("group") > -1) {
	                        processArray(object.children || [])
	                     } else {
	                        if (name) {
	                           loadAlpha(name, object)
	                        }
	                     }
	                  }
	                  if ($.inArray(name, transparent) >= 0) {
	                     var object = model.getObjectByName(name, true)
	                  }
	               }
	            }
	            function loadAlpha(name, object) {
	               var mesh = object.children[0];
	               if (mesh instanceof THREE.Mesh) {
	                  var material = mesh.material;
	                  var texture_img = textureDict[material.name];
	                  if (!texture_img) return;
	                  var file = texturePath + texture_img,
	                     alpha = new THREE.Texture;
	                  material.map = alpha;
	                  material.transparent = true;
	                  material.side = THREE.DoubleSide;
	                  loader.load(file, function(image) {
	                     alpha.image = image;
	                     alpha.needsUpdate = true
	                  })
	               }
	            }
	            function applyTransparency(name, object) {
	               var material = object.children[0].material;
	               material.opacity = .5
	            }
	         } else {
	            hideSpalsh()
	         }
	         callback.call()
	      }, function(request) {
	         var perc = parseInt(request.loaded / request.total * 100 / 2);
	         if (!isNaN(perc) && loadingText && loadedIndex === 0) {
	            percentage.innerText = perc
	         }
	         if (modelLoadedCallback) {
	            modelLoadedCallback.call(window, request)
	         }
	      })
	   }
	   function hideSpalsh() {
	      splash.style.opacity = 0;
	      splash.style.backgroundColor = "transparent";
	      splash.style.pointerEvents = "none"
	   }
	   window.addEventListener("resize", onWindowResize, false);

	   function onWindowResize() {
	      currentChapter.camera.aspect = windowHalfX / windowHalfY;
	      currentChapter.camera.updateProjectionMatrix();
	      renderer.setSize(window.innerWidth, window.innerHeight)
	   }
	   function onDocumentMouseMove(event) {
	      mouseX = event.clientX - windowHalfX;
	      mouseY = event.clientY - windowHalfY
	   }
	   var chapterChanging = false;

	   function playNextChapter(midCallback, callback) {
	      if (chapterChanging) return;
	      if (currentChapterIndex === chapterLength - 1) return;
	      chapterChanging = true;
	      stopAnimation();
	      loadNextChapter();
	      delete currentChapter.scene;
	      $(wrapper).fadeOut(600, function() {
	         if (currentChapter.audio) currentChapter.audio.pause();
	         currentChapterIndex += 1;
	         self.currentChapter = currentChapter = chapters[currentChapterIndex];
	         if (currentChapter.bgcolor !== undefined) {
	            renderer.setClearColor(currentChapter.bgcolor, 1)
	         }
	         if (currentChapter.audio) audioPlay(currentChapter.audio);
	         midCallback.call();
	         if (timeStampControl) clock.getDelta();
	         chapterChanging = false;
	         start();
	         $(wrapper).fadeIn(1e3, function() {
	            callback.call()
	         })
	      })
	   }
	   var loadedIndex = 0;

	   function loadNextChapter() {
	      loadedIndex += 1;
	      if (loadedIndex === chapterLength) return;
	      loadModel(chapters[loadedIndex], function() {
	         initScene(chapters[loadedIndex])
	      })
	   }
	   initRenderer();
	   loadModel(chapters[0], function() {
	      self.currentChapter = currentChapter = chapters[0];
	      if (currentChapter.bgcolor !== undefined) {
	         renderer.setClearColor(currentChapter.bgcolor, 1)
	      }
	      initScene(chapters[0], function() {
	         if (currentChapter.audio) audioPlay(currentChapter.audio);
	         window.scene = currentChapter.scene;
	         start();
	         bindEventListeners()
	      })
	   });
	   self.playNextChapter = playNextChapter;
	   self.renderer = renderer
	}(function(window) {
	   var Navigator = function() {
	         var frame, androidReg = /Android/gi,
	            isAndroid = androidReg.test(navigator.platform) || androidReg.test(navigator.userAgent);
	         frame = null;

	         function getFrame(src) {
	            var _frame = document.createElement("iframe");
	            _frame.setAttribute("style", "display:none;width:0;height:0;position: absolute;top:0;left:0;border:0;");
	            _frame.setAttribute("height", "0px");
	            _frame.setAttribute("width", "0px");
	            _frame.setAttribute("frameborder", "0");
	            if (src) {
	               _frame.setAttribute("src", src)
	            } else {
	               document.documentElement.appendChild(_frame)
	            }
	            return _frame
	         }
	         function removeFrame(frame) {
	            frame && frame.parentNode.removeChild(frame)
	         }
	         function protocol(command, single, noframe) {
	            var _frame, timer;
	            if (noframe) {
	               window.location.href = command;
	               return
	            }
	            if (single) {
	               if (isAndroid) {
	                  _frame = getFrame();
	                  _frame.setAttribute("src", command)
	               } else {
	                  _frame = getFrame(command);
	                  document.documentElement.appendChild(_frame)
	               }
	               timer = setTimeout(function() {
	                  _frame && removeFrame(_frame)
	               }, 3e4);
	               _frame.onload = _frame.onreadystatechange = function() {
	                  timer && clearTimeout(timer);
	                  _frame && removeFrame(_frame)
	               }
	            } else {
	               frame = frame || getFrame();
	               frame.setAttribute("src", command)
	            }
	         }
	         return {
	            protocol: protocol
	         }
	      }();

	   function NewsApp(protocolHandler) {
	      var emptyFn = function() {},
	         newsAppUA = /NewsApp/gi.test(navigator.userAgent),
	         androidReg = /Android/gi,
	         debug = false,
	         isAndroid = androidReg.test(navigator.platform) || androidReg.test(navigator.userAgent),
	         Callbacks, Protocols;
	      Callbacks = {
	         afterEncrypt: emptyFn,
	         afterShare: emptyFn,
	         afterUserinfo: emptyFn,
	         afterLogin: emptyFn,
	         afterDevice: emptyFn,
	         afterUploadImage: emptyFn,
	         afterComment: emptyFn,
	         afterOtherappinfo: emptyFn,
	         afterActionbutton: emptyFn,
	         afterAddAlarm: emptyFn,
	         afterRemoveAlarm: emptyFn,
	         afterCheckAlarm: emptyFn,
	         afterTrashId: emptyFn,
	         afterLocation: emptyFn
	      };
	      Protocols = {
	         share: "share://",
	         updateprofile: "updateprofile://",
	         encrypt: "encrypt://",
	         pushview: "pushview://{TYPE}",
	         userinfo: "userinfo://",
	         login: "login://",
	         device: "device://",
	         uploadImageByCamera: "uploadimage://camera/{W}_{H}",
	         uploadImageByAlbum: "uploadimage://album/{W}_{H}",
	         openComment: "newsapp://comment/{BOARD_ID}/{DOC_ID}/{TITLE}",
	         comment: "comment://",
	         otherappinfo: isAndroid ? "otherappinfo://" : "otherappinfo://intent/",
	         copy: "copy://",
	         toolbar: "docmode://toolbar/{COMMAND}",
	         modifytitle: "docmode://modifytitle/{TITLE}",
	         actionbutton: "docmode://actionbutton/{NAME}",
	         addAlarm: "alarm://add",
	         removeAlarm: "alarm://remove",
	         checkAlarm: "alarm://check",
	         trashid: "trashid://",
	         location: "location://current"
	      };

	      function enableDebug() {
	         debug = true
	      }
	      function isNewsApp() {
	         return newsAppUA || debug
	      }
	      function protocol(action, callback) {
	         protocolHandler(action, true);
	         if (debug && callback) {
	            var _data = action.match(/[\w]:\/\/(.*)/);
	            callback(_data && _data[1])
	         }
	      }
	      function afterCallback(rs, type) {
	         if (Callbacks[type]) {
	            Callbacks[type](rs);
	            Callbacks[type] = emptyFn
	         }
	      }
	      window.__newsapp_share_done = function(rs) {
	         afterCallback(rs, "afterShare")
	      };
	      window.__newsapp_encrypt_done = function(rs) {
	         afterCallback(rs, "afterEncrypt")
	      };
	      window.__newsapp_userinfo_done = function(rs) {
	         afterCallback(rs, "afterUserinfo")
	      };
	      window.__newsapp_login_done = function(rs) {
	         afterCallback(rs, "afterLogin")
	      };
	      window.__newsapp_device_done = function(rs) {
	         afterCallback(rs, "afterDevice")
	      };
	      window.__newsapp_upload_image_done = function(rs) {
	         afterCallback(rs, "afterUploadImage")
	      };
	      window.__newsapp_comment_done = function(rs) {
	         afterCallback(rs, "afterComment")
	      };
	      window.__newsapp_otherappinfo_done = function(rs) {
	         afterCallback(rs, "afterOtherappinfo")
	      };
	      window.__newsapp_browser_actionbutton = function(rs) {
	         afterCallback(rs, "afterActionbutton")
	      };
	      window.__newsapp_alarm_add_done = function(rs) {
	         afterCallback(rs, "afterAddAlarm")
	      };
	      window.__newsapp_alarm_remove_done = function(rs) {
	         afterCallback(rs, "afterRemoveAlarm")
	      };
	      window.__newsapp_alarm_check_done = function(rs) {
	         afterCallback(rs, "afterCheckAlarm")
	      };
	      window.__newsapp_trashid_done = function(rs) {
	         afterCallback(rs, "afterTrashId")
	      };
	      window.__newsapp_location_done = function(rs) {
	         afterCallback(rs, "afterLocation")
	      };

	      function updateProfile() {
	         protocol(Protocols.updateprofile)
	      }
	      function login(callback) {
	         Callbacks.afterLogin = callback;
	         protocol(Protocols.login, callback)
	      }
	      function userInfo(callback) {
	         Callbacks.afterUserinfo = callback;
	         protocol(Protocols.userinfo, callback)
	      }
	      function device(callback) {
	         Callbacks.afterDevice = callback;
	         protocol(Protocols.device, callback)
	      }
	      function share(callback) {
	         Callbacks.afterShare = callback;
	         protocol(Protocols.share, callback)
	      }
	      function pushView(type) {
	         protocol(Protocols.pushview.replace("{TYPE}", type))
	      }
	      function encrypt(data, callback) {
	         Callbacks.afterEncrypt = callback;
	         if (window.extra && window.extra.__newsapp_encrypt) {
	            afterCallback(window.extra.__newsapp_encrypt(data), "afterEncrypt")
	         } else {
	            protocol(Protocols.encrypt + encodeURIComponent(data), callback)
	         }
	      }
	      function uploadImageByCamera(width, height, callback) {
	         Callbacks.afterUploadImage = callback;
	         protocol(Protocols.uploadImageByCamera.replace("{W}", width).replace("{H}", height), callback)
	      }
	      function uploadImageByAlbum(width, height, callback) {
	         Callbacks.afterUploadImage = callback;
	         protocol(Protocols.uploadImageByAlbum.replace("{W}", width).replace("{H}", height), callback)
	      }
	      function openComment(boardid, docid, title) {
	         protocol(Protocols.openComment.replace("{BOARD_ID}", boardid).replace("{DOC_ID}", docid).replace("{TITLE}", title || ""))
	      }
	      function comment(callback) {
	         Callbacks.afterComment = callback;
	         protocol(Protocols.comment, callback)
	      }
	      function otherappinfo(id, callback) {
	         Callbacks.afterOtherappinfo = callback;
	         protocol(Protocols.otherappinfo + id, callback)
	      }
	      function copy(text) {
	         protocol(Protocols.copy + text)
	      }
	      function toolbar(command) {
	         protocol(Protocols.toolbar.replace("{COMMAND}", command))
	      }
	      function modifytitle(title) {
	         document.title = title || document.title;
	         protocol(Protocols.modifytitle.replace("{TITLE}", encodeURIComponent(title)))
	      }
	      function actionbutton(name, callback) {
	         Callbacks.afterActionbutton = callback;
	         protocol(Protocols.actionbutton.replace("{NAME}", encodeURIComponent(name)), callback)
	      }
	      function addAlarm(callback) {
	         Callbacks.afterAddAlarm = callback;
	         if (window.extra && window.extra.__newsapp_alarm_add_done) {
	            afterCallback(window.extra.__newsapp_alarm_add_done(), "afterAddAlarm")
	         } else {
	            protocol(Protocols.addAlarm, callback)
	         }
	      }
	      function removeAlarm(callback) {
	         Callbacks.afterRemoveAlarm = callback;
	         if (window.extra && window.extra.__newsapp_alarm_remove_done) {
	            afterCallback(window.extra.__newsapp_alarm_remove_done(), "afterRemoveAlarm")
	         } else {
	            protocol(Protocols.removeAlarm, callback)
	         }
	      }
	      function checkAlarm(callback) {
	         Callbacks.afterCheckAlarm = callback;
	         if (window.extra && window.extra.__newsapp_alarm_check_done) {
	            afterCallback(window.extra.__newsapp_alarm_check_done(), "afterCheckAlarm")
	         } else {
	            protocol(Protocols.checkAlarm, callback)
	         }
	      }
	      function trashId(callback) {
	         Callbacks.afterTrashId = callback;
	         protocol(Protocols.trashid, callback)
	      }
	      function location(callback) {
	         Callbacks.afterLocation = callback;
	         protocol(Protocols.location, callback)
	      }
	      return {
	         isNewsApp: isNewsApp,
	         login: login,
	         userInfo: userInfo,
	         device: device,
	         share: share,
	         encrypt: encrypt,
	         updateProfile: updateProfile,
	         uploadImageByCamera: uploadImageByCamera,
	         uploadImageByAlbum: uploadImageByAlbum,
	         pushView: pushView,
	         openComment: openComment,
	         comment: comment,
	         otherappinfo: otherappinfo,
	         copy: copy,
	         toolbar: toolbar,
	         modifytitle: modifytitle,
	         actionbutton: actionbutton,
	         enableDebug: enableDebug,
	         addAlarm: addAlarm,
	         removeAlarm: removeAlarm,
	         checkAlarm: checkAlarm,
	         trashId: trashId,
	         location: location,
	         protocol: protocol,
	         Callbacks: Callbacks
	      }
	   }
	   window.NewsAppClient = NewsApp(Navigator.protocol)
	})(window);
	var isWeixin = /MicroMessenger/gi.test(navigator.userAgent),
	   isNewsApp = /NewsApp/gi.test(navigator.userAgent);
	var msgop = $(".message-op"),
	   msgmsn = $(".message-msn");
	var msg = [$(".message-0"), $(".message-1"), $(".message-2"), $(".message-3"), $(".message-4")];
	var search = localParam().search;
	var chapterIndex = search.chapter ? parseInt(search.chapter) : 0;
	if (document.referrer === "") {
	   chapterIndex = 0
	}
	if (chapterIndex > 0) {
	   msgop.hide()
	}
	function localParam(search, hash) {
	   search = search || window.location.search;
	   hash = hash || window.location.hash;
	   var fn = function(str, reg) {
	         if (str) {
	            var data = {};
	            str.replace(reg, function($0, $1, $2, $3) {
	               data[$1] = $3
	            });
	            return data
	         }
	      };
	   return {
	      search: fn(search, new RegExp("([^?=&]+)(=([^&]*))?", "g")) || {},
	      hash: fn(hash, new RegExp("([^#=&]+)(=([^&]*))?", "g")) || {}
	   }
	}
	var msnzs_dict = {
	   ".28": "JWY.png",
	   ".49": "qiao.png",
	   ".48": "cemian.png",
	   ".47": "cat3.png",
	   ".46": "cat2.png",
	   ".45": "cat.png",
	   ".44": "final.jpg",
	   ".42": "television.png",
	   ".40": "window-b.png",
	   ".39": "window-e.png",
	   ".38": "window-d.png",
	   ".37": "window-c.png",
	   ".36": "yelifujiamian.png",
	   ".35": "1.png",
	   ".34": "2.png",
	   ".33": "3.png",
	   ".32": "4.png",
	   ".31": "5.png",
	   ".30": "window-a.png",
	   ".29": "girl1.png",
	   ".27": "ju.png",
	   ".26": "hy.png",
	   ".25": "fsngz.png",
	   ".24": "window-a.png",
	   ".23": "fr.png",
	   ".22": "fangzi02.png",
	   ".21": "fangiz2.png",
	   ".20": "fangiz.png",
	   ".19": "de.png",
	   ".18": "aq.png",
	   ".17": "koloop.png",
	   ".16": "safeloop.png",
	   ".15": "tgloop.png",
	   ".14": "rt.png",
	   ".13": "up.png",
	   ".12": "mid.png",
	   ".11": "fr1.png",
	   ".10": "uj1.png",
	   ".9": "ij1.png",
	   ".8": "mendong2_1.png",
	   ".6": "mendongce.png",
	   ".5": "mendong1.png",
	   ".4": "tingzi1.png",
	   ".2": "word.png",
	   "2333": "fangziaaloop.png",
	   a_pillars: "pillarsloop_1.png",
	   a_stars: "starsloop.png",
	   a_inside: "Inside.png",
	   "": "xingxing.png"
	};
	var hyrz_dict = {
	   ".7": "bagua3.png",
	   ".6": "woailuo2.png",
	   ".5": "woailuo1.png",
	   ".4": "wuya2.png",
	   ".3": "wuya3.png",
	   ".2": "wuya1.png",
	   ".1": "mingren1.png",
	   "": "mingrenti.png",
	   background7: "background7.png",
	   background6: "background6.png",
	   background5: "background5.png",
	   background4: "background4.png",
	   background3: "background3.png",
	   background2: "background2.png",
	   mingren4: "mingren4.png",
	   mingren3: "mingren3.png",
	   mingren2: "mingren2.png",
	   mingren1: "mingren1.png",
	   xiaoying: "xiaoying.png",
	   woailuo: "woailuogai.png",
	   zuozhu: "zuozhu.png",
	   kakaxi: "kakaxi.png",
	   yuzhiboyou: "yuzhiboyou.png",
	   chutian: "chutian.png",
	   background1: "background1.png"
	};
	var duola_dict = {
	   ".27": "yun03.png",
	   ".26": "yun01.png",
	   ".25": "xiaofu.png",
	   ".24": "panghu.png",
	   ".23": "jingxiang.png",
	   ".22": "daxiong.png",
	   ".21": "dingdang.png",
	   ".20": "duola.png",
	   ".19": "5.png",
	   ".18": "4.png",
	   ".17": "2.png",
	   ".16": "1.png",
	   ".15": "5-5.png",
	   ".14": "4-4.png",
	   ".13": "3-3.png",
	   ".12": "2-2.png",
	   ".11": "1-1.png",
	   ".10": "daduola2_1.png",
	   ".9": "door2.png",
	   ".8": "door.png",
	   ".7": "xian8.png",
	   ".6": "xian7.png",
	   ".5": "xian6.png",
	   ".4": "xian5.png",
	   ".3": "xian4.png",
	   ".2": "xian3.png",
	   ".1": "xian2.png",
	   "": "xian1.png"
	};
	var conan_dict = {
	   ".24": "di2.png",
	   ".23": "di1.png",
	   ".22": "jingshitingda.png",
	   ".21": "dingdang.png",
	   ".20": "zhao8.png",
	   ".19": "zhao7.png",
	   ".18": "zhaopian6.png",
	   ".17": "zhao6.png",
	   ".16": "zhao5.png",
	   ".15": "zhaopian3.png",
	   ".14": "zhao4.png",
	   ".13": "zhao3.png",
	   ".12": "dipian.png",
	   ".11": "zhaopian2.png",
	   ".10": "zhao2.png",
	   ".9": "zhao1.png",
	   ".8": "zhaopian1.png",
	   ".6": "05.png",
	   ".5": "03.png",
	   ".4": "02.png",
	   ".2": "01.png",
	   "": "jingshiting.png",
	   ".1": "zhedang2.png"
	};
	var gngs_dict = {
	   ".35": "liuchuanfeng-b.png",
	   ".34": "liuchuanfeng-a.png",
	   ".33": "yingmu-a.png",
	   ".32": "liuchuanfeng-b.png",
	   ".31": "chimu-a.png",
	   ".30": "chimu-b.png",
	   ".29": "yingmu-b.png",
	   ".2": "basketball.png",
	   ".28": "bj6.png",
	   ".27": "bj5.png",
	   ".26": "bj4.png",
	   ".25": "bj3.png",
	   ".24": "bj2.png",
	   ".23": "bj1.png",
	   ".22": "lcb2.png",
	   ".21": "lcb1.png",
	   ".20": "cms.png",
	   ".19": "liuchuangfeng-qiu.png",
	   ".18": "7.png",
	   ".17": "6.png",
	   ".16": "5_1.png",
	   ".15": "4_1.png",
	   ".14": "3.png",
	   ".13": "1_1.png",
	   ".12": "yingmuq.png",
	   ".11": "sanjing.png",
	   ".10": "sanbei2.png",
	   ".9": "sanbei1.png",
	   ".8": "cmq.png",
	   ".7": ".png",
	   ".6": "gb3.png",
	   ".5": "gb2.png",
	   ".4": "gb1.png",
	   ".3": "gc.png",
	   ".1": "2_1.png"
	};
	var chapters = [{
	   model_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/gngs.js",
	   texture_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/texture/gngs/",
	   audio_file: "http://c.m.163.com/nc/qa/activity/kfa-swiper/events/childrens-day-2017/asset/mp3/gngs_bgm.mp3",
	   texture_dict: gngs_dict,
	   camera_fov: 80,
	   camera_far: 8e3,
	   bgcolor: 15658734,
	   length: 24
	}, {
	   model_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/conan.js",
	   texture_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/texture/conan/",
	   audio_file: "http://c.m.163.com/nc/qa/activity/kfa-swiper/events/childrens-day-2017/asset/mp3/conan_bgm.mp3",
	   texture_dict: conan_dict,
	   camera_fov: 70,
	   camera_far: 8e3,
	   bgcolor: 15658734,
	   length: 16
	}, {
	   model_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/duola.js",
	   texture_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/texture/duola/",
	   audio_file: "http://c.m.163.com/nc/qa/activity/kfa-swiper/events/childrens-day-2017/asset/mp3/duola_bgm.mp3",
	   texture_dict: duola_dict,
	   camera_fov: 70,
	   camera_far: 8e3,
	   bgcolor: 4276545,
	   length: 12
	}, {
	   model_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/hyrz.js",
	   texture_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/texture/hyrz/",
	   audio_file: "http://c.m.163.com/nc/qa/activity/kfa-swiper/events/childrens-day-2017/asset/mp3/hyrz_bgm.mp3",
	   texture_dict: hyrz_dict,
	   camera_fov: 90,
	   camera_far: 8e3,
	   bgcolor: 15658734,
	   length: 16
	}, {
	   model_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/msnzs.js",
	   texture_path: "http://img5.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/asset/texture/msnzs/",
	   audio_file: "http://c.m.163.com/nc/qa/activity/kfa-swiper/events/childrens-day-2017/asset/mp3/msnzs_bgm.mp3",
	   texture_dict: msnzs_dict,
	   camera_fov: 80,
	   camera_far: 8e3,
	   bgcolor: 15658734,
	   length: 20
	}];
	var edtime = chapters[chapterIndex].length;
	var edlay = msg[chapterIndex];
	var overlay_clock = false;
	var swiper = new KFASwiper({
	   time_scale: 1.2,
	   wrapper: document.getElementById("kfa-wrapper"),
	   on_texture_loading: function(item, loaded, total) {},
	   on_texture_loaded: function() {},
	   on_model_loaded: function(info) {},
	   onscroll: function(deltaY) {},
	   on_chapter_progress: function(innerChapterIndex, progress) {
	      if (chapterIndex === 0) {
	         if (progress < 5 && progress > .5) {
	            msgop.fadeOut()
	         } else if (progress < .5) {
	            msgop.fadeIn()
	         }
	      } else if (chapterIndex === 4) {
	         if (progress > 4 && progress < 7.6) {
	            msgmsn.fadeIn()
	         } else {
	            msgmsn.fadeOut()
	         }
	      }
	      if (progress > edtime) {
	         edlay.fadeIn(600)
	      } else {
	         edlay.fadeOut(600)
	      }
	   },
	   chapters: [chapters[chapterIndex]]
	});
	$(".nextbtn").on("click touchstart", function() {
	   window.location.href = window.location.pathname + "?chapter=" + (chapterIndex + 1)
	});
	$(".replay-btn").on("click touchstart", function() {
	   window.location.href = window.location.pathname
	});
	if (isNewsApp) {
	   $(".download-btn").hide();
	   $(".share-btn").on("click touchstart", function() {
	      NewsAppClient.share()
	   })
	} else {
	   $(".share-btn").hide()
	}
	var shareData = {
	   title: "",
	   desc: "",
	   img_url: "http://img3.cache.netease.com/utf8/3g/kfa-swiper/events/childrens-day-2017/build/image/share-thumb.jpg",
	   link: "http://c.m.163.com/nc/qa/activity/kfa-swiper/events/childrens-day-2017/index.html"
	};
	document.addEventListener("WeixinJSBridgeReady", function() {
	   WeixinJSBridge.on("menu:share:timeline", function() {
	      WeixinJSBridge.invoke("shareTimeline", shareData, function() {
	         neteaseAnalysis({
	            type: "func",
	            spst: 1,
	            modelid: "newschildrenday",
	            func: "sharedone"
	         })
	      })
	   });
	   WeixinJSBridge.on("menu:share:appmessage", function() {
	      WeixinJSBridge.invoke("sendAppMessage", shareData, function() {
	         neteaseAnalysis({
	            type: "func",
	            spst: 1,
	            modelid: "newschildrenday",
	            func: "sharedone"
	         })
	      })
	   })
	}, false);
	//# sourceMappingURL=build/app.min.js.map

/***/ })

/******/ });